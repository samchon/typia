import { Tabs, Tab } from 'nextra-theme-docs'
import Alert from '@mui/material/Alert';
import AlertTitle from '@mui/material/AlertTitle';

## `stringify()` functions
<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
  <code>IValidation.ts</code>
]}>
  <Tab>
```typescript copy
export namespace json {
  export function stringify<T>(input: T): string;
  export function isStringify<T>(input: T | unknown): string | null;
  export function assertStringify<T>(input: T | unknown): string;
  export function validateStringify<T>(input: T | unknown): IValidation<string>;
}
```
  </Tab>
  <Tab>
```typescript copy
export class TypeGuardError extends Error {
  public readonly method: string;
  public readonly path: string | undefined;
  public readonly expected: string;
  public readonly value: any;
}
```
  </Tab>
  <Tab>
```typescript copy
export type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;
export namespace IValidation {
  export interface ISuccess<T> {
    success: true;
    data: T;
  }
  export interface IFailure {
    success: false;
    errors: IError[];
  }
  export interface IError {
    path: string;
    expected: string;
    value: any;
  }
}
```
  </Tab>
</Tabs>

You can boost up JSON serialization speed just by calling `typia.json.stringify<T>()` function. Also, you even can ensure type safety of JSON serialization by calling other functions like `typia.json.isStringify()` and `typia.json.assertStringify()` functions.

As `typia.json.stringify<T>()` function writes dedicated JSON serialization code only for the target type `T`, its performance is much faster than native `JSON.stringify()` function. However, because of the dedicated optimal JSON serialization code, when wrong typed data comes, unexpected error be occured.

Instead, `typia` supports type safe JSON serialization functions like `typia.json.isStringify()`. The `typia.json.isStringify()` is a combination function of `typia.is<T>()` and `typia.json.stringify<T>()` function. It checks whether the input value is valid for the target type `T` or not first, and operate JSON serialization later. If the input value is not matched with the type `T`, it returns `null` value.

  - `typia.json.isStringify()`: [`typia.is<T>()`](../validators/is) + `typia.json.stringify<T>()`
  - `typia.json.assertStringify()`: [`typia.assert<T>()`](../validators/assert) + `typia.json.stringify<T>()`
  - `typia.json.validateStringify()`: [`typia.validate<T>()`](../validators/validate) + `typia.json.stringify<T>()`

<br/>
<Alert severity="success">
  <AlertTitle> 
    **AOT compliation** 
  </AlertTitle>

`typia.json.isStringify()` and other similar functions are still much faster than native `JSON.stringify()` function, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.

</Alert>

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tab>
```typescript copy filename="examples/src/isStringify.ts" showLineNumbers
import typia, { tags } from "typia";

const department: IDepartment = typia.random<IDepartment>();
const json: string | null = typia.json.isStringify(department);

console.log(json); // not null, but string

interface IDepartment {
  id: string & tags.Format<"uuid">;
  name: string & tags.MinLength<3>;
  limit: number & tags.Type<"int32">;
  clerks: IClerk[];
}
interface IClerk {
  name: string;
  age: number 
    & tags.Type<"uint32"> 
    & tags.ExclusiveMinimum<19> 
    & tags.Maximum<100>;
  authority: number;
  joined_at: string & tags.Format<"date">;
}
```
  </Tab>
  <Tab>
```javascript filename="examples/bin/isStringify.js" showLineNumbers
import typia from "typia";
const department = ((generator) => {
  const $generator = typia.random.generator;
  const $ro0 = (_recursive = false, _depth = 0) => ({
    id:
      (generator?.customs ?? $generator.customs)?.string?.([
        {
          name: 'Format<"uuid">',
          kind: "format",
          value: "uuid",
        },
      ]) ?? (generator?.uuid ?? $generator.uuid)(),
    name:
      (generator?.customs ?? $generator.customs)?.string?.([
        {
          name: "MinLength<3>",
          kind: "minLength",
          value: 3,
        },
      ]) ??
      (generator?.string ?? $generator.string)(
        (generator?.integer ?? $generator.integer)(3, 25),
      ),
    limit:
      (generator?.customs ?? $generator.customs)?.number?.([
        {
          name: 'Type<"int32">',
          kind: "type",
          value: "int32",
        },
      ]) ?? (generator?.integer ?? $generator.integer)(0, 100),
    clerks: (generator?.array ?? $generator.array)(() =>
      $ro1(_recursive, _recursive ? 1 + _depth : _depth),
    ),
  });
  const $ro1 = (_recursive = false, _depth = 0) => ({
    name:
      (generator?.customs ?? $generator.customs)?.string?.([]) ??
      (generator?.string ?? $generator.string)(),
    age:
      (generator?.customs ?? $generator.customs)?.number?.([
        {
          name: 'Type<"uint32">',
          kind: "type",
          value: "uint32",
        },
        {
          name: "ExclusiveMinimum<19>",
          kind: "exclusiveMinimum",
          value: 19,
        },
        {
          name: "Maximum<100>",
          kind: "maximum",
          value: 100,
        },
      ]) ?? (generator?.integer ?? $generator.integer)(19, 100),
    authority:
      (generator?.customs ?? $generator.customs)?.number?.([]) ??
      (generator?.number ?? $generator.number)(0, 100),
    joined_at:
      (generator?.customs ?? $generator.customs)?.string?.([
        {
          name: 'Format<"date">',
          kind: "format",
          value: "date",
        },
      ]) ?? (generator?.date ?? $generator.date)(),
  });
  return $ro0();
})();
const json = (() => {
  const $string = typia.json.isStringify.string;
  const $number = typia.json.isStringify.number;
  const $io0 = (input) =>
    "string" === typeof input.id &&
    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(
      input.id,
    ) &&
    "string" === typeof input.name &&
    3 <= input.name.length &&
    "number" === typeof input.limit &&
    Math.floor(input.limit) === input.limit &&
    -2147483648 <= input.limit &&
    input.limit <= 2147483647 &&
    Array.isArray(input.clerks) &&
    input.clerks.every(
      (elem) => "object" === typeof elem && null !== elem && $io1(elem),
    );
  const $io1 = (input) =>
    "string" === typeof input.name &&
    "number" === typeof input.age &&
    Math.floor(input.age) === input.age &&
    0 <= input.age &&
    input.age <= 4294967295 &&
    19 < input.age &&
    input.age <= 100 &&
    "number" === typeof input.authority &&
    !Number.isNaN(input.authority) &&
    "string" === typeof input.joined_at &&
    /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/.test(input.joined_at);
  const $so0 = (input) =>
    `{"id":${$string(input.id)},"name":${$string(input.name)},"limit":${$number(input.limit)},"clerks":${`[${input.clerks.map((elem) => $so1(elem)).join(",")}]`}}`;
  const $so1 = (input) =>
    `{"name":${$string(input.name)},"age":${$number(input.age)},"authority":${$number(input.authority)},"joined_at":${$string(input.joined_at)}}`;
  const __is = (input) =>
    "object" === typeof input && null !== input && $io0(input);
  const __stringify = (input) => $so0(input);
  return (input) => (__is(input) ? __stringify(input) : null);
})()(department);
console.log(json); // not null, but string
```
  </Tab>
</Tabs>




## Reusable functions
<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
  <code>IValidation.ts</code>
]}>
  <Tab>
```typescript copy
export namespace json {
  export function createStringify<T>: (input: T) => string;
  export function createIsStringify<T>: (
      input: T | unknown
  ) => string | null;
  export function createAssertStringify<T>: (
      input: T | unknown
  ) => string;
  export function createValidateStringify<T>: (
      input: T | unknown
  ) => IValidation<string>;
}
```
  </Tab>
  <Tab>
```typescript copy
export class TypeGuardError extends Error {
  public readonly method: string;
  public readonly path: string | undefined;
  public readonly expected: string;
  public readonly value: any;
}
```
  </Tab>
  <Tab>
```typescript copy
export type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;
export namespace IValidation {
  export interface ISuccess<T> {
    success: true;
    data: T;
  }
  export interface IFailure {
    success: false;
    errors: IError[];
  }
  export interface IError {
    path: string;
    expected: string;
    value: any;
  }
}
```
  </Tab>
</Tabs>

Reusable `typia.json.stringify<T>()` function generators.

If you repeat to call `typia.json.stringify<T>()` function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through `typia.json.createStringify<T>()` function.

Just look at the code below, then you may understand how to use it.

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tab>
```typescript copy filename="examples/src/createAssertStringify.ts" showLineNumbers
import typia, { tags } from "typia";

export const assertDepartment = typia.json.createAssertStringify<IDepartment>();

interface IDepartment {
  id: string & tags.Format<"uuid">;
  name: string & tags.MinLength<3>;
  limit: number & tags.Type<"int32">;
  clerks: IClerk[];
}
interface IClerk {
  name: string;
  age: number &
    tags.Type<"uint32"> &
    tags.ExclusiveMinimum<19> &
    tags.Maximum<100>;
  authority: number;
  joined_at: string & tags.Format<"date">;
}
```
  </Tab>
  <Tab>
```javascript filename="examples/bin/createAssertStringify.js" showLineNumbers
import typia from "typia";
export const assertDepartment = (() => {
  const $guard = typia.json.createAssertStringify.guard;
  const $string = typia.json.createAssertStringify.string;
  const $io0 = (input) =>
    "string" === typeof input.id &&
    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(
      input.id,
    ) &&
    "string" === typeof input.name &&
    3 <= input.name.length &&
    "number" === typeof input.limit &&
    Math.floor(input.limit) === input.limit &&
    -2147483648 <= input.limit &&
    input.limit <= 2147483647 &&
    Array.isArray(input.clerks) &&
    input.clerks.every(
      (elem) => "object" === typeof elem && null !== elem && $io1(elem),
    );
  const $io1 = (input) =>
    "string" === typeof input.name &&
    "number" === typeof input.age &&
    Math.floor(input.age) === input.age &&
    0 <= input.age &&
    input.age <= 4294967295 &&
    19 < input.age &&
    input.age <= 100 &&
    "number" === typeof input.authority &&
    !Number.isNaN(input.authority) &&
    "string" === typeof input.joined_at &&
    /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/.test(input.joined_at);
  const $ao0 = (input, _path, _exceptionable = true) =>
    (("string" === typeof input.id &&
      (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(
        input.id,
      ) ||
        $guard(
          _exceptionable,
          {
            path: _path + ".id",
            expected: 'string & Format<"uuid">',
            value: input.id,
          },
          _errorFactory,
        ))) ||
      $guard(
        _exceptionable,
        {
          path: _path + ".id",
          expected: '(string & Format<"uuid">)',
          value: input.id,
        },
        _errorFactory,
      )) &&
    (("string" === typeof input.name &&
      (3 <= input.name.length ||
        $guard(
          _exceptionable,
          {
            path: _path + ".name",
            expected: "string & MinLength<3>",
            value: input.name,
          },
          _errorFactory,
        ))) ||
      $guard(
        _exceptionable,
        {
          path: _path + ".name",
          expected: "(string & MinLength<3>)",
          value: input.name,
        },
        _errorFactory,
      )) &&
    (("number" === typeof input.limit &&
      ((Math.floor(input.limit) === input.limit &&
        -2147483648 <= input.limit &&
        input.limit <= 2147483647) ||
        $guard(
          _exceptionable,
          {
            path: _path + ".limit",
            expected: 'number & Type<"int32">',
            value: input.limit,
          },
          _errorFactory,
        ))) ||
      $guard(
        _exceptionable,
        {
          path: _path + ".limit",
          expected: '(number & Type<"int32">)',
          value: input.limit,
        },
        _errorFactory,
      )) &&
    (((Array.isArray(input.clerks) ||
      $guard(
        _exceptionable,
        {
          path: _path + ".clerks",
          expected: "Array<IClerk>",
          value: input.clerks,
        },
        _errorFactory,
      )) &&
      input.clerks.every(
        (elem, _index2) =>
          ((("object" === typeof elem && null !== elem) ||
            $guard(
              _exceptionable,
              {
                path: _path + ".clerks[" + _index2 + "]",
                expected: "IClerk",
                value: elem,
              },
              _errorFactory,
            )) &&
            $ao1(
              elem,
              _path + ".clerks[" + _index2 + "]",
              true && _exceptionable,
            )) ||
          $guard(
            _exceptionable,
            {
              path: _path + ".clerks[" + _index2 + "]",
              expected: "IClerk",
              value: elem,
            },
            _errorFactory,
          ),
      )) ||
      $guard(
        _exceptionable,
        {
          path: _path + ".clerks",
          expected: "Array<IClerk>",
          value: input.clerks,
        },
        _errorFactory,
      ));
  const $ao1 = (input, _path, _exceptionable = true) =>
    ("string" === typeof input.name ||
      $guard(
        _exceptionable,
        {
          path: _path + ".name",
          expected: "string",
          value: input.name,
        },
        _errorFactory,
      )) &&
    (("number" === typeof input.age &&
      ((Math.floor(input.age) === input.age &&
        0 <= input.age &&
        input.age <= 4294967295) ||
        $guard(
          _exceptionable,
          {
            path: _path + ".age",
            expected: 'number & Type<"uint32">',
            value: input.age,
          },
          _errorFactory,
        )) &&
      (19 < input.age ||
        $guard(
          _exceptionable,
          {
            path: _path + ".age",
            expected: "number & ExclusiveMinimum<19>",
            value: input.age,
          },
          _errorFactory,
        )) &&
      (input.age <= 100 ||
        $guard(
          _exceptionable,
          {
            path: _path + ".age",
            expected: "number & Maximum<100>",
            value: input.age,
          },
          _errorFactory,
        ))) ||
      $guard(
        _exceptionable,
        {
          path: _path + ".age",
          expected:
            '(number & Type<"uint32"> & ExclusiveMinimum<19> & Maximum<100>)',
          value: input.age,
        },
        _errorFactory,
      )) &&
    (("number" === typeof input.authority && !Number.isNaN(input.authority)) ||
      $guard(
        _exceptionable,
        {
          path: _path + ".authority",
          expected: "number",
          value: input.authority,
        },
        _errorFactory,
      )) &&
    (("string" === typeof input.joined_at &&
      (/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/.test(
        input.joined_at,
      ) ||
        $guard(
          _exceptionable,
          {
            path: _path + ".joined_at",
            expected: 'string & Format<"date">',
            value: input.joined_at,
          },
          _errorFactory,
        ))) ||
      $guard(
        _exceptionable,
        {
          path: _path + ".joined_at",
          expected: '(string & Format<"date">)',
          value: input.joined_at,
        },
        _errorFactory,
      ));
  const $so0 = (input) =>
    `{"id":${$string(input.id)},"name":${$string(input.name)},"limit":${input.limit},"clerks":${`[${input.clerks.map((elem) => $so1(elem)).join(",")}]`}}`;
  const $so1 = (input) =>
    `{"name":${$string(input.name)},"age":${input.age},"authority":${input.authority},"joined_at":${$string(input.joined_at)}}`;
  const __is = (input) =>
    "object" === typeof input && null !== input && $io0(input);
  let _errorFactory;
  const __assert = (input, errorFactory) => {
    if (false === __is(input)) {
      _errorFactory = errorFactory;
      ((input, _path, _exceptionable = true) =>
        ((("object" === typeof input && null !== input) ||
          $guard(
            true,
            {
              path: _path + "",
              expected: "IDepartment",
              value: input,
            },
            _errorFactory,
          )) &&
          $ao0(input, _path + "", true)) ||
        $guard(
          true,
          {
            path: _path + "",
            expected: "IDepartment",
            value: input,
          },
          _errorFactory,
        ))(input, "$input", true);
    }
    return input;
  };
  const __stringify = (input) => $so0(input);
  return (input, errorFactory) => {
    __assert(input, errorFactory);
    return __stringify(input);
  };
})();
```
  </Tab>
</Tabs>




## Performance
Comparing JSON serialization speed with others, it is maximum 200x faster than `class-transformer`.

For reference, `class-transformer` is the most famous library used in `NestJS` with `class-validator`. Also, `fast-json-stringify` is another famous one used in `fastify`. However, whether they are fast or slow, both of them require extra schema definition, that is different with TypeScript type. If you see the code below without experience of them, you may get shocked: how complicate and inefficient they are:

 - `fast-json-stringify` requires [JSON schema definition](https://github.com/samchon/typia/blob/master/test/schemas/json/swagger/ObjectHierarchical.json).
 - `class-validator` requires [DTO class with decorator function calls](https://github.com/samchon/typia/blob/master/benchmark/structures/class-validator/ClassValidatorObjectHierarchical.ts).

![Stringify Function Benchmark](https://github.com/samchon/typia/raw/master/benchmark/results/AMD%20Ryzen%209%207940HS%20w%20Radeon%20780M%20Graphics/images/stringify.svg)

> Measured on [AMD Ryzen 9 7940HS, Rog Flow x13](https://github.com/samchon/typia/tree/master/benchmark/results/AMD%20Ryzen%209%207940HS%20w%20Radeon%20780M%20Graphics#stringify)




## Server Performance
Someone may ask:

> JSON serialization speed affects on the server performance? 
>
> I think that the JSON serialization is just a tiny thing in the server side, isn't it?

My answer is, "Yes, it affects on the server performance".

Most operations in NodeJS server are asynchronously executed in background thread, what are called "event based non-blocking I/O model". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.

I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.

![Server Benchmark](https://raw.githubusercontent.com/samchon/typia/master/benchmark/results/AMD%20Ryzen%209%207940HS%20w%20Radeon%20780M%20Graphics/images/server.svg)

> Measured on [AMD Ryzen 9 7940HS, Rog Flow x13](https://github.com/samchon/typia/tree/master/benchmark/results/AMD%20Ryzen%209%207940HS%20w%20Radeon%20780M%20Graphics#server)