---
title: Guide Documents > Large Language Model > application() function
---
import { Callout, Tabs } from "nextra/components";

import LocalSource from "../../../components/LocalSource";

## `application()` function

<Tabs items={[
    <code>typia</code>,
    <code>ILlmApplication</code>,
    <code>ILlmFunction</code>,
    <code>ILlmSchema</code>,
  ]}>
  <Tabs.Tab>
```typescript filename="typia" showLineNumbers {2-9}
export namespace llm {
  // LLM FUNCTION CALLING APPLICATION SCHEMA
  export function application<
    App extends Record<string, any>,
    Config extends Partial<ILlmSchema.IConfig> = {},
  >(
    config?: Partial<Pick<ILlmApplication.IConfig, "separate">>,
  ): ILlmApplication;

  // STRUCTURED OUTPUT
  export function parameters<
    Parameters extends Record<string, any>,
    Config extends Partial<ILlmSchema.IConfig> = {},
  >(): ILlmSchema.IParameters;

  // TYPE SCHEMA
  export function schema<
    T,
    Config extends Partial<ILlmSchema.IConfig> = {},
  >(
    $defs: Record<string, ILlmSchema>,
  ): ILlmSchema;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="packages/interface/src/schema/ILlmApplication.ts"
      filename="@typia/interface"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="packages/interface/src/schema/ILlmFunction.ts"
      filename="@typia/interface"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="packages/interface/src/schema/ILlmSchema.ts"
      filename="@typia/interface"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

LLM function calling application schema from a native TypeScript class or interface type.

`typia.llm.application<App>()` is a function composing LLM (Large Language Model) calling application schema from a native TypeScript class or interface type. The function returns an `ILlmApplication` instance, which is a data structure representing a collection of LLM function calling schemas.

If you put LLM function schema instances registered in the `ILlmApplication.functions` to the LLM provider like `OpenAI ChatGPT`, the LLM will select a proper function to call with parameter values of the target function in the conversations with the user. This is the "LLM Function Calling".

Let's make A.I. Chatbot super-easily with `typia.llm.application<App>()` function.

<Callout type="info">
**LLM Function Calling** and **Structured Output**

LLM selects proper function and fill arguments.

In nowadays, most LLM (Large Language Model) like OpenAI are supporting "function calling" feature. The "LLM function calling" means that LLM automatically selects a proper function and fills parameter values from conversation with the user (may by chatting text).

Structured output is another feature of LLM. The "structured output" means that LLM automatically transforms the output conversation into a structured data format like JSON.

- https://platform.openai.com/docs/guides/function-calling
- https://platform.openai.com/docs/guides/structured-outputs
</Callout>

<Tabs items={[
    "TypeScript Source Code",
    "Compiled JavaScript",
    <code>BbsArticleService</code>,
    <code>IBbsArticle</code>,
  ]}>
  <Tabs.Tab>
    <LocalSource 
      path="examples/src/llm/application.ts"
      filename="example/src/llm/application.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="examples/bin/llm/application.js"
      filename="example/bin/llm/application.js"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="examples/src/llm/BbsArticleService.ts"
      filename="examples/src/llm/BbsArticleService.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="examples/src/llm/IBbsArticle.ts"
      filename="examples/src/llm/IBbsArticle.ts"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

> [üíª Playground Link](/playground/?script=JYWwDg9gTgLgBAbzgSQDIBsQEExncAYwEMZgIA7OAXzgDMoIQ4AiAAQGciQCALCgeghgApuSJhgzANwAoUJFhwYATwlE6DJsxVrpMuHPDR4SAEIAjdlliF0wgMrCoAN0LDqGxiwB0-C1ZsCO0cXNz0DAgp2eHEwAC4UDGxcfGJSCjgAXiVVYCJvdExvWNSSMnIAHn9rUiCHJ1cCYQA+AAoASllI8nYIOwKIAHNW2M6gA)

## Validation Feedback

`typia.llm.application<App>()` embeds [`typia.validate<T>()`](/docs/validators/validate) in every function for automatic argument validation. When validation fails, the error is returned as text content with inline `// ‚ùå` comments at each invalid property:

```json
{
  "name": "John",
  "age": "twenty", // ‚ùå [{"path":"$input.age","expected":"number"}]
  "email": "not-an-email", // ‚ùå [{"path":"$input.email","expected":"string & Format<\"email\">"}]
  "hobbies": "reading" // ‚ùå [{"path":"$input.hobbies","expected":"Array<string>"}]
}
```

The LLM reads this feedback and self-corrects on the next turn.

In the [AutoBe](https://github.com/wrtnlabs/autobe) project (AI-powered backend code generator), `qwen3-coder-next` showed only 6.75% raw function calling success rate on compiler AST types. However, with validation feedback, it reached 100%.

Working on compiler AST means working on any type and any use case.

  - [AutoBeDatabase](https://github.com/wrtnlabs/autobe/blob/main/packages/interface/src/database/AutoBeDatabase.ts)
  - [AutoBeOpenApi](https://github.com/wrtnlabs/autobe/blob/main/packages/interface/src/openapi/AutoBeOpenApi.ts)
  - [AutoBeTest](https://github.com/wrtnlabs/autobe/blob/main/packages/interface/src/test/AutoBeTest.ts)

```typescript filename="AutoBeTest.IExpression" showLineNumbers
// Compiler AST may be the hardest type structure possible
//
// Unlimited union types + unlimited depth + recursive references
export type IExpression =
  | IBooleanLiteral
  | INumericLiteral
  | IStringLiteral
  | IArrayLiteralExpression   // <- recursive (contains IExpression[])
  | IObjectLiteralExpression  // <- recursive (contains IExpression)
  | INullLiteral
  | IUndefinedKeyword
  | IIdentifier
  | IPropertyAccessExpression // <- recursive
  | IElementAccessExpression  // <- recursive
  | ITypeOfExpression         // <- recursive
  | IPrefixUnaryExpression    // <- recursive
  | IPostfixUnaryExpression   // <- recursive
  | IBinaryExpression         // <- recursive (left & right)
  | IArrowFunction            // <- recursive (body is IExpression)
  | ICallExpression           // <- recursive (args are IExpression[])
  | INewExpression            // <- recursive
  | IConditionalPredicate     // <- recursive (then & else branches)
  | ... // 30+ expression types total
```

## Restrictions

`typia.llm.application<App>()` follows the same restrictions of below.

About the function parameters type, it follows the restriction of both [`typia.llm.parameters<Params>()`](../parameters) and [`typia.llm.schema<T>()`](../schema) functions. Therefore, the parameters must be a keyworded object type with static keys without any dynamic keys. Also, the object type must not be nullable or optional.

About the return value type, it follows the restriction of [`typia.llm.schema<T>()`](../schema) function. By the way, if the return type is union type with `undefined`, it would be compilation error, due to OpenAPI (JSON schema) specification does not support the undefindable union type.

  - [`typia.llm.parameters<Params>()`](../parameters)
  - [`typia.llm.schema<T>()`](../schema)

<Tabs items={["TypeScript Source Code", "Console Output"]}>
  <Tabs.Tab>
```typescript filename="example/src/llm/application.violation.ts" showLineNumbers
import { ILlmApplication } from "@samchon/openapi";
import typia, { tags } from "typia";

const app: ILlmApplication = typia.llm.application<BbsArticleController>();

console.log(app);

interface BbsArticleController {
  /**
   * Create a new article.
   *
   * Writes a new article and archives it into the DB.
   *
   * @param props Properties of create function
   * @returns Newly created article
   */
  create(props: {
    /**
     * Information of the article to create
     */
    input: IBbsArticle.ICreate;
  }): Promise<IBbsArticle | undefined>;

  erase(id: string & tags.Format<"uuid">): Promise<void>;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
```bash filename="Terminal"
src/examples/llm.application.violation.ts:4:29 - error TS(typia.llm.application): unsupported type detected

- BbsArticleController.create: unknown
  - LLM application's function ("create")'s return type must not be union type with undefined.

- BbsArticleController.erase: unknown
  - LLM application's function ("erase")'s parameter must be an object type.

4 const app: ILlmApplication = typia.llm.application<BbsArticleController>();
                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Found 1 error in src/examples/llm.application.violation.ts:4
```
  </Tabs.Tab>
</Tabs>
