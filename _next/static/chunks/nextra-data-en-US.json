{"/docs/llm/application":{"title":"Guide Documents > Large Language Model > application() function","data":{"application-function#application() function":"export namespace llm {\n  // LLM FUNCTION CALLING APPLICATION SCHEMA\n  export function application<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplication.IOptions<Model>, \"separate\">>,\n  ): ILlmApplication<Model>;\n  // STRUCTURED OUTPUT\n  export function parameters<\n    Parameters extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(): ILlmSchema.ModelParameters[Model];\n  // TYPE SCHEMA\n  export function schema<\n    T,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    ...$defs: Extract<\n      ILlmSchema.ModelSchema[Model],\n      { $ref: string }\n    > extends never\n      ? []\n      : [Record<string, ILlmSchema.ModelSchema[Model]>]\n  ): ILlmSchema.ModelSchema[Model];\n}\nLLM function calling application schema from a native TypeScript class or interface type.typia.llm.application<App, Model>() is a function composing LLM (Large Language Model) calling application schema from a native TypeScript class or interface type. The function returns an ILlmApplication instance, which is a data structure representing a collection of LLM function calling schemas.If you put LLM function schema instances registered in the ILlmApplication.functions to the LLM provider like OpenAI ChatGPT, the LLM will select a proper function to call with parameter values of the target function in the conversations with the user. This is the \"LLM Function Calling\".You can specify the LLM provide model by the second Model template argument. It's because detailed specification of the function schema is different by the LLM provider model. Here is the list of LLM schema definitions of each model. Determine one of them carefully reading the LLM schema definitions.If you've determined, let's make A.I. Chatbot super-easily with typia.llm.application<App, Model>() function.\nSupported schemas\nIChatGptSchema: OpenAI ChatGPT\nIClaudeSchema: Anthropic Claude\nIGeminiSchema: Google Gemini\nILlamaSchema: Meta Llama\nMidldle layer schemas\nILlmSchemaV3: middle layer based on OpenAPI v3.0 specification\nILlmSchemaV3_1: middle layer based on OpenAPI v3.1 specification\nLLM Function Calling and Structured OutputLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"LLM function calling\" means that LLM automatically selects a proper function and fills parameter values from conversation with the user (may by chatting text).Structured output is another feature of LLM. The \"structured output\" means that LLM automatically transforms the output conversation into a structured data format like JSON.\nhttps://platform.openai.com/docs/guides/function-calling\nhttps://platform.openai.com/docs/guides/structured-outputs\n💻 Playground Link","validation-feedback#Validation Feedback":"Is LLM Function Calling perfect? No, absolutely not.LLM (Large Language Model) service vendor like OpenAI takes a lot of type level mistakes when composing the arguments of function calling or structured output. Even though target schema is super simple like Array<string> type, LLM often fills it just by a string typed value.In my experience, OpenAI gpt-4o-mini (8b parameters) is taking about 70% of type level mistakes when filling the arguments of function calling to Shopping Mall service. To overcome the imperfection of such LLM function calling, typia.llm.application<App, Model>() function embeds typia.validate<T>() function for the validation feedback strategy.The key concept of validation feedback strategy is, let LLM function calling to construct invalid typed arguments first, and informing detailed type errors to the LLM, so that induce LLM to emend the wrong typed arguments at the next turn. In this way, I could uprise the success rate of function calling from 30% to 99% just by one step validation feedback. Even though the LLM is still occurs type error, it always has been caught at the next turn.For reference, the embedded typia.validate<T>() function creates validation logic by analyzing TypeScript source codes and types in the compilation level. Therefore, it is accurate and detailed than any other validator libraries. This is exactly what is needed for function calling, and I can confidentelly say that typia is the best library for LLM function calling.\nAdditionally, this validation feedback strategy is useful for some LLM providers do not supporting restriction properties of JSON schema like OpenAI (IChatGptSchema) and Gemini (IGeminiSchema). For example, OpenAI and Gemini do not support format property of JSON schema, so that cannot understand the UUID like type. Even though typia.llm.application<App, Model>() function is writing the restriction information to the description property of JSON schema, but LLM provider does not reflect it perfectly.Also, some LLM providers which have not specified the JSON schema version like Claude (IClaudeSchema) and Llama (ILlamaSchema), they tend to fail a lot of function calling about the restriction properties. In fact, Llama does not support function calling formally, so you have to detour it by prompt template, and its success rate is lower than others.In that case, if you give validation feedback from ILlmFunction.validate() function to the LLM agent, the LLM agent will be able to understand the restriction information exactly and fill the arguments properly.\nRestriction properties of JSON schema\nstring: minLength, maxLength, pattern, format, contentMediaType\nnumber: minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf\narray: minItems, maxItems, uniqueItems, items","parameters-separation#Parameters' Separation":"Parameter values from both LLM and Human sides.When composing parameter arguments through the LLM (Large Language Model) function calling, there can be a case that some parameters (or nested properties) must be composed not by LLM, but by Human. File uploading feature, or sensitive information like secret key (password) cases are the representative examples.In that case, you can configure the LLM function calling schemas to exclude such Human side parameters (or nested properties) by ILlmApplication.options.separate property. Instead, you have to merge both Human and LLM composed parameters into one by calling the HttpLlm.mergeParameters() before the LLM function call execution.Here is the example separating the parameter schemas.\n💻 Playground Link","restrictions#Restrictions":"typia.llm.application<App, Model>() follows the same restrictions of below.About the function parameters type, it follows the restriction of both typia.llm.parameters<Params, Models>() and typia.llm.schema<T, Model>() functions. Therefore, the parameters must be a keyworded object type with static keys without any dynamic keys. Also, the object type must not be nullable or optional.About the return value type, it follows the restriction of typia.llm.schema<T, Model>() function. By the way, if the return type is union type with undefined, it would be compilation error, due to OpenAPI (JSON schema) specification does not support the undefindable union type.\ntypia.llm.parameters<Params, Models>()\ntypia.llm.schema<T, Model>()\nimport { ILlmApplication } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\"\n>();\nconsole.log(app);\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle | undefined>;\n  erase(id: string & tags.Format<\"uuid\">): Promise<void>;\n}\nsrc/examples/llm.application.violation.ts:4:41 - error TS(typia.llm.application): unsupported type detected    \n- BbsArticleController.create: unknown\n  - LLM application's function (\"create\")'s return type must not be union type with undefined.    \n- BbsArticleController.erase: unknown\n  - LLM application's function (\"erase\")'s parameter must be an object type.\n4 const app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n                                          ~~~~~~~~~~~~~~~~~~~~~~\n5   BbsArticleController,\n  ~~~~~~~~~~~~~~~~~~~~~~~\n6   \"chatgpt\"\n  ~~~~~~~~~~~\n7 >();\n  ~~~\nFound 1 error in src/examples/llm.application.violation.ts:4"}},"/docs/llm/parameters":{"title":"Guide Documents > Large Language Model > parameters() function","data":{"parameters-function#parameters() function":"export namespace llm {\n  // LLM FUNCTION CALLING APPLICATION SCHEMA\n  export function application<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplication.IOptions<Model>, \"separate\">>,\n  ): ILlmApplication<Model>;\n  // +VALIDATE FUNCTION EMBEDDED\n  export function applicationOfValidate<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplicationOfValidate.IOptions<Model>, \"separate\">>,\n  ): ILlmApplicationOfValidate<Model>;\n  // STRUCTURED OUTPUT\n  export function parameters<\n    Parameters extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(): ILlmSchema.ModelParameters[Model];\n  // TYPE SCHEMA\n  export function schema<\n    T,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    ...$defs: Extract<\n      ILlmSchema.ModelSchema[Model],\n      { $ref: string }\n    > extends never\n      ? []\n      : [Record<string, ILlmSchema.ModelSchema[Model]>]\n  ): ILlmSchema.ModelSchema[Model];\n}\nStructured output schema of LLM (Large Language Model).typia.llm.parameters<Parameters, Model>() is a function generating structured output of LLM (Large Language Model) from a TypeScript object type. It is used to LLM function calling or structured output feature provided by OpenAI like LLM providers.Return value type ILlmSchema.IParameters is a similar with the JSON schema definition's object type. However, its detailed specification becomes different by LLM provider model you've chosen. Here is the list of LLM schema definitions of each model. Determine one of them carefully reading the LLM schema definitions.\nSupported schemas\nIChatGptSchema: OpenAI ChatGPT\nIClaudeSchema: Anthropic Claude\nIGeminiSchema: Google Gemini\nILlamaSchema: Meta Llama\nMidldle layer schemas\nILlmSchemaV3: middle layer based on OpenAPI v3.0 specification\nILlmSchemaV3_1: middle layer based on OpenAPI v3.1 specification\nLLM Function Calling and Structured OutputLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"LLM function calling\" means that LLM automatically selects a proper function and fills parameter values from conversation with the user (may by chatting text).Structured output is another feature of LLM. The \"structured output\" means that LLM automatically transforms the output conversation into a structured data format like JSON.\nhttps://platform.openai.com/docs/guides/function-calling\nhttps://platform.openai.com/docs/guides/structured-outputs\n📖 Playground Link","structured-output#Structured Output":"import OpenAI from \"openai\";\nimport typia, { tags } from \"typia\";\ninterface IMember {\n  email: string & tags.Format<\"email\">;\n  name: string;\n  age: number;\n  hobbies: string[];\n  joined_at: string & tags.Format<\"date\">;\n}\nconst main = async (): Promise<void> => {\n  const client: OpenAI = new OpenAI({\n    apiKey: TestGlobal.env.CHATGPT_API_KEY,\n    // apiKey: \"<YOUR_OPENAI_API_KEY>\",\n  });\n  const completion: OpenAI.ChatCompletion =\n    await client.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            \"I am a new member of the community.\",\n            \"\",\n            \"My name is John Doe, and I am 25 years old.\",\n            \"I like playing basketball and reading books,\",\n            \"and joined to this community at 2022-01-01.\",\n          ].join(\"\\n\"),\n        },\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"member\",\n          schema: typia.llm.parameters<IMember, \"chatgpt\">() as any,\n        },\n      },\n    });\n  console.log(JSON.parse(completion.choices[0].message.content!));\n};\nmain().catch(console.error);\n{\n  email: 'john.doe@example.com',\n  name: 'John Doe',\n  age: 25,\n  hobbies: [ 'playing basketball', 'reading books' ],\n  joined_at: '2022-01-01'\n}\nYou can utilize the typia.llm.parameters<Parameters, Model>() function to generate structured output like above.Just configure output mode as JSON schema, and deliver the typia.llm.parameters<Parameters, Model>() function returned value to the LLM provider like OpenAI (ChatGPT). Then, the LLM provider will automatically transform the output conversation into a structured data format of the Parameters type.","validation-feedback#Validation Feedback":"import OpenAI from \"openai\";\nimport typia, { IValidation, tags } from \"typia\";\ninterface IMember {\n  email: string & tags.Format<\"email\">;\n  name: string;\n  age: number;\n  hobbies: string[];\n  joined_at: string & tags.Format<\"date\">;\n}\nconst step = async (\n  failure?: IValidation.IFailure | undefined,\n): Promise<IValidation<IMember>> => {\n  const client: OpenAI = new OpenAI({\n    apiKey: \"<YOUR_OPENAI_API_KEY>\",\n  });\n  const completion: OpenAI.ChatCompletion =\n    await client.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            \"I am a new member of the community.\",\n            \"\",\n            \"My name is John Doe, and I am 25 years old.\",\n            \"I like playing basketball and reading books,\",\n            \"and joined to this community at 2022-01-01.\",\n          ].join(\"\\n\"),\n        },\n        ...(failure\n          ? [\n              {\n                role: \"system\",\n                content: [\n                  \"You A.I. agent had taken a mistak that\",\n                  \"returning wrong typed structured data.\",\n                  \"\",\n                  \"Here is the detailed list of type errors.\",\n                  \"Review and correct them at the next step.\",\n                  \"\",\n                  \"```json\",\n                  JSON.stringify(failure.errors, null, 2),\n                  \"```\",\n                ].join(\"\\n\"),\n              } satisfies OpenAI.ChatCompletionSystemMessageParam,\n            ]\n          : []),\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"member\",\n          schema: typia.llm.parameters<IMember, \"chatgpt\">() as any,\n        },\n      },\n    });\n  const member: IMember = JSON.parse(completion.choices[0].message.content!);\n  return typia.validate(member);\n};\nconst main = async (): Promise<void> => {\n  let result: IValidation<IMember> | undefined = undefined;\n  for (let i: number = 0; i < 2; ++i) {\n    if (result && result.success === true) break;\n    result = await step(result);\n  }\n  console.log(result);\n};\nmain().catch(console.error);\n{\n  email: 'john.doe@example.com',\n  name: 'John Doe',\n  age: 25,\n  hobbies: [ 'playing basketball', 'reading books' ],\n  joined_at: '2022-01-01'\n}\nIs LLM Structured Output perfect? No, absolutely not.LLM (Large Language Model) service vendor like OpenAI takes a lot of type level mistakes when composing the arguments of function calling or structured output. Even though target schema is super simple like Array<string> type, LLM often fills it just by a string typed value.In my experience, OpenAI gpt-4o-mini (8b parameters) is taking about 70% of type level mistakes when filling the arguments of structured output to Shopping Mall service. To overcome the imperfection of such structured output, you have to utilize the validation feedback strategy with typia.validate<T>() function.The key concept of validation feedback strategy is, let LLM structured output to construct invalid typed arguments first, and informing detailed type errors to the LLM, so that induce LLM to emend the wrong typed arguments at the next turn. In this way, I could uprise the success rate of structured output from 30% to 99% just by one step validation feedback. Even though the LLM is still occurs type error, it always has been caught at the next turn.For reference, the typia.validate<T>() function creates validation logic by analyzing TypeScript source codes and types in the compilation level. Therefore, it is accurate and detailed than any other validator libraries. This is exactly what is needed for function calling, and I can confidentelly say that typia is the best library for LLM structured output.\nAdditionally, this validation feedback strategy is useful for some LLM providers do not supporting restriction properties of JSON schema like OpenAI (IChatGptSchema) and Gemini (IGeminiSchema). For example, OpenAI and Gemini do not support format property of JSON schema, so that cannot understand the UUID like type. Even though typia.llm.application<App, Model>() function is writing the restriction information to the description property of JSON schema, but LLM provider does not reflect it perfectly.Also, some LLM providers which have not specified the JSON schema version like Claude (IClaudeSchema) and Llama (ILlamaSchema), they tend to fail a lot of function calling about the restriction properties. In fact, Llama does not support the structured output formally, so you have to detour it by prompt template, and its success rate is lower than others.In that case, if you give validation feedback from ILlmFunction.validate() function to the LLM agent, the LLM agent will be able to understand the restriction information exactly and fill the arguments properly.\nRestriction properties of JSON schema\nstring: minLength, maxLength, pattern, format, contentMediaType\nnumber: minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf\narray: minItems, maxItems, uniqueItems, items","restrictions#Restrictions":"typia.llm.parameters<Parameters, Model>() follows the same restrictions typia.llm.schema<T, Model>() function. Also, it has only one additional restriction; the keyworded argument.In the LLM function calling and structured output, the parameters must be a keyworded object type with static keys without any dynamic keys. Also, the object type must not be nullable or optional.If you don't follow the LLM's keyworded arguments rule, typia.llm.parameters<Parameters, Model>() will throw compilation error like below.\nimport typia from \"typia\";\ntypia.llm.parameters<string>();\ntypia.llm.parameters<Record<string, boolean>, \"chatgpt\">();\ntypia.llm.parameters<Array<number>>();\nsrc/examples/llm.parameters.violation.ts:3:1 - error TS(typia.llm.parameters): unsupported type detected       \n- string\n  - LLM parameters must be an object type.        \n3 typia.llm.parameters<string, \"chatgpt\">();     \n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      \nsrc/examples/llm.parameters.violation.ts:3:22 - error TS2344: Type 'string' does not satisfy the constraint 'Record<string, any>'.\n3 typia.llm.parameters<string, \"chatgpt\">();     \n                       ~~~~~~\nsrc/examples/llm.parameters.violation.ts:4:1 - error TS(typia.llm.parameters): unsupported type detected       \n- Recordstringboolean\n  - LLM parameters must be an object type.        \n- Recordstringboolean\n  - LLM parameters must not have dynamic keys.   \n  - LLM schema of \"gemini\" does not support dynamic property in object.\n- Recordstringboolean: Recordstringboolean       \n  - LLM schema of \"gemini\" does not support dynamic property in object.\n4 typia.llm.parameters<Record<string, boolean>, \"gemini\">();\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/examples/llm.parameters.violation.ts:5:1 - error TS(typia.llm.parameters): unsupported type detected       \n- Arraynumber\n  - LLM parameters must be an object type.        \n5 typia.llm.parameters<Array<number>, \"claude\">();\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nFound 4 errors in the same file, starting at: src/examples/llm.parameters.violation.ts"}},"/docs/misc":{"title":"Guide Documents > Miscellaneous","data":{"misc-module#misc module":"","clone-functions#clone() functions":"export namespace misc {\n  export function clone<T>(input: T): T;\n  export function assertClone<T>(input: T | unknown): Resolved<T>;\n  export function isClone<T>(input: T | unknown): Resolved<T> | null;\n  export function validateClone<T>(input: T | unknown): IValidation<Resolved<T>>;\n  export function createClone<T>(): (input: T) => Resolved<T>;\n  export function createAssertClone<T>(): (input: T | unknown) => Resolved<T>;\n  export function createIsClone<T>(): (input: T | unknown) => Resolved<T> | null;\n  export function createValidateClone<T>(): (\n      input: T | unknown\n  ) => IValidation<Resolved<T>>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\nDeep copy functions.When you want to copy an instance, just call typia.misc.clone() function. It would perform deep copy including nested objects, so you can get a new instance with same values. Also, if you want type safe deep copy function, you can use typia.misc.isClone(), typia.misc.assertClone() or typia.misc.validateClone() functions instead.\ntypia.misc.assertClone(): typia.assert<T>() + typia.misc.clone<T>()\ntypia.misc.isClone(): typia.is<T>() + typia.misc.clone<T>()\ntypia.misc.validateClone(): typia.validate<T>() + typia.misc.clone<T>()\nimport typia from \"typia\";\nconst department: IDepartment = typia.random<IDepartment>();\nconst cloned: IDepartment = typia.misc.assertClone(department);\nconsole.log(cloned);\ninterface IDepartment {\n  /**\n   * @format uuid\n   */\n  id: string;\n  /**\n   * @minLength 3\n   */\n  name: string;\n  /**\n   * @type int\n   */\n  limit: number;\n  clerks: IClerk[];\n}\ninterface IClerk {\n  name: string;\n  /**\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  age: number;\n  authority: number;\n  /**\n   * @format date\n   */\n  joined_at: string;\n}\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__randomArray from \"typia/lib/internal/_randomArray.js\";\nimport * as __typia_transform__randomNumber from \"typia/lib/internal/_randomNumber.js\";\nimport * as __typia_transform__randomFormatDate from \"typia/lib/internal/_randomFormatDate.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nconst department = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n        minLength: 3,\n      },\n    ),\n    limit: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n    }),\n    clerks: (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n      type: \"array\",\n      element: () => _ro1(_recursive, _recursive ? 1 + _depth : _depth),\n    }),\n  });\n  const _ro1 = (_recursive = false, _depth = 0) => ({\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n      },\n    ),\n    age: (_generator?.number ?? __typia_transform__randomNumber._randomNumber)({\n      type: \"number\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n    }),\n    authority: (\n      _generator?.number ?? __typia_transform__randomNumber._randomNumber\n    )({\n      type: \"number\",\n    }),\n    joined_at: (\n      _generator?.date ?? __typia_transform__randomFormatDate._randomFormatDate\n    )(),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconst cloned = (() => {\n  const _cp0 = (input) => input.map((elem) => _co1(elem));\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\n      input.id,\n    ) &&\n    \"string\" === typeof input.name &&\n    3 <= input.name.length &&\n    \"number\" === typeof input.limit &&\n    Math.floor(input.limit) === input.limit &&\n    -2147483648 <= input.limit &&\n    input.limit <= 2147483647 &&\n    Array.isArray(input.clerks) &&\n    input.clerks.every(\n      (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n    );\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    \"number\" === typeof input.age &&\n    19 < input.age &&\n    input.age <= 100 &&\n    \"number\" === typeof input.authority &&\n    \"string\" === typeof input.joined_at &&\n    /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/.test(input.joined_at);\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\n        input.id,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.name &&\n      (3 <= input.name.length ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".name\",\n            expected: \"string & MinLength<3>\",\n            value: input.name,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".name\",\n          expected: \"(string & MinLength<3>)\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.limit &&\n      ((Math.floor(input.limit) === input.limit &&\n        -2147483648 <= input.limit &&\n        input.limit <= 2147483647) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".limit\",\n            expected: 'number & Type<\"int32\">',\n            value: input.limit,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".limit\",\n          expected: '(number & Type<\"int32\">)',\n          value: input.limit,\n        },\n        _errorFactory,\n      )) &&\n    (((Array.isArray(input.clerks) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      )) &&\n      input.clerks.every(\n        (elem, _index2) =>\n          (((\"object\" === typeof elem && null !== elem) ||\n            __typia_transform__assertGuard._assertGuard(\n              _exceptionable,\n              {\n                method: \"typia.misc.assertClone\",\n                path: _path + \".clerks[\" + _index2 + \"]\",\n                expected: \"IClerk\",\n                value: elem,\n              },\n              _errorFactory,\n            )) &&\n            _ao1(\n              elem,\n              _path + \".clerks[\" + _index2 + \"]\",\n              true && _exceptionable,\n            )) ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.misc.assertClone\",\n              path: _path + \".clerks[\" + _index2 + \"]\",\n              expected: \"IClerk\",\n              value: elem,\n            },\n            _errorFactory,\n          ),\n      )) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      ));\n  const _ao1 = (input, _path, _exceptionable = true) =>\n    (\"string\" === typeof input.name ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".name\",\n          expected: \"string\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".age\",\n          expected: \"(number & ExclusiveMinimum<19> & Maximum<100>)\",\n          value: input.age,\n        },\n        _errorFactory,\n      )) &&\n    (\"number\" === typeof input.authority ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".authority\",\n          expected: \"number\",\n          value: input.authority,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.joined_at &&\n      (/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/.test(\n        input.joined_at,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".joined_at\",\n            expected: 'string & Format<\"date\">',\n            value: input.joined_at,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".joined_at\",\n          expected: '(string & Format<\"date\">)',\n          value: input.joined_at,\n        },\n        _errorFactory,\n      ));\n  const _co0 = (input) => ({\n    id: input.id,\n    name: input.name,\n    limit: input.limit,\n    clerks: _cp0(input.clerks),\n  });\n  const _co1 = (input) => ({\n    name: input.name,\n    age: input.age,\n    authority: input.authority,\n    joined_at: input.joined_at,\n  });\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  const __assert = (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.misc.assertClone\",\n              path: _path + \"\",\n              expected: \"IDepartment\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \"\",\n            expected: \"IDepartment\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n  const __clone = (input) => _co0(input);\n  return (input, errorFactory) => __clone(__assert(input, errorFactory));\n})()(department);\nconsole.log(cloned);","prune-functions#prune() functions":"export function prune<T>(input: T): void;\nexport function assertPrune<T>(input: T | unknown): T;\nexport function isPrune<T>(input: T | unknown): T | null;\nexport function validatePrune<T>(input: T | unknown): IValidation<T>;\nexport function createPrune<T>(): (input: T) => void;\nexport function createAssertPrune<T>(): (input: T | unknown) => T;\nexport function createIsPrune<T>(): (input: T | unknown) => T | null;\nexport function createValidatePrune<T>(): (input: T | unknown) => IValidation<T>;\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T = unknown> =\n  | IValidation.ISuccess<T>\n  | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T = unknown> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\nDeep prune functions.When you want to remove every extra properties that are not defined in the type including nested objects, you can use typia.misc.prune<T>() function. Also, if you want to perform type safe pruning, you can use typia.misc.isPrune<T>(), typia.misc.assertPrune<T>() or typia.misc.validatePrune<T>() functions instead.\ntypia.misc.isPrune(): typia.is<T>() + typia.misc.prune<T>()\ntypia.misc.assertPrune(): typia.assert<T>() + typia.misc.prune<T>()\ntypia.misc.validatePrune(): typia.validate<T>() + typia.misc.prune<T>()\nimport typia from \"typia\";\nconst department: IDepartment = typia.random<IDepartment>();\nconst pruned: IDepartment = typia.misc.assertPrune(department);\nconsole.log(pruned);\ninterface IDepartment {\n  /**\n   * @format uuid\n   */\n  id: string;\n  /**\n   * @minLength 3\n   */\n  name: string;\n  /**\n   * @type int\n   */\n  limit: number;\n  clerks: IClerk[];\n}\ninterface IClerk {\n  name: string;\n  /**\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  age: number;\n  authority: number;\n  /**\n   * @format date\n   */\n  joined_at: string;\n}\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__randomArray from \"typia/lib/internal/_randomArray.js\";\nimport * as __typia_transform__randomNumber from \"typia/lib/internal/_randomNumber.js\";\nimport * as __typia_transform__randomFormatDate from \"typia/lib/internal/_randomFormatDate.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nconst department = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n        minLength: 3,\n      },\n    ),\n    limit: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n    }),\n    clerks: (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n      type: \"array\",\n      element: () => _ro1(_recursive, _recursive ? 1 + _depth : _depth),\n    }),\n  });\n  const _ro1 = (_recursive = false, _depth = 0) => ({\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n      },\n    ),\n    age: (_generator?.number ?? __typia_transform__randomNumber._randomNumber)({\n      type: \"number\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n    }),\n    authority: (\n      _generator?.number ?? __typia_transform__randomNumber._randomNumber\n    )({\n      type: \"number\",\n    }),\n    joined_at: (\n      _generator?.date ?? __typia_transform__randomFormatDate._randomFormatDate\n    )(),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconst pruned = (() => {\n  const _pp0 = (input) =>\n    input.forEach((elem) => {\n      if (\"object\" === typeof elem && null !== elem) _po1(elem);\n    });\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\n      input.id,\n    ) &&\n    \"string\" === typeof input.name &&\n    3 <= input.name.length &&\n    \"number\" === typeof input.limit &&\n    Math.floor(input.limit) === input.limit &&\n    -2147483648 <= input.limit &&\n    input.limit <= 2147483647 &&\n    Array.isArray(input.clerks) &&\n    input.clerks.every(\n      (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n    );\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    \"number\" === typeof input.age &&\n    19 < input.age &&\n    input.age <= 100 &&\n    \"number\" === typeof input.authority &&\n    \"string\" === typeof input.joined_at &&\n    /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/.test(input.joined_at);\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\n        input.id,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.name &&\n      (3 <= input.name.length ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \".name\",\n            expected: \"string & MinLength<3>\",\n            value: input.name,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".name\",\n          expected: \"(string & MinLength<3>)\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.limit &&\n      ((Math.floor(input.limit) === input.limit &&\n        -2147483648 <= input.limit &&\n        input.limit <= 2147483647) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \".limit\",\n            expected: 'number & Type<\"int32\">',\n            value: input.limit,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".limit\",\n          expected: '(number & Type<\"int32\">)',\n          value: input.limit,\n        },\n        _errorFactory,\n      )) &&\n    (((Array.isArray(input.clerks) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      )) &&\n      input.clerks.every(\n        (elem, _index2) =>\n          (((\"object\" === typeof elem && null !== elem) ||\n            __typia_transform__assertGuard._assertGuard(\n              _exceptionable,\n              {\n                method: \"typia.misc.assertPrune\",\n                path: _path + \".clerks[\" + _index2 + \"]\",\n                expected: \"IClerk\",\n                value: elem,\n              },\n              _errorFactory,\n            )) &&\n            _ao1(\n              elem,\n              _path + \".clerks[\" + _index2 + \"]\",\n              true && _exceptionable,\n            )) ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.misc.assertPrune\",\n              path: _path + \".clerks[\" + _index2 + \"]\",\n              expected: \"IClerk\",\n              value: elem,\n            },\n            _errorFactory,\n          ),\n      )) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      ));\n  const _ao1 = (input, _path, _exceptionable = true) =>\n    (\"string\" === typeof input.name ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".name\",\n          expected: \"string\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".age\",\n          expected: \"(number & ExclusiveMinimum<19> & Maximum<100>)\",\n          value: input.age,\n        },\n        _errorFactory,\n      )) &&\n    (\"number\" === typeof input.authority ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".authority\",\n          expected: \"number\",\n          value: input.authority,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.joined_at &&\n      (/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/.test(\n        input.joined_at,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \".joined_at\",\n            expected: 'string & Format<\"date\">',\n            value: input.joined_at,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".joined_at\",\n          expected: '(string & Format<\"date\">)',\n          value: input.joined_at,\n        },\n        _errorFactory,\n      ));\n  const _po0 = (input) => {\n    if (Array.isArray(input.clerks)) _pp0(input.clerks);\n    for (const key of Object.keys(input)) {\n      if (\"id\" === key || \"name\" === key || \"limit\" === key || \"clerks\" === key)\n        continue;\n      delete input[key];\n    }\n  };\n  const _po1 = (input) => {\n    for (const key of Object.keys(input)) {\n      if (\n        \"name\" === key ||\n        \"age\" === key ||\n        \"authority\" === key ||\n        \"joined_at\" === key\n      )\n        continue;\n      delete input[key];\n    }\n  };\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  const __assert = (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.misc.assertPrune\",\n              path: _path + \"\",\n              expected: \"IDepartment\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \"\",\n            expected: \"IDepartment\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n  const __prune = (input) => {\n    if (\"object\" === typeof input && null !== input) _po0(input);\n  };\n  return (input, errorFactory) => {\n    input = __assert(input, errorFactory);\n    __prune(input);\n    return input;\n  };\n})()(department);\nconsole.log(pruned);","literals-function#literals() function":"export namespace misc {\n  export function literals<\n    T extends boolean | number | string | bigint | null,\n  >(): T[];\n}\nUnion literal type to array.When you call typia.misc.literals<T>() function with union literal type, it returns an array of literal values listed in the generic T argument. This typia.misc.literals<T> function is useful when you are developing test program, especially handling some discriminated union types.\nimport typia from \"typia\";\ntypia.misc.literals<\"A\" | \"B\" | \"C\" | 1 | 2n>();\nimport typia from \"typia\";\n[\"A\", \"B\", \"C\", 1, BigInt(2)];","notations-module#notations module":"","camel-functions#camel() functions":"export namespace notations {\n  export function camel<T>(input: T): CamelCase<T>;\n  export function assertCamel<T>(input: T | unknown): CamelCase<T>;\n  export function isCamel<T>(input: T | unknown): CamelCase<T> | null;\n  export function validateCamel<T>(\n    input: T | unknown,\n  ): IValidation<CamelCase<T>>;\n  export function createCamel<T>(): (input: T) => CamelCase<T>;\n  export function createAssertCamel<T>(): (input: T | unknown) => CamelCase<T>;\n  export function createIsCamel<T>(): (\n    input: T | unknown,\n  ) => CamelCase<T> | null;\n  export function createValidateCamel<T>(): (\n    input: T | unknown,\n  ) => IValidation<CamelCase<T>>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Camel case type.\n *\n * `CamelCase` type is a type that all keys of an object are camelized.\n *\n * It also erase every method properties like {@link Resolved} type.\n *\n * @template T Target type to be camelized\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type CamelCase<T> = Equal<T, CamelizeMain<T>> extends true\n  ? T\n  : CamelizeMain<T>;\n/* -----------------------------------------------------------\n    OBJECT CONVERSION\n----------------------------------------------------------- */\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype CamelizeMain<T> = T extends [never]\n  ? never // special trick for (jsonable | null) type\n  : T extends { valueOf(): boolean | bigint | number | string }\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? CamelizeObject<T>\n  : T;\ntype CamelizeObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? CamelizeTuple<T>\n    : CamelizeMain<U>[]\n  : T extends Set<infer U>\n  ? Set<CamelizeMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<CamelizeMain<K>, CamelizeMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [Key in keyof T as CamelizeString<Key & string>]: CamelizeMain<T[Key]>;\n    };\n/* -----------------------------------------------------------\n    SPECIAL CASES\n----------------------------------------------------------- */\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype CamelizeTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [CamelizeMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [CamelizeMain<F>, ...CamelizeTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [CamelizeMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [CamelizeMain<F>?, ...CamelizeTuple<Rest>]\n  : [];\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n/* -----------------------------------------------------------\n    STRING CONVERTER\n----------------------------------------------------------- */\ntype CamelizeString<Key extends string> = Key extends `_${infer R}`\n  ? `_${CamelizeString<R>}`\n  : Key extends `${infer F}${infer R}`\n  ? `${Lowercase<F>}${CamelizeStringRepeatedly<R>}`\n  : Key;\ntype CamelizeStringRepeatedly<Key extends string> =\n  Key extends `${infer F}_${infer R}`\n    ? `${F}${Capitalize<CamelizeStringRepeatedly<R>>}`\n    : Key;\nCamel case converters.Convert every property names of nested objects to be camel case notation.When you need type safe functions, you can utilize below them.\ntypia.notations.assertCamel<T>(): typia.assert<T>() + typia.notations.camel<T>()\ntypia.notations.isCamel<T>: typia.is<T>() + typia.notations.camel<T>()\ntypia.notations.validateCamel<T>: typia.validate<T>() + typia.notations.camel<T>()\nimport typia from \"typia\";\ninterface IPerson {\n  is_my_name_samchon?: boolean;\n  HelloTheNewWorld: string;\n  ToHTML: string;\n}\ntypia.notations.createCamel<IPerson>();\nimport typia from \"typia\";\n(() => {\n  const $co0 = (input) => ({\n    isMyNameSamchon: input.is_my_name_samchon,\n    helloTheNewWorld: input.HelloTheNewWorld,\n    toHTML: input.ToHTML,\n  });\n  return (input) =>\n    \"object\" === typeof input && null !== input ? $co0(input) : input;\n})();","pascal-functions#pascal() functions":"export namespace notations {\n  export function pascal<T>(input: T): PascalCase<T>;\n  export function assertPascal<T>(input: T | unknown): PascalCase<T>;\n  export function isPascal<T>(input: T | unknown): PascalCase<T> | null;\n  export function validatePascal<T>(\n    input: T | unknown,\n  ): IValidation<PascalCase<T>>;\n  export function createPascal<T>(): (input: T) => PascalCase<T>;\n  export function createAssertPascal<T>(): (\n    input: T | unknown,\n  ) => PascalCase<T>;\n  export function createIsPascal<T>(): (\n    input: T | unknown,\n  ) => PascalCase<T> | null;\n  export function createValidatePascal<T>(): (\n    input: T | unknown,\n  ) => IValidation<PascalCase<T>>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Pascal case type.\n *\n * `PascalCase` type is a type that all keys of an object are pascalized.\n *\n * It also erase every method properties like {@link Resolved} type.\n *\n * @template T Target type to be pascalized\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type PascalCase<T> = Equal<T, PascalizeMain<T>> extends true\n  ? T\n  : PascalizeMain<T>;\n/* -----------------------------------------------------------\n    OBJECT CONVERSION\n----------------------------------------------------------- */\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype PascalizeMain<T> = T extends [never]\n  ? never // special trick for (jsonable | null) type\n  : T extends { valueOf(): boolean | bigint | number | string }\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? PascalizeObject<T>\n  : T;\ntype PascalizeObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? PascalizeTuple<T>\n    : PascalizeMain<U>[]\n  : T extends Set<infer U>\n  ? Set<PascalizeMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<PascalizeMain<K>, PascalizeMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [Key in keyof T as PascalizeString<Key & string>]: PascalizeMain<T[Key]>;\n    };\n/* -----------------------------------------------------------\n    SPECIAL CASES\n----------------------------------------------------------- */\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype PascalizeTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [PascalizeMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [PascalizeMain<F>, ...PascalizeTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [PascalizeMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [PascalizeMain<F>?, ...PascalizeTuple<Rest>]\n  : [];\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n/* -----------------------------------------------------------\n    STRING CONVERTER\n----------------------------------------------------------- */\ntype PascalizeString<Key extends string> = Key extends `_${infer R}`\n  ? `_${PascalizeString<R>}`\n  : Key extends `${infer F}${infer R}`\n  ? `${Uppercase<F>}${PascalizeStringRepeatedly<R>}`\n  : Key;\ntype PascalizeStringRepeatedly<Key extends string> =\n  Key extends `${infer F}_${infer R}`\n    ? `${F}${Capitalize<PascalizeStringRepeatedly<R>>}`\n    : Key;\nPascal case converters.Convert every property names of nested objects to be pascal case notation.When you need type safe functions, you can utilize below them.\ntypia.notations.assertPascal<T>(): typia.assert<T>() + typia.notations.pascal<T>()\ntypia.notations.isPascal<T>: typia.is<T>() + typia.notations.pascal<T>()\ntypia.notations.validatePascal<T>: typia.validate<T>() + typia.notations.pascal<T>()\nimport typia from \"typia\";\ninterface IPerson {\n  is_my_name_samchon?: boolean;\n  helloTheNewWorld: string;\n  toHTML: string;\n}\ntypia.notations.createPascal<IPerson>();\nimport typia from \"typia\";\n(() => {\n  const $co0 = (input) => ({\n    IsMyNameSamchon: input.is_my_name_samchon,\n    HelloTheNewWorld: input.helloTheNewWorld,\n    ToHTML: input.toHTML,\n  });\n  return (input) =>\n    \"object\" === typeof input && null !== input ? $co0(input) : input;\n})();","snake-functions#snake() functions":"export namespace notations {\n  export function snake<T>(input: T): SnakeCase<T>;\n  export function assertSnake<T>(input: T | unknown): SnakeCase<T>;\n  export function isSnake<T>(input: T | unknown): SnakeCase<T> | null;\n  export function validateSnake<T>(\n    input: T | unknown,\n  ): IValidation<SnakeCase<T>>;\n  export function createSnake<T>(): (input: T) => SnakeCase<T>;\n  export function createAssertSnake<T>(): (input: T | unknown) => SnakeCase<T>;\n  export function createIsSnake<T>(): (\n    input: T | unknown,\n  ) => SnakeCase<T> | null;\n  export function createValidateSnake<T>(): (\n    input: T | unknown,\n  ) => IValidation<SnakeCase<T>>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Snake case type.\n *\n * `SnakeCase` type is a type that all keys of an object are converted to snake case.\n *\n * It also erase every method properties like {@link Resolved} type.\n *\n * @template T Target type to be snake cased\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type SnakeCase<T> = Equal<T, SnakageMain<T>> extends true\n  ? T\n  : SnakageMain<T>;\n/* -----------------------------------------------------------\n    OBJECT CONVERSION\n----------------------------------------------------------- */\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype SnakageMain<T> = T extends [never]\n  ? never // special trick for (jsonable | null) type\n  : T extends { valueOf(): boolean | bigint | number | string }\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? SnakageObject<T>\n  : T;\ntype SnakageObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? SnakageTuple<T>\n    : SnakageMain<U>[]\n  : T extends Set<infer U>\n  ? Set<SnakageMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<SnakageMain<K>, SnakageMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [Key in keyof T as SnakageString<Key & string>]: SnakageMain<T[Key]>;\n    };\n/* -----------------------------------------------------------\n    SPECIAL CASES\n----------------------------------------------------------- */\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype SnakageTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [SnakageMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [SnakageMain<F>, ...SnakageTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [SnakageMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [SnakageMain<F>?, ...SnakageTuple<Rest>]\n  : [];\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n/* -----------------------------------------------------------\n    STRING CONVERTER\n----------------------------------------------------------- */\ntype SnakageString<Key extends string> = Key extends `${infer _}`\n  ? SnakageStringRepeatedly<Key, \"\">\n  : Key;\ntype SnakageStringRepeatedly<\n  S extends string,\n  Previous extends string,\n> = S extends `${infer First}${infer Second}${infer Rest}`\n  ? `${Underscore<Previous, First>}${Lowercase<First>}${Underscore<\n      First,\n      Second\n    >}${Lowercase<Second>}${SnakageStringRepeatedly<Rest, Second>}`\n  : S extends `${infer First}`\n  ? `${Underscore<Previous, First>}${Lowercase<First>}`\n  : \"\";\ntype Underscore<First extends string, Second extends string> = First extends\n  | UpperAlphabetic\n  | \"\"\n  | \"_\"\n  ? \"\"\n  : Second extends UpperAlphabetic\n  ? \"_\"\n  : \"\";\ntype UpperAlphabetic =\n  | \"A\"\n  | \"B\"\n  | \"C\"\n  | \"D\"\n  | \"E\"\n  | \"F\"\n  | \"G\"\n  | \"H\"\n  | \"I\"\n  | \"J\"\n  | \"K\"\n  | \"L\"\n  | \"M\"\n  | \"N\"\n  | \"O\"\n  | \"P\"\n  | \"Q\"\n  | \"R\"\n  | \"S\"\n  | \"T\"\n  | \"U\"\n  | \"V\"\n  | \"W\"\n  | \"X\"\n  | \"Y\"\n  | \"Z\";\nSnake case converters.Convert every property names of nested objects to be snake case notation.When you need type safe functions, you can utilize below them.\ntypia.notations.assertSnake<T>(): typia.assert<T>() + typia.notations.snake<T>()\ntypia.notations.isSnake<T>: typia.is<T>() + typia.notations.snake<T>()\ntypia.notations.validateSnake<T>: typia.validate<T>() + typia.notations.snake<T>()\nimport typia from \"typia\";\ninterface IPerson {\n  isMyNameSamchon?: boolean;\n  HelloTheNewWorld: string;\n  ToHTML: string;\n}\ntypia.notations.createSnake<IPerson>();\nimport typia from \"typia\";\n(() => {\n  const $co0 = (input) => ({\n    is_my_name_samchon: input.isMyNameSamchon,\n    hello_the_new_world: input.HelloTheNewWorld,\n    to_html: input.ToHTML,\n  });\n  return (input) =>\n    \"object\" === typeof input && null !== input ? $co0(input) : input;\n})();","http-module#http module":"Nestia Supporting\nhttp module has been designed to support the nestia project.\nquery() functions -> @TypedQuery()\nheaders() functions -> @TypedHeaders()\nparameter() function -> @TypedParam()","query-functions#query() functions":"export namespace http {\n  export function query<T extends object>(input: Query): Resolved<T>;\n  export function assertQuery<T extends object>(input: Query): Resolved<T>;\n  export function isQuery<T extends object>(input: Query): Resolved<T> | null;\n  export function validateQuery<T extends object>(\n    input: Query,\n  ): IValidation<Resolved<T>>;\n  export function createQuery<T extends object>(): (\n    input: Query,\n  ) => Resolved<T>;\n  export function createAssertQuery<T extends object>(): (\n    input: Query,\n  ) => Resolved<T>;\n  export function createIsQuery<T extends object>(): (\n    input: Query,\n  ) => Resolved<T> | null;\n  export function createValidateQuery<T extends object>(): (\n    input: Query,\n  ) => IValidation<Resolved<T>>;\n}\ntype Query = string | URLSearchParams;\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\nURL query decoder functions.typia.http.query<T>() is a function decoding a query string or an URLSearchParams instance, with automatic type casting to the expected type. When property type be defined as boolean or number type, typia.http.query<T>() will cast the value to the expected type when decoding.By the way, as URL query is not enough to express complex data structures, typia.http.query<T>() function has some limitations. If target type T is not following those restrictions, compilation errors would be occurred.\nType T must be an object type\nDo not allow dynamic property\nOnly boolean, bigint, number, string or their array types are allowed\nBy the way, union type never be not allowed\nAlso, typia.http.query<T>() function does not perform validation about the decoded value. Therefore, if you can't sure that input data is following the T type, it would better to call one of below functions instead.\ntypia.http.assertQuery<T>(): typia.assert<T>() + typia.http.query<T>()\ntypia.http.isQuery<T>(): typia.is<T>() + typia.http.query<T>()\ntypia.http.validateQuery<T>(): typia.validate<T>() + typia.http.query<T>()\nimport typia from \"typia\";\ninterface IQuery {\n  limit?: number;\n  enforce: boolean;\n  values?: string[];\n  atomic: string | null;\n  indexes: number[];\n}\ntypia.http.createQuery<IQuery>();\nimport * as __typia_transform__httpQueryParseURLSearchParams from \"typia/lib/internal/_httpQueryParseURLSearchParams.js\";\nimport * as __typia_transform__httpQueryReadNumber from \"typia/lib/internal/_httpQueryReadNumber.js\";\nimport * as __typia_transform__httpQueryReadBoolean from \"typia/lib/internal/_httpQueryReadBoolean.js\";\nimport * as __typia_transform__httpQueryReadString from \"typia/lib/internal/_httpQueryReadString.js\";\nimport * as __typia_transform__httpQueryReadArray from \"typia/lib/internal/_httpQueryReadArray.js\";\nimport typia from \"typia\";\n(() => {\n  return (input) => {\n    input =\n      __typia_transform__httpQueryParseURLSearchParams._httpQueryParseURLSearchParams(\n        input,\n      );\n    const output = {\n      limit:\n        __typia_transform__httpQueryReadNumber._httpQueryReadNumber(\n          input.get(\"limit\"),\n        ) ?? undefined,\n      enforce: __typia_transform__httpQueryReadBoolean._httpQueryReadBoolean(\n        input.get(\"enforce\"),\n      ),\n      values: __typia_transform__httpQueryReadArray._httpQueryReadArray(\n        input\n          .getAll(\"values\")\n          .map((elem) =>\n            __typia_transform__httpQueryReadString._httpQueryReadString(elem),\n          ),\n        undefined,\n      ),\n      atomic: __typia_transform__httpQueryReadString._httpQueryReadString(\n        input.get(\"atomic\"),\n      ),\n      indexes: input\n        .getAll(\"indexes\")\n        .map((elem) =>\n          __typia_transform__httpQueryReadNumber._httpQueryReadNumber(elem),\n        ),\n    };\n    return output;\n  };\n})();","headers-functions#headers() functions":"export namespace http {\n  export function headers<T extends object>(input: Headers): Resolved<T>;\n  export function assertHeaders<T extends object>(input: Headers): Resolved<T>;\n  export function isHeaders<T extends object>(\n    input: Headers,\n  ): Resolved<T> | null;\n  export function validateHeaders<T extends object>(\n    input: Headers,\n  ): IValidation<Resolved<T>>;\n  export function createHeaders<T extends object>(): (\n    input: Headers,\n  ) => Resolved<T>;\n  export function createAssertHeaders<T extends object>(): (\n    input: Headers,\n  ) => Resolved<T>;\n  export function createIsHeaders<T extends object>(): (\n    input: Headers,\n  ) => Resolved<T> | null;\n  export function createValidateHeaders<T extends object>(): (\n    input: Headers,\n  ) => IValidation<Resolved<T>>;\n}\ntype Headers = Record<string, string | string[] | undefined>;\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\nHeaders decoder (for express and fastify).typia.http.headers<t>() is a function decoding an header instance, with automatic type casting to the expected type. When property type be defined as boolean or number type, typia.http.headers<t>() will cast the value to the expected type.By the way, as HTTP headers are not enough to express complex data structures, typia.http.headers<t>() function has some limitations. If target type T is not following those restrictions, compilation errors would be occurred.\nType T must be an object type\nDo not allow dynamic property\nProperty key must be lower case\nProperty value cannot be null, but undefined is possible\nOnly boolean, bigint, number, string or their array types are allowed\nBy the way, union type never be not allowed\nProperty set-cookie must be array type\nThose properties cannot be array type\nage\nauthorization\ncontent-length\ncontent-type\netag\nexpires\nfrom\nhost\nif-modified-since\nif-unmodified-since\nlast-modified\nlocation\nmax-forwards\nproxy-authorization\nreferer\nretry-after\nserver\nuser-agent\nAlso, typia.http.headers<t>() function does not perform validation about the decoded value. Therefore, if you can't sure that input data is following the T type, it would better to call one of below functions instead.\ntypia.http.assertHeaders<T>(): typia.assert<T>() + typia.http.headers<T>()\ntypia.http.isHeaders<T>(): typia.is<T>() + typia.http.headers<T>()\ntypia.http.validateHeaders<T>(): typia.validate<T>() + typia.http.headers<T>()\nimport typia from \"typia\";\ninterface IHeaders {\n  \"x-Category\": \"x\" | \"y\" | \"z\";\n  \"x-MEMO\"?: string;\n  \"x-nAmE\"?: string;\n  \"x-Values\": number[];\n  \"x-FlAgS\": boolean[];\n  \"X-Descriptions\": string[];\n}\ntypia.http.createHeaders<IHeaders>();\nimport * as __typia_transform__httpHeaderReadNumber from \"typia/lib/internal/_httpHeaderReadNumber.js\";\nimport * as __typia_transform__httpHeaderReadBoolean from \"typia/lib/internal/_httpHeaderReadBoolean.js\";\nimport typia from \"typia\";\n(() => {\n  return (input) => {\n    const output = {\n      \"x-Category\": input[\"x-category\"],\n      \"x-MEMO\": input[\"x-memo\"],\n      \"x-nAmE\": input[\"x-name\"],\n      \"x-Values\": Array.isArray(input[\"x-values\"])\n        ? input[\"x-values\"].map(\n            __typia_transform__httpHeaderReadNumber._httpHeaderReadNumber,\n          )\n        : (input[\"x-values\"]\n            ?.split(\", \")\n            ?.map(\n              __typia_transform__httpHeaderReadNumber._httpHeaderReadNumber,\n            ) ?? []),\n      \"x-FlAgS\": Array.isArray(input[\"x-flags\"])\n        ? input[\"x-flags\"].map(\n            __typia_transform__httpHeaderReadBoolean._httpHeaderReadBoolean,\n          )\n        : (input[\"x-flags\"]\n            ?.split(\", \")\n            ?.map(\n              __typia_transform__httpHeaderReadBoolean._httpHeaderReadBoolean,\n            ) ?? []),\n      \"X-Descriptions\": Array.isArray(input[\"x-descriptions\"])\n        ? input[\"x-descriptions\"].map((str) => str.trim())\n        : (input[\"x-descriptions\"]?.split(\", \")?.map((str) => str.trim()) ??\n          []),\n    };\n    return output;\n  };\n})();","parameter-functions#parameter() functions":"export namespace http {\n  export function parameter<T extends Atomic.Type | null>(input: string): T;\n  export function createParameter<T extends Atomic.Type | null>(): (\n    input: string,\n  ) => T;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nURL path parameter decoder.typia.http.parameter<T>() is a function decoding a path parameter, with automatic type casting to the expected type. When type T has been defined as boolean or number type, typia.http.parameter<T>() will cast the value to the expected type.Also, typia.http.parameter<T>() performs type assertion to the decoded value by combining with assert function. Therefore, when the decoded value is not following the T type, TypeGuardError would be thrown.\nimport typia, { tags } from \"typia\";\ntypia.http.createParameter<string & tags.Format<\"uuid\">>();\ntypia.http.createParameter<number & tags.Type<\"uint32\">>();\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport * as __typia_transform__httpParameterReadString from \"typia/lib/internal/_httpParameterReadString.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__httpParameterReadNumber from \"typia/lib/internal/_httpParameterReadNumber.js\";\nimport typia from \"typia\";\n(input) => {\n  const assert = (() => {\n    const __is = (input) =>\n      \"string\" === typeof input &&\n      __typia_transform__isFormatUuid._isFormatUuid(input);\n    let _errorFactory;\n    return (input, errorFactory) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          (\"string\" === typeof input &&\n            (__typia_transform__isFormatUuid._isFormatUuid(input) ||\n              __typia_transform__assertGuard._assertGuard(\n                true,\n                {\n                  method: \"typia.http.createParameter\",\n                  path: _path + \"\",\n                  expected: 'string & Format<\"uuid\">',\n                  value: input,\n                },\n                _errorFactory,\n              ))) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.http.createParameter\",\n              path: _path + \"\",\n              expected: '(string & Format<\"uuid\">)',\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  const value =\n    __typia_transform__httpParameterReadString._httpParameterReadString(input);\n  return assert(value);\n};\n(input) => {\n  const assert = (() => {\n    const __is = (input) =>\n      \"number\" === typeof input &&\n      __typia_transform__isTypeUint32._isTypeUint32(input);\n    let _errorFactory;\n    return (input, errorFactory) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          (\"number\" === typeof input &&\n            (__typia_transform__isTypeUint32._isTypeUint32(input) ||\n              __typia_transform__assertGuard._assertGuard(\n                true,\n                {\n                  method: \"typia.http.createParameter\",\n                  path: _path + \"\",\n                  expected: 'number & Type<\"uint32\">',\n                  value: input,\n                },\n                _errorFactory,\n              ))) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.http.createParameter\",\n              path: _path + \"\",\n              expected: '(number & Type<\"uint32\">)',\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  const value =\n    __typia_transform__httpParameterReadNumber._httpParameterReadNumber(input);\n  return assert(value);\n};"}},"/docs/random":{"title":"Guide Documents > random() function","data":{"random-function#random() function":"export function random<T>(g?: IRandomGenerator): Resolved<T>;\nimport { Customizable } from \"./typings/Customizable\";\nexport interface IRandomGenerator {\n  // REGULAR\n  boolean(): boolean;\n  integer(minimum?: number, maximum?: number): number;\n  bigint(minimum?: bigint, maximum?: bigint): bigint;\n  number(minimum?: number, maximum?: number): number;\n  string(length?: number): string;\n  array<T>(closure: (index: number) => T, count?: number): T[];\n  length(): number;\n  pattern(regex: RegExp): string;\n  //----\n  // FORMAT\n  //----\n  // SPECIAL CHARACTERS\n  byte(): string;\n  password(): string;\n  regex(): string;\n  uuid(): string;\n  // ADDRESSES\n  email(): string;\n  hostname(): string;\n  idnEmail(): string;\n  idnHostname(): string;\n  iri(): string;\n  iriReference(): string;\n  ipv4(): string;\n  ipv6(): string;\n  uri(): string;\n  uriReference(): string;\n  uriTemplate(): string;\n  url(): string;\n  // TIMESTAMPS\n  datetime(minimum?: number, maximum?: number): string;\n  date(minimum?: number, maximum?: number): string;\n  time(): string;\n  duration(): string;\n  // POINTERS\n  jsonPointer(): string;\n  relativeJsonPointer(): string;\n  customs?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\n  export type CustomMap = {\n    [Type in keyof Customizable]?: (\n      tags: ITypeTag[],\n    ) => Customizable[Type] | undefined;\n  };\n  export interface ITypeTag {\n    name: string;\n    kind: string;\n    value: any;\n  }\n}\nexport interface Customizable {\n  number: number;\n  string: string;\n  bigint: bigint;\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\nYou can make every random data just by calling typia.random<T>() function.When you call the typia.random<T>() function, typia will analyze your type T, and writes optimal random generation code for the type T, in the compilation level. This is called AOT (Ahead of Time) compilation, and you may understand what it is just by reading below example code.\nimport typia, { tags } from \"typia\";\nconst member: IMember = typia.random<IMember>();\nconsole.log(member);\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomFormatEmail from \"typia/lib/internal/_randomFormatEmail.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport typia from \"typia\";\nconst member = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    email: (\n      _generator?.email ??\n      __typia_transform__randomFormatEmail._randomFormatEmail\n    )(),\n    age: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n    }),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconsole.log(member);","reusable-function#Reusable function":"export function createRandom<T>(): (g?: IRandomGenerator) => Resolved<T>;\nimport { Customizable } from \"./typings/Customizable\";\nexport interface IRandomGenerator {\n  // REGULAR\n  boolean(): boolean;\n  integer(minimum?: number, maximum?: number): number;\n  bigint(minimum?: bigint, maximum?: bigint): bigint;\n  number(minimum?: number, maximum?: number): number;\n  string(length?: number): string;\n  array<T>(closure: (index: number) => T, count?: number): T[];\n  length(): number;\n  pattern(regex: RegExp): string;\n  //----\n  // FORMAT\n  //----\n  // SPECIAL CHARACTERS\n  byte(): string;\n  password(): string;\n  regex(): string;\n  uuid(): string;\n  // ADDRESSES\n  email(): string;\n  hostname(): string;\n  idnEmail(): string;\n  idnHostname(): string;\n  iri(): string;\n  iriReference(): string;\n  ipv4(): string;\n  ipv6(): string;\n  uri(): string;\n  uriReference(): string;\n  uriTemplate(): string;\n  url(): string;\n  // TIMESTAMPS\n  datetime(minimum?: number, maximum?: number): string;\n  date(minimum?: number, maximum?: number): string;\n  time(): string;\n  duration(): string;\n  // POINTERS\n  jsonPointer(): string;\n  relativeJsonPointer(): string;\n  customs?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\n  export type CustomMap = {\n    [Type in keyof Customizable]?: (\n      tags: ITypeTag[],\n    ) => Customizable[Type] | undefined;\n  };\n  export interface ITypeTag {\n    name: string;\n    kind: string;\n    value: any;\n  }\n}\nexport interface Customizable {\n  number: number;\n  string: string;\n  bigint: bigint;\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}","special-tags#Special Tags":"Runtime validators of typia provides additional type checking logic through Type Tags and Comment Tags. typia.random<T>() function also like that. typia.random<T>() function can utilize those tags to specialize the behavior of random data generation.For reference, whether you choose Type Tags or Comment Tags. typia.random<T>(), it is not a matter for typia.random<T>() function. Below two TypeScript codes are generating exactly same JavaScript code. Therefore, you can choose whatever you want considering your preference.\nimport typia, { tags } from \"typia\";\nconst data: TypeTag = typia.random<TypeTag>();\nconsole.log(data);\ninterface TypeTag {\n  type: number & tags.Type<\"int32\">;\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n  string: string & tags.MinLength<3>;\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n  format: (string & tags.Format<\"date-time\">) | null;\n}\nimport typia from \"typia\";\nconst data: CommentTag = typia.random<CommentTag>();\nconsole.log(data);\ninterface CommentTag {\n  /**\n   * @type int\n   */\n  type: number;\n  /**\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n  /**\n   * @minLength 3\n   */\n  string: string;\n  /**\n   * @pattern ^[a-z]+$\n   */\n  pattern: string;\n  /**\n   * @format date-time\n   */\n  format: string | null;\n}\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__randomNumber from \"typia/lib/internal/_randomNumber.js\";\nimport * as __typia_transform__randomPick from \"typia/lib/internal/_randomPick.js\";\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomPattern from \"typia/lib/internal/_randomPattern.js\";\nimport * as __typia_transform__randomFormatDatetime from \"typia/lib/internal/_randomFormatDatetime.js\";\nimport typia from \"typia\";\nconst data = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    type: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n    }),\n    number: __typia_transform__randomPick._randomPick([\n      () => undefined,\n      () =>\n        (_generator?.number ?? __typia_transform__randomNumber._randomNumber)({\n          type: \"number\",\n          exclusiveMinimum: true,\n          minimum: 19,\n          maximum: 100,\n        }),\n    ])(),\n    string: (\n      _generator?.string ?? __typia_transform__randomString._randomString\n    )({\n      type: \"string\",\n      minLength: 3,\n    }),\n    pattern: (\n      _generator?.pattern ?? __typia_transform__randomPattern._randomPattern\n    )(new RegExp(\"^[a-z]+$\")),\n    format: __typia_transform__randomPick._randomPick([\n      () => null,\n      () =>\n        (\n          _generator?.datetime ??\n          __typia_transform__randomFormatDatetime._randomFormatDatetime\n        )(),\n    ])(),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconsole.log(data);","customization#Customization":"export function random<T>(g?: IRandomGenerator): Resolved<T>;\nimport { Customizable } from \"./typings/Customizable\";\nexport interface IRandomGenerator {\n  // REGULAR\n  boolean(): boolean;\n  integer(minimum?: number, maximum?: number): number;\n  bigint(minimum?: bigint, maximum?: bigint): bigint;\n  number(minimum?: number, maximum?: number): number;\n  string(length?: number): string;\n  array<T>(closure: (index: number) => T, count?: number): T[];\n  length(): number;\n  pattern(regex: RegExp): string;\n  //----\n  // FORMAT\n  //----\n  // SPECIAL CHARACTERS\n  byte(): string;\n  password(): string;\n  regex(): string;\n  uuid(): string;\n  // ADDRESSES\n  email(): string;\n  hostname(): string;\n  idnEmail(): string;\n  idnHostname(): string;\n  iri(): string;\n  iriReference(): string;\n  ipv4(): string;\n  ipv6(): string;\n  uri(): string;\n  uriReference(): string;\n  uriTemplate(): string;\n  url(): string;\n  // TIMESTAMPS\n  datetime(minimum?: number, maximum?: number): string;\n  date(minimum?: number, maximum?: number): string;\n  time(): string;\n  duration(): string;\n  // POINTERS\n  jsonPointer(): string;\n  relativeJsonPointer(): string;\n  customs?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\n  export type CustomMap = {\n    [Type in keyof Customizable]?: (\n      tags: ITypeTag[],\n    ) => Customizable[Type] | undefined;\n  };\n  export interface ITypeTag {\n    name: string;\n    kind: string;\n    value: any;\n  }\n}\nexport interface Customizable {\n  number: number;\n  string: string;\n  bigint: bigint;\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\nYou can add custom type tags for random data generation.As above IRandomGenerator.CustomMap has a little bit complicate type, it may hard to understand for newcomers. However, such newcomers may easily understand, how to customize the random generation, just by reading the following example.Just define custom type tags like below, then everything would be done.For reference, when defining custom type tag, typia enforces user to define validate function literal for type safety. Never forget it when you define custom type tags for random generation. Such validation logic definition may enhance your random data generator logic when combining with typia.assert<T>() function.\nimport typia from \"typia\";\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\nconst data: TagCustom = typia.random<TagCustom>({\n  customs: {\n    string: (tags) => {\n      if (tags.find((t) => t.kind === \"dollar\") !== undefined)\n        return \"$\" + RandomGenerator.integer();\n      const postfix = tags.find((t) => t.kind === \"postfix\");\n      if (postfix !== undefined)\n        return RandomGenerator.string() + postfix.value;\n    },\n  },\n});\nconsole.log(data);\ninterface TagCustom {\n  id: string & typia.tags.Format<\"uuid\">;\n  dollar: string & Dolloar;\n  postfix: string & Postfix<\"abcd\">;\n  powerOf: number & PowerOf<2>;\n}\ntype Dolloar = typia.tags.TagBase<{\n  kind: \"dollar\";\n  target: \"string\";\n  value: undefined;\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\ntype Postfix<Value extends string> = typia.tags.TagBase<{\n  kind: \"postfix\";\n  target: \"string\";\n  value: Value;\n  validate: `$input.endsWith(\"${Value}\")`;\n}>;\ntype PowerOf<Value extends number> = typia.tags.TagBase<{\n  kind: \"powerOf\";\n  target: \"number\";\n  value: Value;\n  validate: `(() => {\n        const denominator: number = Math.log(${Value});\n        const value: number = Math.log($input) / denominator;\n        return Math.abs(value - Math.round(value)) < 0.00000001;\n    })()`;\n}>;\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomNumber from \"typia/lib/internal/_randomNumber.js\";\nimport typia from \"typia\";\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\nconst data = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    dollar: (\n      _generator?.string ?? __typia_transform__randomString._randomString\n    )({\n      type: \"string\",\n    }),\n    postfix: (\n      _generator?.string ?? __typia_transform__randomString._randomString\n    )({\n      type: \"string\",\n    }),\n    powerOf: (\n      _generator?.number ?? __typia_transform__randomNumber._randomNumber\n    )({\n      type: \"number\",\n    }),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()({\n  customs: {\n    string: (tags) => {\n      if (tags.find((t) => t.kind === \"dollar\") !== undefined)\n        return \"$\" + RandomGenerator.integer();\n      const postfix = tags.find((t) => t.kind === \"postfix\");\n      if (postfix !== undefined)\n        return RandomGenerator.string() + postfix.value;\n    },\n  },\n});\nconsole.log(data);"}},"/docs/utilization/hono":{"title":"Guide Documents > Utilization Cases > Hono","data":{"":"Hono is a small, simple, and ultrafast web framework for the Edges.If you are using Hono with typia, you can use  @hono/typia-validator  to validate the request body.\nimport { Hono } from \"hono\";\nimport { typiaValidator } from '@hono/typia-validator'\nimport typia, { type tags } from \"typia\";\nimport { IBbsArticle } from \"../structures/IBbsArticle\";\n/** create a validate function */\nconst validate = typia.createValidate<IBbsArticle>();\nconst app = new Hono();\napp.post(\"/\",\n  typiaValidator('json', validate),\n  (c) => {\n    const data = c.req.valid(\"json\");\n    return c.json({\n      id: data.id,\n      title: data.title,\n      body: data.body,\n      created_at: data.created_at,\n    });\n  });\nexport default app;"}},"/docs/utilization/nestjs":{"title":"Guide Documents > Utilization Cases > NestJS","data":{"":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: superfast decorators using typia\n@nestia/sdk: evolved SDK and Swagger generators\n@nestia/migrate: Swagger to NestJS\nnestia: just CLI (command line interface) tool\nimport { Controller } from \"@nestjs/common\";\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\nimport type { IBbsArticle } from \"@bbs-api/structures/IBbsArticle\";\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  /**\n   * Store a new content.\n   *\n   * @param input Content to store\n   * @returns Newly archived article\n   */\n  @TypedRoute.Post() // 200x faster and safer JSON.stringify()\n  public async store(\n    @TypedBody() input: IBbsArticle.IStore, // 20,000x faster validator\n  ): Promise<IBbsArticle>;\n    // do not need DTO class definition,\n    // just fine with interface\n}\nLeft: NestJS server code\nRight: Client code using SDK"}},"/docs/validators/functional":{"title":"Guide Documents > Runtime Validators > Functional Module","data":{"assertfunction#assertFunction()":"export namespace functional {\n  export function assertFunction<T extends Function>(func: T): T;\n  export function assertParameters<T extends Function>(func: T): T;\n  export function assertReturn<T extends Function>(func: T): T;\n  export function assertEqualsFunction<T extends Function>(func: T): T;\n  export function assertEqualsParameters<T extends Function>(func: T): T;\n  export function assertEqualsReturn<T extends Function>(func: T): T;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nAsserts a function.typia.functional.assertFunction<T>() asserts a function, by wrapping the parameter function and checking its parameters and return value through typia.assert<T>() function. If some parameter or return value does not match the expected type, it throws a TypeGuardError error.For reference, TypeGuardError.path would be a little bit different with individual typia.assert<T>() function. If TypeGuardError occurs from some parameter, the path would start from $input.parameters[<index>]. Otherwise the path would start from $input.return.\n$input.parameters[0].~\n$input.return.~\nBy the way, if you don't want to assert both parameters and return value, but one of them, you can use typia.functional.assertParameters<T>() or typia.functional.assertReturn<T>() instead. Otherwise, if you want to prohibit superfluous properties, typia.functional.assertEqualsFunction<T>() would be helpful.Also, if what you want is not just finding the first type error through assertion, but also finding every type errors, utilize typia.functional.validateFunction<T>() function instead. Otherwise, you don't need the reason why, but just want to know whether the function is valid or not, use typia.functional.isFunction<T>() function.\nimport typia from \"typia\";\nconst func = typia.functional.assertFunction(\n  (x: number, y: number): number => x + y,\n);\nfunc(3, 4);\nfunc(4, 5);\nimport * as  from \"typia/lib/internal/_functionalTypeGuardErrorFactory.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nconst func = (() => {\n  const errorFactoryWrapper =\n    ._functionalTypeGuardErrorFactory;\n  const __assert_param_0 = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let _errorFactory;\n    return (\n      input,\n      errorFactory = (p) =>\n        errorFactoryWrapper({\n          ...p,\n          path: p.path\n            ? p.path.replace(\"$input\", \"$input.parameters[0]\")\n            : undefined,\n        }),\n    ) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.functional.assertFunction\",\n              path: _path + \"\",\n              expected: \"number\",\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  const __assert_param_1 = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let _errorFactory;\n    return (\n      input,\n      errorFactory = (p) =>\n        errorFactoryWrapper({\n          ...p,\n          path: p.path\n            ? p.path.replace(\"$input\", \"$input.parameters[1]\")\n            : undefined,\n        }),\n    ) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.functional.assertFunction\",\n              path: _path + \"\",\n              expected: \"number\",\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  const __assert_return = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let _errorFactory;\n    return (\n      input,\n      errorFactory = (p) =>\n        errorFactoryWrapper({\n          ...p,\n          path: p.path ? p.path.replace(\"$input\", \"$input.return\") : undefined,\n        }),\n    ) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.functional.assertFunction\",\n              path: _path + \"\",\n              expected: \"number\",\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  return (x, y) => {\n    __assert_param_0(x);\n    __assert_param_1(y);\n    return __assert_return(((x, y) => x + y)(x, y));\n  };\n})();\nfunc(3, 4);\nfunc(4, 5);","isfunction#isFunction()":"export namespace functional {\n  export function isFunction<T extends (...args: any[]) => any>(\n    func: T,\n  ): T extends (...args: infer Arguments) => infer Output\n    ? Output extends Promise<infer R>\n      ? (...args: Arguments) => Promise<R | null>\n      : (...args: Arguments) => Output | null\n    : never;\n  export function isParameters;\n  export function isReturn;\n  export function isEqualsFunction;\n  export function isEqualsParameters;\n  export function isEqualsReturn;\n}\nTests a function.typia.functional.isFunction<T>() tests a function, by wrapping the parameter function and checking its parameters and return value through typia.is<T>() function. If some parameter or return value does not match the expected type, it returns null. Otherwise, it returns the return value of the parameter function.By the way, if you don't want to test both parameters and return value, but one of them, you can use typia.functional.isParameters<T>() or typia.functional.isReturn<T>() instead. Otherwise, if you want to prohibit superfluous properties, typia.functional.equalsFunction<T>() would be helpful.Also, if what you want is not just type checking, but want to know the detailed reason(s) why, utilize typia.functional.assertFunction<T>() or typia.functional.validateFunction<T>() instead.\nimport typia from \"typia\";\nconst func = typia.functional.isFunction(\n  (x: number, y: number): number => x + y,\n);\nfunc(3, 4);\nfunc(4, 5);\nimport typia from \"typia\";\nimport typia from \"typia\";\nconst func = (() => {\n  const __is_param_0 = (() => {\n    return (input) => \"number\" === typeof input;\n  })();\n  const __is_param_1 = (() => {\n    return (input) => \"number\" === typeof input;\n  })();\n  const __is_return = (() => {\n    return (input) => \"number\" === typeof input;\n  })();\n  return (x, y) => {\n    if (false === __is_param_0(x)) return null;\n    if (false === __is_param_1(y)) return null;\n    const result = ((x, y) => x + y)(x, y);\n    return __is_return(result) ? result : null;\n  };\n})();\nfunc(3, 4);\nfunc(4, 5);\nValidates a function.typia.functional.validateFunction<T>() validates a function, by wrapping the parameter function and checking its parameters and return value through typia.validate<T>() function. If some parameter or return value does not match the expected type, it returns a IValidation.IFailure typed object. Otherwise, it returns a IValidation.ISuccess typed object instead.For reference, IValidation.IError.path would be a little bit different with individual typia.validate<T>() function. If IValidation.IError occurs from some parameter, the path would start from $input.parameters[<index>]. Otherwise the path would start from $input.return.\n$input.parameters[0].~\n$input.return.~\nBy the way, if you don't want to validate both parameters and return value, but one of them, you can use typia.functional.validateParameters<T>() or typia.functional.validateReturn<T>() instead. Otherwise, if you want to prohibit superfluous properties, typia.functional.validateEqualsFunction<T>() would be helpful.Also, if what you want is not retrieving every type errors, but just finding the first type error, utilize typia.functional.assertFunction<T>() function instead. Otherwise, you don't need the reason why, but just want to know whether the function is valid or not, use typia.functional.isFunction<T>() function.\nimport typia from \"typia\";\nconst func = typia.functional.validateFunction(\n  (x: number, y: number): number => x + y,\n);\nfunc(3, 4);\nfunc(4, 5);\nimport * as __typia_transform__validateReport from \"typia/lib/internal/_validateReport.js\";\nimport typia from \"typia\";\nconst func = (() => {\n  const __validate_param_0 = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let errors;\n    let $report;\n    return (input) => {\n      if (false === __is(input)) {\n        errors = [];\n        $report = __typia_transform__validateReport._validateReport(errors);\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"number\",\n            value: input,\n          }))(input, \"$input\", true);\n        const success = 0 === errors.length;\n        return {\n          success,\n          errors,\n          data: success ? input : undefined,\n        };\n      }\n      return {\n        success: true,\n        errors: [],\n        data: input,\n      };\n    };\n  })();\n  const __validate_param_1 = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let errors;\n    let $report;\n    return (input) => {\n      if (false === __is(input)) {\n        errors = [];\n        $report = __typia_transform__validateReport._validateReport(errors);\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"number\",\n            value: input,\n          }))(input, \"$input\", true);\n        const success = 0 === errors.length;\n        return {\n          success,\n          errors,\n          data: success ? input : undefined,\n        };\n      }\n      return {\n        success: true,\n        errors: [],\n        data: input,\n      };\n    };\n  })();\n  const __validate_return = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let errors;\n    let $report;\n    return (input) => {\n      if (false === __is(input)) {\n        errors = [];\n        $report = __typia_transform__validateReport._validateReport(errors);\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"number\",\n            value: input,\n          }))(input, \"$input\", true);\n        const success = 0 === errors.length;\n        return {\n          success,\n          errors,\n          data: success ? input : undefined,\n        };\n      }\n      return {\n        success: true,\n        errors: [],\n        data: input,\n      };\n    };\n  })();\n  return (x, y) => {\n    const paramErrorResults = [__validate_param_0(x), __validate_param_1(y)]\n      .map((r, i) =>\n        true === r.success\n          ? r\n          : {\n              ...r,\n              errors: r.errors.map((error) => ({\n                ...error,\n                path: error.path.replace(\"$input\", `$input.parameters[${i}]`),\n              })),\n            },\n      )\n      .filter((r) => false === r.success);\n    if (0 !== paramErrorResults.length)\n      return {\n        success: false,\n        errors: paramErrorResults.map((r) => r.errors).flat(),\n      };\n    const result = __validate_return(((x, y) => x + y)(x, y));\n    if (false === result.success)\n      result.errors = result.errors.map((error) => ({\n        ...error,\n        path: error.path.replace(\"$input\", \"$input.return\"),\n      }));\n    return result;\n  };\n})();\nfunc(3, 4);\nfunc(4, 5);"}},"/playground":{"title":"Playground","data":{}},"/docs":{"title":"Guide Documents > Introduction","data":{"outline#Outline":"// RUNTIME VALIDATORS\nexport function is<T>(input: unknown): input is T; // returns boolean\nexport function assert<T>(input: unknown): T; // throws TypeGuardError\nexport function assertGuard<T>(input: unknown): asserts input is T;\nexport function validate<T>(input: unknown): IValidation<T>; // detailed\n// JSON FUNCTIONS\nexport namespace json {\n  export function application<T>(): IJsonApplication; // JSON schema\n  export function assertParse<T>(input: string): T; // type safe parser\n  export function assertStringify<T>(input: T): string; // safe and faster\n}\n// LLM FUNCTION CALLING SCHEMA\nexport namespace llm {\n  // collection of function calling schemas\n  export function application<Class, Model>(): ILlmApplication<Class>;\n  export function controller<Class, Model>(\n    name: string,\n    execute: Class,\n  ): ILlmController<Model>; // +executor\n  // structured output\n  export function parameters<P, Model>(): ILlmSchema.IParameters<Model>; \n  export function schema<T, Model>(): ILlmSchema<Model>; // type schema\n}\n// PROTOCOL BUFFER\nexport namespace protobuf {\n  export function message<T>(): string; // Protocol Buffer message\n  export function assertDecode<T>(buffer: Uint8Array): T; // safe decoder\n  export function assertEncode<T>(input: T): Uint8Array; // safe encoder\n}\n// RANDOM GENERATOR\nexport function random<T>(g?: Partial<IRandomGenerator>): T;\ntypia is a transformer library supporting below features:\nSuper-fast Runtime Validators\nEnhanced JSON functions\nLLM function calling schema and structured output\nProtocol Buffer encoder and decoder\nRandom data generator\nOnly one line required, with pure TypeScript type\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer","transformation#Transformation":"If you call typia function, it would be compiled like below.This is the key concept of typia, transforming TypeScript type to a runtime function. The typia.is<T>() function is transformed to a dedicated type checker by analyzing the target type T in the compilation level.This feature enables developers to ensure type safety in their applications, leveraging TypeScript's static typing while also providing runtime validation. Instead of defining additional schemas, you can simply utilize the pure TypeScript type itself.\n//----\n// examples/checkString.ts\n//----\nimport typia, { tags } from \"typia\";\nexport const checkString = typia.createIs<string>();\n//----\n// examples/checkUUID.js\n//----\nimport typia from \"typia\";\nexport const checkString = (() => {\n  return (input) => \"string\" === typeof input;\n})();","sponsors#Sponsors":"Thanks for your support.Your donation encourages typia development.Also, typia is re-distributing half of donations to core contributors of typia.\nnonara/ts-patch\nryoppippi/unplugin-typia"}},"/docs/json/parse":{"title":"Guide Documents > JSON < parse() functions","data":{"parse-functions#parse() functions":"export namespace json {\n  export function isParse<T>(input: string): Primitive<T> | null;\n  export function assertParse<T>(input: string): Primitive<T>;\n  export function validateParse<T>(input: string): IValidation<Primitive<T>>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Primitive type of JSON.\n *\n * `Primitive<T>` is a TMP (Type Meta Programming) type which converts\n * its argument as a primitive type within framework JSON.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be an empty object (`{}`).\n *\n * Otherwise, the target argument is a type of custom class, all of its custom method\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the primitive object.\n *\n * In addition, if the target argument is a type of custom class and it has a special\n * method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\n * but `Primitive<ReturnType<Instance.toJSON>>`.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `String`                | `string`\n * `Class`                 | `object`\n * `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\n * Native Class            | never\n * Others                  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n * @author Michael - https://github.com/8471919\n */\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true\n  ? T\n  : PrimitiveMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype PrimitiveMain<Instance> = Instance extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<Instance> extends bigint\n  ? never\n  : ValueOf<Instance> extends boolean | number | string\n  ? ValueOf<Instance>\n  : Instance extends Function\n  ? never\n  : ValueOf<Instance> extends object\n  ? Instance extends object\n    ? Instance extends NativeClass\n      ? never\n      : Instance extends IJsonable<infer Raw>\n      ? ValueOf<Raw> extends object\n        ? Raw extends object\n          ? PrimitiveObject<Raw> // object would be primitified\n          : never // cannot be\n        : ValueOf<Raw> // atomic value\n      : PrimitiveObject<Instance> // object would be primitified\n    : never // cannot be\n  : ValueOf<Instance>;\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T>\n  ? IsTuple<Instance> extends true\n    ? PrimitiveTuple<Instance>\n    : PrimitiveMain<T>[]\n  : {\n      [P in keyof Instance]: PrimitiveMain<Instance[P]>;\n    };\ntype PrimitiveTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [PrimitiveMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [PrimitiveMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>]\n  : [];\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype NativeClass =\n  | Set<any>\n  | Map<any, any>\n  | WeakSet<any>\n  | WeakMap<any, any>\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array\n  | ArrayBuffer\n  | SharedArrayBuffer\n  | DataView;\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer U>\n    ? Instance extends U\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\ninterface IJsonable<T> {\n  toJSON(): T;\n}\nType safe JSON parser.Unlike native JSON.parse() function which returns any typed instance without type checking, typia.json.assertParse<T>() function validates instance type after the parsing. If the parsed value is not following the promised type T, it throws TypeGuardError with the first type error info.If you want to know every type error infos detaily, you can use typia.json.validateParse<T>() function instead. Otherwise, you just only want to know whether the parsed value is following the type T or not, just call typia.json.isParse<T>() function.\ntypia.json.isParse<T>(): JSON.parse() + typia.is<T>()\ntypia.json.assertParse<T>(): JSON.parse() + typia.assert<T>()\ntypia.json.validateParse<T>(): JSON.parse() + typia.validate<T>()\nLook at the below code, then you may understand how the typia.json.assertParse<T>() function works.\nimport typia, { tags } from \"typia\";\nconst json: string = JSON.stringify(typia.random<IMember>());\nconst parsed: IMember = typia.json.assertParse<IMember>(json);\nconsole.log(json === JSON.stringify(parsed)); // true\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomFormatEmail from \"typia/lib/internal/_randomFormatEmail.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nconst json = JSON.stringify(\n  (() => {\n    const _ro0 = (_recursive = false, _depth = 0) => ({\n      id: (\n        _generator?.uuid ??\n        __typia_transform__randomFormatUuid._randomFormatUuid\n      )(),\n      email: (\n        _generator?.email ??\n        __typia_transform__randomFormatEmail._randomFormatEmail\n      )(),\n      age: (\n        _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n      )({\n        type: \"integer\",\n        exclusiveMinimum: true,\n        minimum: 19,\n        maximum: 100,\n      }),\n    });\n    let _generator;\n    return (generator) => {\n      _generator = generator;\n      return _ro0();\n    };\n  })()(),\n);\nconst parsed = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.assertParse\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.assertParse\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.email &&\n      (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.assertParse\",\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.assertParse\",\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.assertParse\",\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.assertParse\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.assertParse\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.assertParse\",\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        },\n        _errorFactory,\n      ));\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  const __assert = (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.json.assertParse\",\n              path: _path + \"\",\n              expected: \"IMember\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.json.assertParse\",\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n  return (input, errorFactory) => __assert(JSON.parse(input), errorFactory);\n})()(json);\nconsole.log(json === JSON.stringify(parsed)); // true\n/**\n * Primitive type of JSON.\n *\n * `Primitive<T>` is a TMP (Type Meta Programming) type which converts\n * its argument as a primitive type within framework JSON.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be an empty object (`{}`).\n *\n * Otherwise, the target argument is a type of custom class, all of its custom method\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the primitive object.\n *\n * In addition, if the target argument is a type of custom class and it has a special\n * method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\n * but `Primitive<ReturnType<Instance.toJSON>>`.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `String`                | `string`\n * `Class`                 | `object`\n * `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\n * Native Class            | never\n * Others                  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n * @author Michael - https://github.com/8471919\n */\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true\n  ? T\n  : PrimitiveMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype PrimitiveMain<Instance> = Instance extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<Instance> extends bigint\n  ? never\n  : ValueOf<Instance> extends boolean | number | string\n  ? ValueOf<Instance>\n  : Instance extends Function\n  ? never\n  : ValueOf<Instance> extends object\n  ? Instance extends object\n    ? Instance extends NativeClass\n      ? never\n      : Instance extends IJsonable<infer Raw>\n      ? ValueOf<Raw> extends object\n        ? Raw extends object\n          ? PrimitiveObject<Raw> // object would be primitified\n          : never // cannot be\n        : ValueOf<Raw> // atomic value\n      : PrimitiveObject<Instance> // object would be primitified\n    : never // cannot be\n  : ValueOf<Instance>;\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T>\n  ? IsTuple<Instance> extends true\n    ? PrimitiveTuple<Instance>\n    : PrimitiveMain<T>[]\n  : {\n      [P in keyof Instance]: PrimitiveMain<Instance[P]>;\n    };\ntype PrimitiveTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [PrimitiveMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [PrimitiveMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>]\n  : [];\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype NativeClass =\n  | Set<any>\n  | Map<any, any>\n  | WeakSet<any>\n  | WeakMap<any, any>\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array\n  | ArrayBuffer\n  | SharedArrayBuffer\n  | DataView;\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer U>\n    ? Instance extends U\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\ninterface IJsonable<T> {\n  toJSON(): T;\n}","reusable-functions#Reusable functions":"export namespace json {\n  export function createIsParse<T>(): (input: string) => Primitive<T> | null;\n  export function createAssertParse<T>(): (input: string) => Primitive<T>;\n  export function createValidateParse<T>(): (\n    input: string,\n  ) => IValidation<Primitive<T>>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\nReusable typia.json.isParse<T>() function generators.If you repeat to call typia.json.isParse<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIsParse<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\nexport const parseMember = typia.json.createIsParse<IMember>();\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport typia from \"typia\";\nexport const parseMember = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  return (input) => {\n    input = JSON.parse(input);\n    return __is(input) ? input : null;\n  };\n})();"}},"/docs/json/schema":{"title":"Guide Documents > JSON > Schema","data":{"schemas-function#schemas() function":"export namespace json {\n  export function schemas<\n    Schemas extends unknown[],\n    Version extends \"3.0\" | \"3.1\" = \"3.1\",\n  >(): IJsonSchemaCollection<Version>;\n}\nimport type { OpenApi, OpenApiV3 } from \"@samchon/openapi\";\nexport type IJsonSchemaCollection<Version extends \"3.0\" | \"3.1\" = \"3.1\"> =\n  Version extends \"3.0\" ? IJsonSchemaCollection.IV3_0 : IJsonSchemaCollection.IV3_1;\nexport namespace IJsonSchemaCollection {\n  export interface IV3_0 {\n    version: \"3.0\";\n    schemas: OpenApiV3.IJsonSchema[];\n    components: OpenApiV3.IComponents;\n  }\n  export interface IV3_1 {\n    version: \"3.1\";\n    components: OpenApi.IComponents;\n    schemas: OpenApi.IJsonSchema[];\n  }\n}\nJSON schema generator.\nDefinitions:\nIJsonSchemaCollection\nOpenAPI v3.0\nOpenAPI v3.1\nWhen you need JSON schema, do not write it by yourself, but just call typia.json.schemas() function.If you call the typia.json.schemas() with specialization of target Schemas, typia will analyze your Schemas and generate JSON schema definition in the compilation level. However, note that, JSON schema definitions of \"OpenAPI v3.0\" and \"OpenAPI v3.1\" are a little bit different. Therefore, you have to consider which value to assign in the Version argument.\nSwagger can't express tuple type\nSwagger can't express pattern property\nimport typia, { tags } from \"typia\";\nexport const MemberSchema = typia.json.schemas<[IMember], \"3.0\">();\ninterface IMember {\n  /**\n   * Unique user ID generated by server.\n   */\n  id: string & tags.Format<\"uuid\">;\n  /**\n   * Email address of the member.\n   */\n  email: string & tags.Format<\"email\">;\n  /**\n   * Age of the member.\n   *\n   * For reference, only adult can be a member.\n   */\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport typia from \"typia\";\nexport const MemberSchema = {\n  version: \"3.0\",\n  components: {\n    schemas: {\n      IMember: {\n        type: \"object\",\n        properties: {\n          id: {\n            type: \"string\",\n            format: \"uuid\",\n            title: \"Unique user ID generated by server\",\n            description: \"Unique user ID generated by server.\",\n          },\n          email: {\n            type: \"string\",\n            format: \"email\",\n            title: \"Email address of the member\",\n            description: \"Email address of the member.\",\n          },\n          age: {\n            type: \"integer\",\n            exclusiveMinimum: true,\n            minimum: 19,\n            maximum: 100,\n            title: \"Age of the member\",\n            description:\n              \"Age of the member.\\n\\nFor reference, only adult can be a member.\",\n          },\n        },\n        required: [\"id\", \"email\", \"age\"],\n      },\n    },\n  },\n  schemas: [\n    {\n      $ref: \"#/components/schemas/IMember\",\n    },\n  ],\n};","specialization#Specialization":"You can utilize type tags (or validator's comment tags) to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. Also, there're special comment tags only for JSON schema definition that are different with validator's comment tags like below.\n@deprecated\n@hidden\n@internal\n@title {string}\nLet's see how those type tags, comment tags and description comments are working with example code.\nimport typia, { tags } from \"typia\";\nexport const SpecialTagSchema = typia.json.schemas<[Special], \"3.1\">();\ninterface Special {\n  /**\n   * Deprecated tags are just used for marking.\n   *\n   * @title Unsigned integer\n   * @deprecated\n   */\n  type: number & tags.Type<\"int32\">;\n  /**\n   * Internal tagged property never be shown in JSON schema.\n   *\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\n   *\n   * @internal\n   */\n  internal: number[];\n  /**\n   * Hidden tagged property never be shown in JSON schema.\n   *\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\n   *\n   * @hidden\n   */\n  hidden: boolean;\n  /**\n   * You can limit the range of number.\n   *\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n  /**\n   * You can limit the length of string.\n   *\n   * Also, multiple range conditions are also possible.\n   */\n  string: string &\n    (\n      | (tags.MinLength<3> & tags.MaxLength<24>)\n      | (tags.MinLength<40> & tags.MaxLength<100>)\n    );\n  /**\n   * You can limit the pattern of string.\n   *\n   * @pattern ^[a-z]+$\n   */\n  pattern: string;\n  /**\n   * You can limit the format of string.\n   *\n   * @format date-time\n   */\n  format: string | null;\n  /**\n   * In the Array case, possible to restrict its elements.\n   */\n  array: Array<string & tags.Format<\"uuid\">> & tags.MinItems<3>;\n}\nimport typia from \"typia\";\nexport const SpecialTagSchema = {\n  version: \"3.1\",\n  components: {\n    schemas: {\n      Special: {\n        type: \"object\",\n        properties: {\n          type: {\n            type: \"integer\",\n            deprecated: true,\n            title: \"Unsigned integer\",\n            description: \"Deprecated tags are just used for marking.\",\n          },\n          number: {\n            type: \"number\",\n            exclusiveMinimum: true,\n            minimum: 19,\n            maximum: 100,\n            title: \"You can limit the range of number\",\n            description: \"You can limit the range of number.\",\n          },\n          string: {\n            oneOf: [\n              {\n                type: \"string\",\n                minLength: 3,\n                maxLength: 24,\n              },\n              {\n                type: \"string\",\n                minLength: 40,\n                maxLength: 100,\n              },\n            ],\n            title: \"You can limit the length of string\",\n            description:\n              \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\",\n          },\n          pattern: {\n            type: \"string\",\n            pattern: \"^[a-z]+$\",\n            title: \"You can limit the pattern of string\",\n            description: \"You can limit the pattern of string.\",\n          },\n          format: {\n            oneOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                format: \"date-time\",\n              },\n            ],\n            title: \"You can limit the format of string\",\n            description: \"You can limit the format of string.\",\n          },\n          array: {\n            type: \"array\",\n            items: {\n              type: \"string\",\n              format: \"uuid\",\n            },\n            minItems: 3,\n            title: \"In the Array case, possible to restrict its elements\",\n            description:\n              \"In the Array case, possible to restrict its elements.\",\n          },\n        },\n        required: [\"type\", \"string\", \"pattern\", \"format\", \"array\"],\n      },\n    },\n  },\n  schemas: [\n    {\n      $ref: \"#/components/schemas/Special\",\n    },\n  ],\n};","customization#Customization":"If what you want is not just filling regular properties of JSON schema specification, but to adding custom properties into the JSON schema definition, you can do it through the tags.TagBase.schema property type or tags.JsonSchemaPlugin type.For reference, the custom property must be started with x- prefix. It's a rule of JSON schema.\nimport typia, { tags } from \"typia\";\n \ntype Monetary<Value extends string> = tags.TagBase<{\n  target: \"number\";\n  kind: \"monetary\";\n  value: Value;\n  schema: {\n    \"x-monetary\": Value;\n  };\n}>;\ntype Placeholder<Value extends string> = tags.JsonSchemaPlugin<{\n  \"x-placeholder\": Value;\n}>;\ninterface IAccount {\n  code: string & Placeholder<\"Write you account code please\">;\n  balance: number & Monetary<\"dollar\">;\n};\n \ntypia.json.schemas<[IAccount]>();\nimport typia from \"typia\";\n({\n  version: \"3.1\",\n  components: {\n    schemas: {\n      IAccount: {\n        type: \"object\",\n        properties: {\n          code: {\n            type: \"string\",\n            \"x-placeholder\": \"Write you account code please\",\n          },\n          balance: {\n            type: \"number\",\n            \"x-monetary\": \"dollar\",\n          },\n        },\n        required: [\"code\", \"balance\"],\n      },\n    },\n  },\n  schemas: [\n    {\n      $ref: \"#/components/schemas/IAccount\",\n    },\n  ],\n});","restrictions#Restrictions":"JSON schema does not support bigint type.So if you use bigint type in one of your onetarget schemas, typia will make compile error like below.\nimport typia, { tags } from \"typia\";\ninterface Something {\n  bigint: bigint;\n  array: bigint[];\n  nested: Nested;\n}\ninterface Nested {\n  uint64: bigint & tags.Type<\"uint64\">;\n}\ntypia.json.schemas<[Something]>();\nmain.ts:12:1 - error TS(typia.json.schemas): unsupported type detected\n- Something.bigint: bigint\n  - JSON does not support bigint type.\n- Something.array: bigint\n  - JSON does not support bigint type.\n- Nested.uint64: (bigint & Type<\"uint64\">)\n  - JSON does not support bigint type.\nAlso, if you put any type of native classes like Map or Uint8Array, it would also be error, either. By the way, only Date class is exceptional, and it would be considered as string & Format<\"date-time\"> type like below.\nimport typia from \"typia\";\ninterface Native {\n  date: Date;\n}\ntypia.json.schemas<[Native]>();\nimport typia from \"typia\";\n({\n  version: \"3.1\",\n  components: {\n    schemas: {\n      Native: {\n        type: \"object\",\n        properties: {\n          date: {\n            type: \"string\",\n            format: \"date-time\",\n          },\n        },\n        required: [\"date\"],\n      },\n    },\n  },\n  schemas: [\n    {\n      $ref: \"#/components/schemas/Native\",\n    },\n  ],\n});"}},"/docs/json/stringify":{"title":"Guide Documents > JSON > stringify() function","data":{"stringify-functions#stringify() functions":"export namespace json {\n  export function stringify<T>(input: T): string;\n  export function isStringify<T>(input: T | unknown): string | null;\n  export function assertStringify<T>(input: T | unknown): string;\n  export function validateStringify<T>(input: T | unknown): IValidation<string>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\nYou can boost up JSON serialization speed just by calling typia.json.stringify<T>() function. Also, you even can ensure type safety of JSON serialization by calling other functions like typia.json.isStringify() and typia.json.assertStringify() functions.As typia.json.stringify<T>() function writes dedicated JSON serialization code only for the target type T, its performance is much faster than native JSON.stringify() function. However, because of the dedicated optimal JSON serialization code, when wrong typed data comes, unexpected error be occurred.Instead, typia supports type safe JSON serialization functions like typia.json.isStringify(). The typia.json.isStringify() is a combination function of typia.is<T>() and typia.json.stringify<T>() function. It checks whether the input value is valid for the target type T or not first, and operate JSON serialization later. If the input value is not matched with the type T, it returns null value.\ntypia.json.isStringify(): typia.is<T>() + typia.json.stringify<T>()\ntypia.json.assertStringify(): typia.assert<T>() + typia.json.stringify<T>()\ntypia.json.validateStringify(): typia.validate<T>() + typia.json.stringify<T>()\nAOT compilation\ntypia.json.isStringify() and other similar functions are still much faster than native JSON.stringify() function, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\nimport typia, { tags } from \"typia\";\nconst department: IDepartment = typia.random<IDepartment>();\nconst json: string | null = typia.json.isStringify(department);\nconsole.log(json); // not null, but string\ninterface IDepartment {\n  id: string & tags.Format<\"uuid\">;\n  name: string & tags.MinLength<3>;\n  limit: number & tags.Type<\"int32\">;\n  clerks: IClerk[];\n}\ninterface IClerk {\n  name: string;\n  age: number \n    & tags.Type<\"uint32\"> \n    & tags.ExclusiveMinimum<19> \n    & tags.Maximum<100>;\n  authority: number;\n  joined_at: string & tags.Format<\"date\">;\n}\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__randomArray from \"typia/lib/internal/_randomArray.js\";\nimport * as __typia_transform__randomNumber from \"typia/lib/internal/_randomNumber.js\";\nimport * as __typia_transform__randomFormatDate from \"typia/lib/internal/_randomFormatDate.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isTypeInt32 from \"typia/lib/internal/_isTypeInt32.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__isFormatDate from \"typia/lib/internal/_isFormatDate.js\";\nimport * as __typia_transform__jsonStringifyString from \"typia/lib/internal/_jsonStringifyString.js\";\nimport * as __typia_transform__jsonStringifyNumber from \"typia/lib/internal/_jsonStringifyNumber.js\";\nimport typia from \"typia\";\nconst department = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n        minLength: 3,\n      },\n    ),\n    limit: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n    }),\n    clerks: (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n      type: \"array\",\n      element: () => _ro1(_recursive, _recursive ? 1 + _depth : _depth),\n    }),\n  });\n  const _ro1 = (_recursive = false, _depth = 0) => ({\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n      },\n    ),\n    age: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n    }),\n    authority: (\n      _generator?.number ?? __typia_transform__randomNumber._randomNumber\n    )({\n      type: \"number\",\n    }),\n    joined_at: (\n      _generator?.date ?? __typia_transform__randomFormatDate._randomFormatDate\n    )(),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconst json = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.name &&\n    3 <= input.name.length &&\n    \"number\" === typeof input.limit &&\n    __typia_transform__isTypeInt32._isTypeInt32(input.limit) &&\n    Array.isArray(input.clerks) &&\n    input.clerks.every(\n      (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n    );\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100 &&\n    \"number\" === typeof input.authority &&\n    !Number.isNaN(input.authority) &&\n    \"string\" === typeof input.joined_at &&\n    __typia_transform__isFormatDate._isFormatDate(input.joined_at);\n  const _so0 = (input) =>\n    `{\"id\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.id)},\"name\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.name)},\"limit\":${__typia_transform__jsonStringifyNumber._jsonStringifyNumber(input.limit)},\"clerks\":${`[${input.clerks.map((elem) => _so1(elem)).join(\",\")}]`}}`;\n  const _so1 = (input) =>\n    `{\"name\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.name)},\"age\":${__typia_transform__jsonStringifyNumber._jsonStringifyNumber(input.age)},\"authority\":${__typia_transform__jsonStringifyNumber._jsonStringifyNumber(input.authority)},\"joined_at\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.joined_at)}}`;\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  const __stringify = (input) => _so0(input);\n  return (input) => (__is(input) ? __stringify(input) : null);\n})()(department);\nconsole.log(json); // not null, but string","reusable-functions#Reusable functions":"export namespace json {\n  export function createStringify<T>(): (input: T) => string;\n  export function createIsStringify<T>(): (input: unknown) => string | null;\n  export function createAssertStringify<T>(\n   errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n  ): (input: unknown) => string; \n  export function createValidateStringify<T>(): (input: unknown) => IValidation<string>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\nReusable typia.json.stringify<T>() function generators.If you repeat to call typia.json.stringify<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.json.createStringify<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\nexport const assertDepartment = typia.json.createAssertStringify<IDepartment>();\ninterface IDepartment {\n  id: string & tags.Format<\"uuid\">;\n  name: string & tags.MinLength<3>;\n  limit: number & tags.Type<\"int32\">;\n  clerks: IClerk[];\n}\ninterface IClerk {\n  name: string;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n  authority: number;\n  joined_at: string & tags.Format<\"date\">;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isTypeInt32 from \"typia/lib/internal/_isTypeInt32.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__isFormatDate from \"typia/lib/internal/_isFormatDate.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport * as __typia_transform__jsonStringifyString from \"typia/lib/internal/_jsonStringifyString.js\";\nimport typia from \"typia\";\nexport const assertDepartment = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.name &&\n    3 <= input.name.length &&\n    \"number\" === typeof input.limit &&\n    __typia_transform__isTypeInt32._isTypeInt32(input.limit) &&\n    Array.isArray(input.clerks) &&\n    input.clerks.every(\n      (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n    );\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100 &&\n    \"number\" === typeof input.authority &&\n    !Number.isNaN(input.authority) &&\n    \"string\" === typeof input.joined_at &&\n    __typia_transform__isFormatDate._isFormatDate(input.joined_at);\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.name &&\n      (3 <= input.name.length ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".name\",\n            expected: \"string & MinLength<3>\",\n            value: input.name,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".name\",\n          expected: \"(string & MinLength<3>)\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.limit &&\n      (__typia_transform__isTypeInt32._isTypeInt32(input.limit) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".limit\",\n            expected: 'number & Type<\"int32\">',\n            value: input.limit,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".limit\",\n          expected: '(number & Type<\"int32\">)',\n          value: input.limit,\n        },\n        _errorFactory,\n      )) &&\n    (((Array.isArray(input.clerks) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      )) &&\n      input.clerks.every(\n        (elem, _index2) =>\n          (((\"object\" === typeof elem && null !== elem) ||\n            __typia_transform__assertGuard._assertGuard(\n              _exceptionable,\n              {\n                method: \"typia.json.createAssertStringify\",\n                path: _path + \".clerks[\" + _index2 + \"]\",\n                expected: \"IClerk\",\n                value: elem,\n              },\n              _errorFactory,\n            )) &&\n            _ao1(\n              elem,\n              _path + \".clerks[\" + _index2 + \"]\",\n              true && _exceptionable,\n            )) ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.json.createAssertStringify\",\n              path: _path + \".clerks[\" + _index2 + \"]\",\n              expected: \"IClerk\",\n              value: elem,\n            },\n            _errorFactory,\n          ),\n      )) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      ));\n  const _ao1 = (input, _path, _exceptionable = true) =>\n    (\"string\" === typeof input.name ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".name\",\n          expected: \"string\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.authority && !Number.isNaN(input.authority)) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".authority\",\n          expected: \"number\",\n          value: input.authority,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.joined_at &&\n      (__typia_transform__isFormatDate._isFormatDate(input.joined_at) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".joined_at\",\n            expected: 'string & Format<\"date\">',\n            value: input.joined_at,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".joined_at\",\n          expected: '(string & Format<\"date\">)',\n          value: input.joined_at,\n        },\n        _errorFactory,\n      ));\n  const _so0 = (input) =>\n    `{\"id\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.id)},\"name\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.name)},\"limit\":${input.limit},\"clerks\":${`[${input.clerks.map((elem) => _so1(elem)).join(\",\")}]`}}`;\n  const _so1 = (input) =>\n    `{\"name\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.name)},\"age\":${input.age},\"authority\":${input.authority},\"joined_at\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.joined_at)}}`;\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  const __assert = (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.json.createAssertStringify\",\n              path: _path + \"\",\n              expected: \"IDepartment\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \"\",\n            expected: \"IDepartment\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n  const __stringify = (input) => _so0(input);\n  return (input, errorFactory) => {\n    __assert(input, errorFactory);\n    return __stringify(input);\n  };\n})();","performance#Performance":"Comparing JSON serialization speed with others, it is maximum 200x faster than class-transformer.For reference, class-transformer is the most famous library used in NestJS with class-validator. Also, fast-json-stringify is another famous one used in fastify. However, whether they are fast or slow, both of them require extra schema definition, that is different with TypeScript type. If you see the code below without experience of them, you may get shocked: how complicate and inefficient they are:\nfast-json-stringify requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13","server-performance#Server Performance":"Someone may ask:\nJSON serialization speed affects on the server performance?I think that the JSON serialization is just a tiny thing in the server side, isn't it?\nMy answer is, \"Yes, it affects on the server performance\".Most operations in NodeJS server are asynchronously executed in background thread, what are called \"event based non-blocking I/O model\". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13"}},"/docs/llm/chat":{"title":"Guide Documents > Large Language Model > AI Chatbot Development","data":{"agentica#Agentica":"https://github.com/wrtnlabs/agenticaThe simplest Agentic AI framework, specialized in LLM Function Calling.With @agentica, you can build Agentic AI chatbot only with TypeScript class types. Complex agent workflows and graphs required in conventional AI agent develoopment are not necessary in @agentica. Only with TypeScript class types, @agentica will do everything with the function calling.Look at below demonstration, and and feel how @agentica is powerful. Now, you can let users to read and write articles only with conversation texts. The TypeScript class functions would be adequately called in the AI chatbot with LLM function calling.\n@nestia/agent had been migrated to @agentica/* for enhancements and separation to multiple packages extending the functionalities.\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport { BbsArticleService } from \"./BbsArticleService\";\nconst agent = new Agentica({\n  controllers: [\n    typia.llm.application<BbsArticleService>(),\n  ]\n});\nawait agent.conversate(\"Hello, I want to create an article.\");\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport { BbsArticleService } from \"./BbsArticleService\";\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  service: {\n    api: new OpenAI({ apiKey: \"*****\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      protocol: \"class\",\n      name: \"bbs\",\n      application: typia.llm.application<BbsArticleService>(),\n      execute: new BbsArticleService(),\n    },\n  ],\n});\nawait agent.conversate(\"Hello, I want to create an article.\");\nBBS A.I. Chatbot Application: https://nestia.io/chat/bbs","swagger-chatbot#Swagger Chatbot":"You also can make the super A.I. chatbot by Swagger document too.With @agentica, you can build Agentic AI chatbot only with Swagger document built by @nestia/sdk. Complex agent workflows and graphs required in conventional AI agent development are not necessary in @agentica. Only with the Swagger document, @agentica will do everything with the function calling.Look at below demonstration, and feel how @agentica is powerful. Now, you can let users to search and purchase products only with conversation texts. The backend API functions would be adequately called in the AI chatbot with LLM function calling.\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nconst agent = new Agentica({\n  controllers: [\n    await fetch(\n      \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n    ).then(r => r.json()),\n    typia.llm.application<ShoppingCounselor>(),\n    typia.llm.application<ShoppingPolicy>(),\n    typia.llm.application<ShoppingSearchRag>(),\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\nimport { Agentica } from \"@agentica/core\";\nimport { OpenApi, HttpLlm } from \"@samchon/openapi\";\nimport typia from \"typia\";\nconst main = async (): Promise<void> => {\n  const agent = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"*****\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"http\",\n        name: \"shopping\",\n        application: HttpLlm.application({\n          model: \"chatgpt\",\n          document: OpenApi.convert(\n            await fetch(\n              \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n            ).then(r => r.json()),\n          ),\n        }),\n        connection: {\n          host: \"https://shopping-be.wrtn.ai\",\n          headers: {\n            Authorization: \"Bearer *****\",\n          },\n        },\n      },\n      {\n        protocol: \"class\",\n        name: \"counselor\",\n        application: \n          typia.llm.application<ShoppingCounselor, \"chatgpt\">(),\n        execute: new ShoppingCounselor(),\n      },\n      {\n        protocol: \"class\",\n        name: \"policy\",\n        application: \n          typia.llm.application<ShoppingPolicy, \"chatgpt\">(),\n        execute: new ShoppingPolicy(),\n      },\n      {\n        protocol: \"class\",\n        name: \"rag\",\n        application: \n          typia.llm.application<ShoppingSearchRag, \"chatgpt\">(),\n        execute: new ShoppingSearchRag(),\n      },\n    ],\n  });\n  await agent.conversate(\"I wanna buy MacBook Pro\");\n};\nmain().catch(console.error);\nShopping A.I. Chatbot Application: https://nestia.io/chat/shopping\nShopping Backend Repository: https://github.com/samchon/shopping-backend\nShopping Swagger Document (@nestia/editor): https://nestia.io/editor/?url=...","principles#Principles":"","agent-strategy#Agent Strategy":"When user says, @agentica/core delivers the conversation text to the selector agent, and let the selector agent to find (or cancel) candidate functions from the context. If the selector agent could not find any candidate function to call and there is not any candidate function previously selected either, the selector agent will work just like a plain ChatGPT.And @agentica/core enters to a loop statement until the candidate functions to be empty. In the loop statement, caller agent tries to LLM function calling by analyzing the user's conversation text. If context is enough to compose arguments of candidate functions, the caller agent actually calls the target functions, and let decriber agent to explain the function calling results. Otherwise the context is not enough to compose arguments, caller agent requests more information to user.Such LLM (Large Language Model) function calling strategy separating selector, caller, and describer is the key logic of @agentica/core.","validation-feedback#Validation Feedback":"import { FunctionCall } from \"pseudo\";\nimport { ILlmFunction, IValidation } from \"typia\";\nexport const correctFunctionCall = (p: {\n  call: FunctionCall;\n  functions: Array<ILlmFunction<\"chatgpt\">>;\n  retry: (reason: string, errors?: IValidation.IError[]) => Promise<unknown>;\n}): Promise<unknown> => {\n  // FIND FUNCTION\n  const func: ILlmFunction<\"chatgpt\"> | undefined =\n    p.functions.find((f) => f.name === p.call.name);\n  if (func === undefined) {\n    // never happened in my experience\n    return p.retry(\n      \"Unable to find the matched function name. Try it again.\",\n    );\n  }\n  // VALIDATE\n  const result: IValidation<unknown> = func.validate(p.call.arguments);\n  if (result.success === false) {\n    // 1st trial: 50% (gpt-4o-mini in shopping mall chatbot)\n    // 2nd trial with validation feedback: 99%\n    // 3nd trial with validation feedback again: never have failed\n    return p.retry(\n      \"Type errors are detected. Correct it through validation errors\",\n      {\n        errors: result.errors,\n      },\n    );\n  }\n  return result.data;\n}\nIs LLM function calling perfect?The answer is not, and LLM (Large Language Model) vendors like OpenAI take a lot of type level mistakes when composing the arguments of the target function to call. Even though an LLM function calling schema has defined an Array<string> type, LLM often fills it just by a string typed value.Therefore, when developing an LLM function calling agent, the validation feedback process is essentially required. If LLM takes a type level mistake on arguments composition, the agent must feedback the most detailed validation errors, and let the LLM to retry the function calling referencing the validation errors.About the validation feedback, @agentica/core is utilizing typia.validate<T>() and typia.llm.application<Class, Model>() functions. They construct validation logic by analyzing TypeScript source codes and types in the compilation level, so that detailed and accurate than any other validators like below.Such validation feedback strategy and combination with typia runtime validator, @agentica/core has achieved the most ideal LLM function calling. In my experience, when using OpenAI's gpt-4o-mini model, it tends to construct invalid function calling arguments at the first trial about 50% of the time. By the way, if correct it through validation feedback with typia, success rate soars to 99%. And I've never had a failure when trying validation feedback twice.For reference, the embedded typia.validate<T>() function creates validation logic by analyzing TypeScript source codes and types in the compilation level. Therefore, it is accurate and detailed than any other validator libraries. This is exactly what is needed for function calling, and I can confidentelly say that typia is the best library for LLM function calling.\nAdditionally, this validation feedback strategy is useful for some LLM providers do not supporting restriction properties of JSON schema like OpenAI (IChatGptSchema) and Gemini (IGeminiSchema). For example, OpenAI and Gemini do not support format property of JSON schema, so that cannot understand the UUID like type. Even though typia.llm.application<App, Model>() function is writing the restriction information to the description property of JSON schema, but LLM provider does not reflect it perfectly.Also, some LLM providers which have not specified the JSON schema version like Claude (IClaudeSchema) and Llama (ILlamaSchema), they tend to fail a lot of function calling about the restriction properties. In fact, Llama does not support function calling formally, so you have to detour it by prompt template, and its success rate is lower than others.In that case, if you give validation feedback from ILlmFunction.validate() function to the LLM agent, the LLM agent will be able to understand the restriction information exactly and fill the arguments properly.\nRestriction properties of JSON schema\nstring: minLength, maxLength, pattern, format, contentMediaType\nnumber: minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf\narray: minItems, maxItems, uniqueItems, items","openapi-specification#OpenAPI Specification":"@agentica/core obtains LLM function calling schemas from both Swagger/OpenAPI documents and TypeScript class types. The TypeScript class type can be converted to LLM function calling schema by typia.llm.application<Class, Model>() function. Then how about OpenAPI document? How Swagger document can be LLM function calling schema.The secret is in the above diagram.In the OpenAPI specification, there are three versions with different definitions. And even in the same version, there are too much ambiguous and duplicated expressions. To resolve these problems, @samchon/openapi is transforming every OpenAPI documents to v3.1 emended specification. The @samchon/openapi's emended v3.1 specification has removed every ambiguous and duplicated expressions for clarity.With the v3.1 emended OpenAPI document, @samchon/openapi converts it to a migration schema that is near to the function structure. And as the last step, the migration schema will be transformed to a specific LLM vendor's function calling schema. LLM function calling schemas are composed like this way.\nWhy do not directly convert, but intermediate?If directly convert from each version of OpenAPI specification to specific LLM's function calling schema, I have to make much more converters increased by cartesian product. In current models, number of converters would be 12 = 3 x 4.However, if define intermediate schema, number of converters are shrunk to plus operation. In current models, I just need to develop only (7 = 3 + 4) converters, and this is the reason why I've defined intermediate specification. This way is economic."}},"/docs/llm/schema":{"title":"Guide Documents > Large Language Model > schema() function","data":{"schema-function#schema() function":"export namespace llm {\n  // LLM FUNCTION CALLING APPLICATION SCHEMA\n  export function application<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplication.IOptions<Model>, \"separate\">>,\n  ): ILlmApplication<Model>;\n  // +VALIDATE FUNCTION EMBEDDED\n  export function applicationOfValidate<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplicationOfValidate.IOptions<Model>, \"separate\">>,\n  ): ILlmApplicationOfValidate<Model>;\n  // STRUCTURED OUTPUT\n  export function parameters<\n    Parameters extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(): ILlmSchema.ModelParameters[Model];\n  // TYPE SCHEMA\n  export function schema<\n    T,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    ...$defs: Extract<\n      ILlmSchema.ModelSchema[Model],\n      { $ref: string }\n    > extends never\n      ? []\n      : [Record<string, ILlmSchema.ModelSchema[Model]>]\n  ): ILlmSchema.ModelSchema[Model];\n}\nType schema in the LLM function calling application.typia.llm.schema<T, Model>() is a function generating type schema which is used in the LLM (Large Language Model) function calling application schema or structured output, especially composed by the typia.llm.parameters<Parameters, Model>() and typia.llm.application<App, Model>() functions.Return value type ILlmSchema is similar with the JSON schema definition. However, its detailed specification becomes different by the LLM provider model you've chosen. Here is the list of LLM schema definitions of each model. Determine one of them carefully reading the LLM schema definitions.\nSupported schemas\nIChatGptSchema: OpenAI ChatGPT\nIClaudeSchema: Anthropic Claude\nIGeminiSchema: Google Gemini\nILlamaSchema: Meta Llama\nMidldle layer schemas\nILlmSchemaV3: middle layer based on OpenAPI v3.0 specification\nILlmSchemaV3_1: middle layer based on OpenAPI v3.1 specification\nLLM Function Calling and Structured OutputLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"LLM function calling\" means that LLM automatically selects a proper function and fills parameter values from conversation with the user (may by chatting text).Structured output is another feature of LLM. The \"structured output\" means that LLM automatically transforms the output conversation into a structured data format like JSON.\nhttps://platform.openai.com/docs/guides/function-calling\nhttps://platform.openai.com/docs/guides/structured-outputs","specialization#Specialization":"You can utilize type tags (or validator's comment tags) to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. Also, there're special comment tags only for JSON schema definition that are different with validator's comment tags like below.\n@deprecated\n@hidden\n@internal\n@title {string}\nLet's see how those type tags, comment tags and description comments are working with example code.\nimport { IChatGptSchema } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\nexport const schema: IChatGptSchema = typia.llm.schema<Special, \"claude\">({\n  $defs: {},\n});\ninterface Special {\n  /**\n   * Deprecated tags are just used for marking.\n   *\n   * @title Unsigned integer\n   * @deprecated\n   */\n  type: number & tags.Type<\"int32\">;\n  /**\n   * Internal tagged property never be shown in JSON schema.\n   *\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\n   *\n   * @internal\n   */\n  internal: number[];\n  /**\n   * Hidden tagged property never be shown in JSON schema.\n   *\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\n   *\n   * @hidden\n   */\n  hidden: boolean;\n  /**\n   * You can limit the range of number.\n   *\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n  /**\n   * You can limit the length of string.\n   *\n   * Also, multiple range conditions are also possible.\n   */\n  string: string &\n    (\n      | (tags.MinLength<3> & tags.MaxLength<24>)\n      | (tags.MinLength<40> & tags.MaxLength<100>)\n    );\n  /**\n   * You can limit the pattern of string.\n   *\n   * @pattern ^[a-z]+$\n   */\n  pattern: string;\n  /**\n   * You can limit the format of string.\n   *\n   * @format date-time\n   */\n  format: string | null;\n  /**\n   * In the Array case, possible to restrict its elements.\n   */\n  array: Array<string & tags.Format<\"uuid\">> & tags.MinItems<3>;\n}\nimport typia from \"typia\";\nexport const schema = {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"integer\",\n      deprecated: true,\n      title: \"Unsigned integer\",\n      description: \"Deprecated tags are just used for marking.\",\n    },\n    number: {\n      type: \"number\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n      title: \"You can limit the range of number\",\n      description: \"You can limit the range of number.\",\n    },\n    string: {\n      oneOf: [\n        {\n          type: \"string\",\n          minLength: 3,\n          maxLength: 24,\n        },\n        {\n          type: \"string\",\n          minLength: 40,\n          maxLength: 100,\n        },\n      ],\n      title: \"You can limit the length of string\",\n      description:\n        \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\",\n    },\n    pattern: {\n      type: \"string\",\n      pattern: \"^[a-z]+$\",\n      title: \"You can limit the pattern of string\",\n      description: \"You can limit the pattern of string.\",\n    },\n    format: {\n      oneOf: [\n        {\n          type: \"string\",\n          format: \"date-time\",\n        },\n        {\n          type: \"null\",\n        },\n      ],\n      title: \"You can limit the format of string\",\n      description: \"You can limit the format of string.\",\n    },\n    array: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        format: \"uuid\",\n      },\n      minItems: 3,\n      title: \"In the Array case, possible to restrict its elements\",\n      description: \"In the Array case, possible to restrict its elements.\",\n    },\n  },\n  required: [\"type\", \"string\", \"pattern\", \"format\", \"array\"],\n  additionalProperties: false,\n};","customziation#Customziation":"If what you want is not just filling regular properties of LLM schema specification, but to adding custom properties into the JSON schema definition, you can do it through the tags.TagBase.schema property type or tags.JsonSchemaPlugin type.For reference, the custom property must be started with x- prefix. It's a rule of LLM schema.\nimport typia, { tags } from \"typia\";\n \ntype Monetary<Value extends string> = tags.TagBase<{\n  target: \"number\";\n  kind: \"monetary\";\n  value: Value;\n  schema: {\n    \"x-monetary\": Value;\n  };\n}>;\ntype Placeholder<Value extends string> = tags.JsonSchemaPlugin<{\n  \"x-placeholder\": Value;\n}>;\ninterface IAccount {\n  code: string & Placeholder<\"Write you account code please\">;\n  balance: number & Monetary<\"dollar\">;\n};\n \ntypia.llm.schema<IAccount, \"chatgpt\">();\nimport typia from \"typia\";\n({\n  type: \"object\",\n  properties: {\n    code: {\n      type: \"string\",\n      \"x-placeholder\": \"Write you account code please\",\n    },\n    balance: {\n      type: \"number\",\n      \"x-monetary\": \"dollar\",\n    },\n  },\n  required: [\"code\", \"balance\"],\n  additionalProperties: false,\n});","restrictions#Restrictions":"LLM schema does not support bigint type.LLM schema is based on the JSON schema definition of the OpenAPI v3.0 specification. Therefore, limitations of the JSON schema is also applied to the LLM schema, and the bigint type is not supported in the LLM function calling schema composition.Also, LLM schema does not support the tuple type, which is represented by the OpenApi.IJsonSchema.ITuple type. It's no LLM providers are supporting the tuple type, and such tuple type harms the separation option of the typia.llm.application<App, Model>() function. If you need a tuple type, just change the tuple type to a regular object type instead.\nimport typia from \"typia\";\ntypia.llm.schema<bigint, \"chatgpt\">({});\ntypia.llm.schema<[number, string], \"claude\">({});\nsrc/examples/llm.schema.bigint-and-tuple.ts:3:1 - error TS(typia.llm.schema): unsupported type detected\n- bigint\n  - LLM schema does not support bigint type.\n3 typia.llm.schema<bigint, \"chatgpt\">({});\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/examples/llm.schema.bigint-and-tuple.ts:4:1 - error TS(typia.llm.schema): failed to convert JSON schema to LLM schema.\n  - $input.schema: LLM does not allow tuple type.\n4 typia.llm.schema<[number, string], \"claude\">({});\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIf you're using Google Gemini (IGeminiSchema) or middle layer schema of ILlmSchemaV3, they do not support the reference type that is embodied by the OpenApi.IJsonSchema.IReference type with $ref property. Therefore, if recursive type comes, no way to express it perfectly in those IGeminiSchema and ILlmSchemaV3. They just repeat the recursive structure 3 times, and remove the recursive type after the 4 depths.For reference, if the recursive type comes from the array type, it would be zero length array type at the fourth step. Otherwise the recursive type comes from a property and the property is optional, the 4th property would be removed from the object type. At last, if the recursive type is combined as an oneOf type, the type would be removed from there.\nimport typia, { tags } from \"typia\";\ntypia.llm.schema<IDepartment, \"gemini\">();\ninterface IDepartment {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  department: IDepartment[];\n}\n\"use strict\";\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\n({\n  type: \"object\",\n  properties: {\n    id: {\n      type: \"string\",\n      format: \"uuid\",\n    },\n    name: {\n      type: \"string\",\n    },\n    department: {\n      type: \"array\",\n      items: {\n        type: \"object\",\n        properties: {\n          id: {\n            type: \"string\",\n            format: \"uuid\",\n          },\n          name: {\n            type: \"string\",\n          },\n          department: {\n            type: \"array\",\n            items: {\n              type: \"object\",\n              properties: {\n                id: {\n                  type: \"string\",\n                  format: \"uuid\",\n                },\n                name: {\n                  type: \"string\",\n                },\n                department: {\n                  type: \"array\",\n                  items: {\n                    type: \"object\",\n                    properties: {\n                      id: {\n                        type: \"string\",\n                        format: \"uuid\",\n                      },\n                      name: {\n                        type: \"string\",\n                      },\n                      department: {\n                        type: \"array\",\n                        items: {},\n                        maxItems: 0,\n                      },\n                    },\n                    required: [\"id\", \"name\", \"department\"],\n                    additionalProperties: false,\n                  },\n                },\n              },\n              required: [\"id\", \"name\", \"department\"],\n              additionalProperties: false,\n            },\n          },\n        },\n        required: [\"id\", \"name\", \"department\"],\n        additionalProperties: false,\n      },\n    },\n  },\n  required: [\"id\", \"name\", \"department\"],\n  additionalProperties: false,\n});\nAnd OpenAI ChatGPT (IChatGptSchema) and Google Gemini (IGeminiSchema) do not support the OpenApi.IJsonSchema.IObject.additionalProperties type, which represent the dynamic key typed object like Record<string, T> type in the TypeScript. Therefore, if you put the dynamic Record<string, T> type like below, typia.llm.schema<T, \"chatgpt\">() and typia.llm.schema<T, \"gemini\"> functions throw the compilation error like below.Therefore, if you want to utilzie OpenAI hatGPT (IChatGptSchema) or Google Gemini (IGeminiSchema), you have to change the Record<string, T> type to an array of regular object type like below. Note that, as LLM providers do not support the tuple type, you don't have to define the array type containing the tuple type.\nrecommended: Array<{ key: string, value: T }>\nnot recommended: Array<[string, T]>\nimport typia from \"typia\";\ntypia.llm.schema<Record<string, number>, \"chatgpt\">({});\ntypia.llm.schema<Record<string, number>, \"gemini\">();\nsrc/examples/llm.schema.additionalProperties.ts:3:1 - error TS(typia.llm.schema): unsupported type detected\n- Recordstringnumber\n  - LLM schema of \"chatgpt\" does not support dynamic property in object.  \n- Recordstringnumber: Recordstringnumber\n  - LLM schema of \"chatgpt\" does not support dynamic property in object.  \n3 typia.llm.schema<Record<string, number>, \"chatgpt\">({});\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/examples/llm.schema.additionalProperties.ts:4:1 - error TS(typia.llm.schema): unsupported type detected\n- Recordstringnumber\n  - LLM schema of \"gemini\" does not support dynamic property in object.   \n- Recordstringnumber: Recordstringnumber\n  - LLM schema of \"gemini\" does not support dynamic property in object.   \n4 typia.llm.schema<Record<string, number>, \"gemini\">();\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"}},"/docs/llm/strategy":{"title":"Guide Documents > Large Language Model > Documentation Strategy","data":{"description-comment#Description Comment":"import { ILlmApplication, ILlmFunction } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\"\n>();\nconst func: ILlmFunction<\"chatgpt\"> | undefined = app.functions.find(\n  func => func.name === \"create\"\n);\nconsole.log(func?.description);\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle>;\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param props Properties of update function\n   * @param input New content to update\n   */\n  update(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * New content to update.\n     */\n    input: IBbsArticle.IUpdate;\n  }): Promise<void>;\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param props Properties of erase function\n   */\n  erase(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): Promise<void>;\n}\n/**\n * Article entity.\n *\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n */\ninterface IBbsArticle extends IBbsArticle.ICreate {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n  /**\n   * Creation time of the article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n  /**\n   * Last updated time of the article.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n}\nnamespace IBbsArticle {\n  /**\n   * Information of the article to create.\n   */\n  export interface ICreate {\n    /**\n     * Title of the article.\n     *\n     * Representative title of the article.\n     */\n    title: string;\n    /**\n     * Content body.\n     *\n     * Content body of the article writtn in the markdown format.\n     */\n    body: string;\n    /**\n     * Thumbnail image URI.\n     *\n     * Thumbnail image URI which can represent the article.\n     *\n     * If configured as `null`, it means that no thumbnail image in the article.\n     */\n    thumbnail:\n      | null\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n  }\n  /**\n   * Information of the article to update.\n   *\n   * Only the filled properties will be updated.\n   */\n  export type IUpdate = Partial<ICreate>;\n}\nimport typia from \"typia\";\nconst app = {\n  model: \"chatgpt\",\n  options: {\n    reference: false,\n    strict: false,\n    separate: null,\n  },\n  functions: [\n    {\n      name: \"create\",\n      parameters: {\n        description: \" Properties of create function\",\n        type: \"object\",\n        properties: {\n          input: {\n            description:\n              \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n          },\n        },\n        required: [\"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      output: {\n        description:\n          \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Primary Key\",\n            description: \"Primary Key.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          created_at: {\n            title: \"Creation time of the article\",\n            description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          updated_at: {\n            title: \"Last updated time of the article\",\n            description:\n              \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          title: {\n            title: \"Title of the article\",\n            description:\n              \"Title of the article.\\n\\nRepresentative title of the article.\",\n            type: \"string\",\n          },\n          body: {\n            title: \"Content body\",\n            description:\n              \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            type: \"string\",\n          },\n          thumbnail: {\n            title: \"Thumbnail image URI\",\n            description:\n              \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            anyOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                description: \"@format uri\\n@contentMediaType image/*\",\n              },\n            ],\n          },\n        },\n        required: [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\",\n        ],\n      },\n      description:\n        \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n    },\n    {\n      name: \"update\",\n      parameters: {\n        description: \" Properties of update function\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description:\n              \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          input: {\n            description:\n              \"Make all properties in T optional\\n\\n------------------------------\\n\\nDescription of the current {@link PartialIBbsArticle.ICreate} type:\\n\\n> Make all properties in T optional\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [],\n          },\n        },\n        required: [\"id\", \"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Update an article.\\n\\nUpdates an article with new content.\",\n    },\n    {\n      name: \"erase\",\n      parameters: {\n        description: \" Properties of erase function\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description:\n              \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n        },\n        required: [\"id\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Erase an article.\\n\\nErases an article from the DB.\",\n    },\n  ],\n};\nconst func = app.functions.find((func) => func.name === \"create\");\nconsole.log(func?.description);\nconsole.log(func?.parameters.description);\nconsole.log(func?.output?.description);\nCreate a new article.\nWrites a new article and archives it into the DB.\nHere is the example code utilizing the typia.llm.application<App, Model>() function.As you can see, above example code is writing detailed descriptions for every functions and their parameter/return types. Such detailed descriptions are very important to teach the purpose of the function to the LLM (Language Large Model), and LLM actually determines which function to call by the description. Therefore, don’t forget to writing detailed descriptions. It’s very import feature for the LLM function calling.Also, ILlmFunction type which has only description property about the comment, but ILlmSchema has two descriptive properties; description and title. The title property of the ILlmSchema can be filled by two ways. The first way is closing the first line of the description comment with a period (.). By the way, this way's description property would be the entire description comment even including the first line.If you don't want that, you can adapt the second way that writing @title {string} comment tag. In that case, the title value would not be contained in the description value. For reference, it is possible to fill the description property of the ILlmSchema by the comment tag @description, but you have to take care of the indentation like below.\ninterface IMember {\n  /**\n   * Primary Key.\n   * \n   * Above \"Primary Key\" would be the title of LLM schema. \n   */\n  id: string;\n  /**\n   * Below \"Age of the member\" would be the title of LLM schema.\n   * \n   * @title Age of the member\n   */\n  age: number;\n  /**\n   * @title Email address of the member\n   * @description The description property also can be filled by \n   *              the comment tag `@description`. Instead, be\n   *              careful about the indentation.\n   */\n  email: string;\n}","namespace-strategy#Namespace Strategy":"import { ILlmApplication, ILlmFunction } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\",\n>();\nconst func: ILlmFunction<\"chatgpt\"> | undefined = app.functions.find(\n  func => func.name === \"create\"\n);\nconsole.log(func?.parameters.properties.input?.description);\n/**\n * Article entity.\n *\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n */\ninterface IBbsArticle extends IBbsArticle.ICreate {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n  /**\n   * Creation time of the article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n  /**\n   * Last updated time of the article.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n}\nnamespace IBbsArticle {\n  /**\n   * Information of the article to create.\n   */\n  export interface ICreate {\n    /**\n     * Title of the article.\n     *\n     * Representative title of the article.\n     */\n    title: string;\n    /**\n     * Content body.\n     *\n     * Content body of the article writtn in the markdown format.\n     */\n    body: string;\n    /**\n     * Thumbnail image URI.\n     *\n     * Thumbnail image URI which can represent the article.\n     *\n     * If configured as `null`, it means that no thumbnail image in the article.\n     */\n    thumbnail:\n      | null\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n  }\n  /**\n   * Information of the article to update.\n   *\n   * Only the filled properties will be updated.\n   */\n  export type IUpdate = Partial<ICreate>;\n}\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle>;\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param props Properties of update function\n   * @param input New content to update\n   */\n  update(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * New content to update.\n     */\n    input: IBbsArticle.IUpdate;\n  }): Promise<void>;\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param props Properties of erase function\n   */\n  erase(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): Promise<void>;\n}\nimport typia from \"typia\";\nconst app = {\n  model: \"chatgpt\",\n  options: {\n    reference: false,\n    strict: false,\n    separate: null,\n  },\n  functions: [\n    {\n      name: \"create\",\n      parameters: {\n        description: \" Properties of create function\",\n        type: \"object\",\n        properties: {\n          input: {\n            description:\n              \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n          },\n        },\n        required: [\"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      output: {\n        description:\n          \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Primary Key\",\n            description: \"Primary Key.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          created_at: {\n            title: \"Creation time of the article\",\n            description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          updated_at: {\n            title: \"Last updated time of the article\",\n            description:\n              \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          title: {\n            title: \"Title of the article\",\n            description:\n              \"Title of the article.\\n\\nRepresentative title of the article.\",\n            type: \"string\",\n          },\n          body: {\n            title: \"Content body\",\n            description:\n              \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            type: \"string\",\n          },\n          thumbnail: {\n            title: \"Thumbnail image URI\",\n            description:\n              \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            anyOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                description: \"@format uri\\n@contentMediaType image/*\",\n              },\n            ],\n          },\n        },\n        required: [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\",\n        ],\n      },\n      description:\n        \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n    },\n    {\n      name: \"update\",\n      parameters: {\n        description: \" Properties of update function\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description:\n              \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          input: {\n            description:\n              \"Make all properties in T optional\\n\\n------------------------------\\n\\nDescription of the current {@link PartialIBbsArticle.ICreate} type:\\n\\n> Make all properties in T optional\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [],\n          },\n        },\n        required: [\"id\", \"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Update an article.\\n\\nUpdates an article with new content.\",\n    },\n    {\n      name: \"erase\",\n      parameters: {\n        description: \" Properties of erase function\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description:\n              \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n        },\n        required: [\"id\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Erase an article.\\n\\nErases an article from the DB.\",\n    },\n  ],\n};\nconst func = app.functions.find((func) => func.name === \"create\");\nconsole.log(func?.parameters.properties.input?.description);\nInformation of the article to create.\n------------------------------\nDescription of the current {@link IBbsArticle.ICreate} type:\nInformation of the article to create.\n> Description of the parent {@link IBbsArticle} type: Article entity.\n> \n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\ntypia.llm.application<App, Model>() copies the parent namespaced type description comment to the children types. typia calls this comment writing strategy as namespace documentation, and it is recommended for the efficient documentation.As you can see from the above example, BbsArticleController has many CRUD functions about the IBbsArticle namespaced type. By the way, the above IBbsArticle.ICreate and IBbsArticle.IUpdate types are not repeating same description comments about the IBbsArticle type. Instead, just writing the short description comment about them, and just compose the LLM function calling application schema.In that case, the IBbsArticle type's description comment would be copied to the IBbsArticle.ICreate and IBbsArticle.IUpdate types like above \"Console Output\" case. It's a good strategy to avoid repeating same description comments, and also to deliver enough information to the LLM function calling.","function-hiding#Function Hiding":"import {\n  ClaudeTypeChecker,\n  ILlmApplication,\n  ILlmSchema,\n} from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\"\n>();\nconsole.log(app);\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle>;\n  /**\n   * Read an article.\n   * \n   * Reads an article from the DB.\n   * \n   * @param props Properties of read function\n   * @returns The article\n   * @hidden\n   */\n  at(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): Promise<IBbsArticle>;\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param props Properties of update function\n   * @param input New content to update\n   * @internal\n   */\n  update(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * New content to update.\n     */\n    input: IBbsArticle.IUpdate;\n  }): Promise<void>;\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param props Properties of erase function\n   * @human\n   */\n  erase(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): Promise<void>;\n}\nimport typia from \"typia\";\nconst app = {\n  model: \"chatgpt\",\n  options: {\n    reference: false,\n    separate: null,\n  },\n  functions: [\n    {\n      name: \"create\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          input: {\n            description:\n              \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n            additionalProperties: false,\n          },\n        },\n        required: [\"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      output: {\n        description:\n          \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Primary Key\",\n            description: \"Primary Key.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          created_at: {\n            title: \"Creation time of the article\",\n            description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          updated_at: {\n            title: \"Last updated time of the article\",\n            description:\n              \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          title: {\n            title: \"Title of the article\",\n            description:\n              \"Title of the article.\\n\\nRepresentative title of the article.\",\n            type: \"string\",\n          },\n          body: {\n            title: \"Content body\",\n            description:\n              \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            type: \"string\",\n          },\n          thumbnail: {\n            title: \"Thumbnail image URI\",\n            description:\n              \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            anyOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                description: \"@format uri\\n@contentMediaType image/*\",\n              },\n            ],\n          },\n        },\n        required: [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\",\n        ],\n        additionalProperties: false,\n      },\n      description:\n        \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n      strict: true,\n    },\n    {\n      name: \"update\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description:\n              \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          input: {\n            description:\n              \"Make all properties in T optional\\n\\n------------------------------\\n\\nDescription of the current {@link PartialIBbsArticle.ICreate} type:\\n\\n> Make all properties in T optional\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n            additionalProperties: false,\n          },\n        },\n        required: [\"id\", \"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Update an article.\\n\\nUpdates an article with new content.\",\n      strict: true,\n    },\n  ],\n};\nconsole.log(app);\nHiding some functions by comment tag.If you write @hidden, @human or @internal tag onto a function description comment, the function would not participate in the LLM (Large Language Model) function calling application composition. ILlmFunction schema does not be generated in the ILlmApplication.functions collection.It's a good feature to hide some internal functions, so that avoiding the LLM function calling.","specialization#Specialization":"import { IChatGptSchema } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\nexport const schema: IChatGptSchema = typia.llm.schema<Special, \"claude\">();\ninterface Special {\n  /**\n   * Deprecated tags are just used for marking.\n   *\n   * @title Unsigned integer\n   * @deprecated\n   */\n  type: number & tags.Type<\"int32\">;\n  /**\n   * Internal tagged property never be shown in JSON schema.\n   *\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\n   *\n   * @internal\n   */\n  internal: number[];\n  /**\n   * Hidden tagged property never be shown in JSON schema.\n   *\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\n   *\n   * @hidden\n   */\n  hidden: boolean;\n  /**\n   * You can limit the range of number.\n   *\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n  /**\n   * You can limit the length of string.\n   *\n   * Also, multiple range conditions are also possible.\n   */\n  string: string &\n    (\n      | (tags.MinLength<3> & tags.MaxLength<24>)\n      | (tags.MinLength<40> & tags.MaxLength<100>)\n    );\n  /**\n   * You can limit the pattern of string.\n   *\n   * @pattern ^[a-z]+$\n   */\n  pattern: string;\n  /**\n   * You can limit the format of string.\n   *\n   * @format date-time\n   */\n  format: string | null;\n  /**\n   * In the Array case, possible to restrict its elements.\n   */\n  array: Array<string & tags.Format<\"uuid\">> & tags.MinItems<3>;\n}\nimport typia from \"typia\";\nexport const schema = {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"integer\",\n      deprecated: true,\n      title: \"Unsigned integer\",\n      description: \"Deprecated tags are just used for marking.\",\n    },\n    number: {\n      type: \"number\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n      title: \"You can limit the range of number\",\n      description: \"You can limit the range of number.\",\n    },\n    string: {\n      oneOf: [\n        {\n          type: \"string\",\n          minLength: 3,\n          maxLength: 24,\n        },\n        {\n          type: \"string\",\n          minLength: 40,\n          maxLength: 100,\n        },\n      ],\n      title: \"You can limit the length of string\",\n      description:\n        \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\",\n    },\n    pattern: {\n      type: \"string\",\n      pattern: \"^[a-z]+$\",\n      title: \"You can limit the pattern of string\",\n      description: \"You can limit the pattern of string.\",\n    },\n    format: {\n      oneOf: [\n        {\n          type: \"string\",\n          format: \"date-time\",\n        },\n        {\n          type: \"null\",\n        },\n      ],\n      title: \"You can limit the format of string\",\n      description: \"You can limit the format of string.\",\n    },\n    array: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        format: \"uuid\",\n      },\n      minItems: 3,\n      title: \"In the Array case, possible to restrict its elements\",\n      description: \"In the Array case, possible to restrict its elements.\",\n    },\n  },\n  required: [\"type\", \"string\", \"pattern\", \"format\", \"array\"],\n  additionalProperties: false,\n};\nYou can utilize type tags (or validator's comment tags) to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. Also, there're special comment tags only for JSON schema definition that are different with validator's comment tags like below.\n@deprecated\n@hidden\n@internal\n@title {string}\nLet's see how those type tags, comment tags and description comments are working with example code.","customization#Customization":"If what you want is not just filling regular properties of LLM schema specification, but to adding custom properties into the JSON schema definition, you can do it through the tags.TagBase.schema property type or tags.JsonSchemaPlugin type.For reference, the custom property must be started with x- prefix. It's a rule of LLM schema.\nimport typia, { tags } from \"typia\";\n \ntype Monetary<Value extends string> = tags.TagBase<{\n  target: \"number\";\n  kind: \"monetary\";\n  value: Value;\n  schema: {\n    \"x-monetary\": Value;\n  };\n}>;\ntype Placeholder<Value extends string> = tags.JsonSchemaPlugin<{\n  \"x-placeholder\": Value;\n}>;\ninterface IAccount {\n  code: string & Placeholder<\"Write you account code please\">;\n  balance: number & Monetary<\"dollar\">;\n};\n \ntypia.llm.schema<IAccount, \"chatgpt\">();\nimport typia from \"typia\";\n({\n  type: \"object\",\n  properties: {\n    code: {\n      type: \"string\",\n      \"x-placeholder\": \"Write you account code please\",\n    },\n    balance: {\n      type: \"number\",\n      \"x-monetary\": \"dollar\",\n    },\n  },\n  required: [\"code\", \"balance\"],\n  additionalProperties: false,\n});"}},"/docs/protobuf/decode":{"title":"Guide Documents > Protobuf > decode() functions","data":{"decode-functions#decode() functions":"export namespace protobuf {\n  export function decode<T>(buffer: Uint8Array): Resolved<T>;\n  export function isDecode<T>(buffer: Uint8Array): Resolved<T> | null;\n  export function assertDecode<T>(buffer: Uint8Array): Resolved<T>;\n  export function validateDecode<T>(\n    buffer: Uint8Array,\n  ): IValidation<Resolved<T>>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\nProtocol Buffer Decoder.You can easily convert a Protocol Buffer's binary data to a JavaScript object, without any extra Protocol Buffer Message Schema definition. typia.protobuf.decode<T>() function analyzes your type T, and generates a Protocol Buffer Message Schema internally.And then, it converts the binary data to a JavaScript object.By the way, as Protocol Buffer handles binary data directly, there's no way when input binary data was not encoded from the T typed value. In that case, unexpected behavior or internal error would be occurred. Therefore, I recommend you to encode binary data of Protocol Buffer from type safe encode functions like below, Use typia.protobuf.encode<T>() function only when you can trust it.\ntypia.protobuf.isEncode<T>()\ntypia.protobuf.assertEncode<T>()\ntypia.protobuf.validateEncode<T>()\nFor reference, typia provides type safe decorators like below, but they are just for additional type validation like number & Minimum<7> or string & Format<\"uuid\"> cases, that are represented by Special Tags. Thus, I repeat that, you've to ensure type safety when using decoder function.\ntypia.protobuf.isDecode<T>(): typia.is<T>() + typia.protobuf.decode<T>()\ntypia.protobuf.assertDecode<T>(): typia.assert<T>() + typia.protobuf.decode<T>()\ntypia.protobuf.validateDecode<T>(): typia.validate<T>() + typia.protobuf.decode<T>()\nAOT compilation\ntypia.protobuf.decode<T>() and other similar functions are still much faster than any other competitive libraries, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\nimport typia, { tags } from \"typia\";\n \nconst member: IMember = typia.random<IMember>();\nconst encoded: Uint8Array = typia.protobuf.encode<IMember>(member);\nconst decoded: IMember = typia.protobuf.decode<IMember>(encoded);\nconsole.log(member, decoded);\ninterface IMember {\n  id:\n    | (string & tags.Sequence<11>)\n    | (number & tags.Type<\"uint64\"> & tags.Sequence<12>)\n    | (Uint8Array & tags.Sequence<13>);\n  name: (string & tags.Sequence<20>) | null;\n  children: Array<IMember> & tags.Sequence<30>;\n  keywords: Map<string, string> & tags.Sequence<40>;\n  thumbnail:\n    | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">)\n    | Uint8Array;\n  email: string & tags.Format<\"email\">;\n  hobbies: Array<IHobby>;\n}\ninterface IHobby {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  valid: boolean;\n}\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__randomArray from \"typia/lib/internal/_randomArray.js\";\nimport * as __typia_transform__randomPick from \"typia/lib/internal/_randomPick.js\";\nimport * as __typia_transform__randomFormatUri from \"typia/lib/internal/_randomFormatUri.js\";\nimport * as __typia_transform__randomFormatEmail from \"typia/lib/internal/_randomFormatEmail.js\";\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomBoolean from \"typia/lib/internal/_randomBoolean.js\";\nimport * as __typia_transform__throwTypeGuardError from \"typia/lib/internal/_throwTypeGuardError.js\";\nimport * as __typia_transform__isTypeUint64 from \"typia/lib/internal/_isTypeUint64.js\";\nimport * as __typia_transform__isFormatUri from \"typia/lib/internal/_isFormatUri.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__ProtobufSizer from \"typia/lib/internal/_ProtobufSizer.js\";\nimport * as __typia_transform__ProtobufWriter from \"typia/lib/internal/_ProtobufWriter.js\";\nimport * as __typia_transform__ProtobufReader from \"typia/lib/internal/_ProtobufReader.js\";\nimport typia from \"typia\";\nconst member = (() => {\n  const _ro0 = (_recursive = true, _depth = 0) => ({\n    id: __typia_transform__randomPick._randomPick([\n      () =>\n        (_generator?.string ?? __typia_transform__randomString._randomString)({\n          type: \"string\",\n          \"x-protobuf-sequence\": 11,\n        }),\n      () =>\n        (\n          _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n        )({\n          type: \"integer\",\n          \"x-protobuf-sequence\": 12,\n        }),\n      () =>\n        new Uint8Array(\n          5 >= _depth\n            ? (\n                _generator?.array ?? __typia_transform__randomArray._randomArray\n              )({\n                type: \"array\",\n                element: () =>\n                  (\n                    _generator?.integer ??\n                    __typia_transform__randomInteger._randomInteger\n                  )({\n                    type: \"integer\",\n                    minimum: 0,\n                    maximum: 255,\n                  }),\n              })\n            : [],\n        ),\n    ])(),\n    name: __typia_transform__randomPick._randomPick([\n      () => null,\n      () =>\n        (_generator?.string ?? __typia_transform__randomString._randomString)({\n          type: \"string\",\n          \"x-protobuf-sequence\": 20,\n        }),\n    ])(),\n    children:\n      5 >= _depth\n        ? (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n            type: \"array\",\n            \"x-protobuf-sequence\": 30,\n            element: () => _ro0(true, _recursive ? 1 + _depth : _depth),\n          })\n        : [],\n    keywords: new Map(\n      5 >= _depth\n        ? (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n            type: \"array\",\n            element: () => [\n              (\n                _generator?.string ??\n                __typia_transform__randomString._randomString\n              )({\n                type: \"string\",\n              }),\n              (\n                _generator?.string ??\n                __typia_transform__randomString._randomString\n              )({\n                type: \"string\",\n              }),\n            ],\n          })\n        : [],\n    ),\n    thumbnail: __typia_transform__randomPick._randomPick([\n      () =>\n        (\n          _generator?.uri ?? __typia_transform__randomFormatUri._randomFormatUri\n        )(),\n      () =>\n        new Uint8Array(\n          5 >= _depth\n            ? (\n                _generator?.array ?? __typia_transform__randomArray._randomArray\n              )({\n                type: \"array\",\n                element: () =>\n                  (\n                    _generator?.integer ??\n                    __typia_transform__randomInteger._randomInteger\n                  )({\n                    type: \"integer\",\n                    minimum: 0,\n                    maximum: 255,\n                  }),\n              })\n            : [],\n        ),\n    ])(),\n    email: (\n      _generator?.email ??\n      __typia_transform__randomFormatEmail._randomFormatEmail\n    )(),\n    hobbies:\n      5 >= _depth\n        ? (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n            type: \"array\",\n            element: () => _ro1(true, _recursive ? 1 + _depth : _depth),\n          })\n        : [],\n  });\n  const _ro1 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n      },\n    ),\n    valid: (\n      _generator?.boolean ?? __typia_transform__randomBoolean._randomBoolean\n    )({\n      type: \"boolean\",\n    }),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconst encoded = (() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"id\": ((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>));\n      if (input.id instanceof Uint8Array) {\n        writer.uint32(106);\n        writer.bytes(input.id);\n      } else if (\"number\" === typeof input.id) {\n        writer.uint32(96);\n        writer.uint64(input.id);\n      } else if (\"string\" === typeof input.id) {\n        writer.uint32(90);\n        writer.string(input.id);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.encode\",\n          expected:\n            '((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>))',\n          value: input.id,\n        });\n      // property \"name\": ((string & Sequence<20>) | null);\n      if (null !== input.name) {\n        writer.uint32(162);\n        writer.string(input.name);\n      }\n      // property \"children\": (Array<IMember> & Sequence<30>);\n      if (0 !== input.children.length) {\n        for (const elem of input.children) {\n          writer.uint32(242);\n          writer.fork();\n          _peo0(elem);\n          writer.ldelim();\n        }\n      }\n      // property \"keywords\": (Map<string, string> & Sequence<40>);\n      for (const [key, value] of input.keywords) {\n        writer.uint32(322);\n        writer.fork();\n        writer.uint32(10);\n        writer.string(key);\n        writer.uint32(18);\n        writer.string(value);\n        writer.ldelim();\n      }\n      // property \"thumbnail\": ((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array);\n      if (input.thumbnail instanceof Uint8Array) {\n        writer.uint32(330);\n        writer.bytes(input.thumbnail);\n      } else if (\"string\" === typeof input.thumbnail) {\n        writer.uint32(338);\n        writer.string(input.thumbnail);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.encode\",\n          expected:\n            '((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array)',\n          value: input.thumbnail,\n        });\n      // property \"email\": (string & Format<\"email\">);\n      writer.uint32(346);\n      writer.string(input.email);\n      // property \"hobbies\": Array<IHobby>;\n      if (0 !== input.hobbies.length) {\n        for (const elem of input.hobbies) {\n          writer.uint32(354);\n          writer.fork();\n          _peo1(elem);\n          writer.ldelim();\n        }\n      }\n    };\n    const _peo1 = (input) => {\n      // property \"id\": (string & Format<\"uuid\">);\n      writer.uint32(10);\n      writer.string(input.id);\n      // property \"name\": string;\n      writer.uint32(18);\n      writer.string(input.name);\n      // property \"valid\": boolean;\n      writer.uint32(24);\n      writer.bool(input.valid);\n    };\n    const _io0 = (input) =>\n      null !== input.id &&\n      undefined !== input.id &&\n      (\"string\" === typeof input.id ||\n        (\"number\" === typeof input.id &&\n          __typia_transform__isTypeUint64._isTypeUint64(input.id)) ||\n        input.id instanceof Uint8Array) &&\n      (null === input.name || \"string\" === typeof input.name) &&\n      Array.isArray(input.children) &&\n      input.children.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io0(elem),\n      ) &&\n      input.keywords instanceof Map &&\n      (() =>\n        [...input.keywords].every(\n          (elem) =>\n            Array.isArray(elem) &&\n            elem.length === 2 &&\n            \"string\" === typeof elem[0] &&\n            \"string\" === typeof elem[1],\n        ))() &&\n      null !== input.thumbnail &&\n      undefined !== input.thumbnail &&\n      ((\"string\" === typeof input.thumbnail &&\n        __typia_transform__isFormatUri._isFormatUri(input.thumbnail)) ||\n        input.thumbnail instanceof Uint8Array) &&\n      \"string\" === typeof input.email &&\n      __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n      Array.isArray(input.hobbies) &&\n      input.hobbies.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n      );\n    const _io1 = (input) =>\n      \"string\" === typeof input.id &&\n      __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n      \"string\" === typeof input.name &&\n      \"boolean\" === typeof input.valid;\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})()(member);\nconst decoded = (() => {\n  const _pdo0 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      id: new Uint8Array([]),\n      name: null,\n      children: [],\n      keywords: new Map(),\n      thumbnail: new Uint8Array([]),\n      email: \"\",\n      hobbies: [],\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 13:\n          // bytes;\n          output.id = reader.bytes();\n          break;\n        case 12:\n          // uint64;\n          output.id = Number(reader.uint64());\n          break;\n        case 11:\n          // string;\n          output.id = reader.string();\n          break;\n        case 20:\n          // string;\n          output.name = reader.string();\n          break;\n        case 30:\n          // Array<IMember>;\n          output.children.push(_pdo0(reader, reader.uint32()));\n          break;\n        case 40:\n          // Map<string, string>;\n          (() => {\n            output.keywords ??= new Map();\n            const piece = reader.uint32() + reader.index();\n            const entry = {\n              key: \"\",\n              value: \"\",\n            };\n            while (reader.index() < piece) {\n              const kind = reader.uint32();\n              switch (kind >>> 3) {\n                case 1:\n                  // string;\n                  entry.key = reader.string();\n                  break;\n                case 2:\n                  // string;\n                  entry.value = reader.string();\n                  break;\n                default:\n                  reader.skipType(kind & 7);\n                  break;\n              }\n            }\n            output.keywords.set(entry.key, entry.value);\n          })();\n          break;\n        case 41:\n          // bytes;\n          output.thumbnail = reader.bytes();\n          break;\n        case 42:\n          // string;\n          output.thumbnail = reader.string();\n          break;\n        case 43:\n          // string;\n          output.email = reader.string();\n          break;\n        case 44:\n          // Array<IHobby>;\n          output.hobbies.push(_pdo1(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  const _pdo1 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      id: \"\",\n      name: \"\",\n      valid: undefined,\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          // string;\n          output.id = reader.string();\n          break;\n        case 2:\n          // string;\n          output.name = reader.string();\n          break;\n        case 3:\n          // bool;\n          output.valid = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  return (input) => {\n    const reader = new __typia_transform__ProtobufReader._ProtobufReader(input);\n    return _pdo0(reader);\n  };\n})()(encoded);\nconsole.log(member, decoded);","reusable-functions#Reusable functions":"export namespace protobuf {\n  export function createDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\n  export function createIsDecode<T>: (buffer: Uint8Array) => Resolved<T> | null;\n  export function createAssertDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\n  export function createValidateDecode<T>(): (\n      buffer: Uint8Array\n  ) => IValidation<Resolved<T>>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\nReusable typia.protobuf.decode<T>() function generators.If you repeat to call typia.protobuf.decode<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.protobuf.createDecode<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\n \nexport const decode = typia.protobuf.createDecode<IMember>();\ninterface IMember {\n  id:\n    | (string & tags.Sequence<11>)\n    | (number & tags.Type<\"uint64\"> & tags.Sequence<12>)\n    | (Uint8Array & tags.Sequence<13>);\n  name: (string & tags.Sequence<20>) | null;\n  children: Array<IMember> & tags.Sequence<30>;\n  keywords: Map<string, string> & tags.Sequence<40>;\n  thumbnail:\n    | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">)\n    | Uint8Array;\n  email: string & tags.Format<\"email\">;\n  hobbies: Array<IHobby>;\n}\ninterface IHobby {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  valid: boolean;\n}\nimport * as __typia_transform__ProtobufReader from \"typia/lib/internal/_ProtobufReader.js\";\nimport typia from \"typia\";\nexport const decode = (() => {\n  const _pdo0 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      id: new Uint8Array([]),\n      name: null,\n      children: [],\n      keywords: new Map(),\n      thumbnail: new Uint8Array([]),\n      email: \"\",\n      hobbies: [],\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 13:\n          // bytes;\n          output.id = reader.bytes();\n          break;\n        case 12:\n          // uint64;\n          output.id = Number(reader.uint64());\n          break;\n        case 11:\n          // string;\n          output.id = reader.string();\n          break;\n        case 20:\n          // string;\n          output.name = reader.string();\n          break;\n        case 30:\n          // Array<IMember>;\n          output.children.push(_pdo0(reader, reader.uint32()));\n          break;\n        case 40:\n          // Map<string, string>;\n          (() => {\n            output.keywords ??= new Map();\n            const piece = reader.uint32() + reader.index();\n            const entry = {\n              key: \"\",\n              value: \"\",\n            };\n            while (reader.index() < piece) {\n              const kind = reader.uint32();\n              switch (kind >>> 3) {\n                case 1:\n                  // string;\n                  entry.key = reader.string();\n                  break;\n                case 2:\n                  // string;\n                  entry.value = reader.string();\n                  break;\n                default:\n                  reader.skipType(kind & 7);\n                  break;\n              }\n            }\n            output.keywords.set(entry.key, entry.value);\n          })();\n          break;\n        case 41:\n          // bytes;\n          output.thumbnail = reader.bytes();\n          break;\n        case 42:\n          // string;\n          output.thumbnail = reader.string();\n          break;\n        case 43:\n          // string;\n          output.email = reader.string();\n          break;\n        case 44:\n          // Array<IHobby>;\n          output.hobbies.push(_pdo1(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  const _pdo1 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      id: \"\",\n      name: \"\",\n      valid: undefined,\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          // string;\n          output.id = reader.string();\n          break;\n        case 2:\n          // string;\n          output.name = reader.string();\n          break;\n        case 3:\n          // bool;\n          output.valid = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  return (input) => {\n    const reader = new __typia_transform__ProtobufReader._ProtobufReader(input);\n    return _pdo0(reader);\n  };\n})();","references#References":"Protocol Buffer supports special numeric types like int32 or uint64 that are not supported in TypeScript. Also, types of Protocol Buffer cannot fully meet TypeScript type specs either, as expression power of TypeScript types are much stronger than Protocol Buffer.To know how to define special numeric types like uint64, and to understand which TypeScript types are not supported in Protocol Buffer specs, it would better to read below documents. I recommend you to read them before using typia.protobuf.decode<T>() related functions.\nTypia Guide Documents > Protocol Buffer > Message Schema\nmessage() function\nType Tags\nComment Tags\nRestrictions"}},"/docs/protobuf/encode":{"title":"Guide Documents > Protobuf > encode() functions","data":{"encode-functions#encode() functions":"export namespace protobuf {\n  export function encode<T>(input: T): Uint8Array;\n  export function isEncode<T>(input: T): Uint8Array | null;\n  export function assertEncode<T>(input: T): Uint8Array;\n  export function validateEncode<T>(input: T): IValidation<Uint8Array>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\nProtocol Buffer Encoder.You can easily convert a JavaScript object to a binary data of Protocol Buffer, without any extra Protocol Buffer Message Schema definition. typia.protobuf.encode<T>() function analyzes your type T, and generates a Protocol Buffer Message Schema internally. And then, it converts the input instance to the binary data of Protocol Buffer format.By the way, typia.protobuf.encode<T>() function does not validate the input value. It just believes user and input value, and converts to the Protocol Buffer binary data directly without any validation. By the way, if the input value was not validate, the encoded binary data never can be decoded. So, if you can't sure the input value type, you should use below functions instead.\ntypia.protobuf.isEncode<T>(): typia.is<T>() + typia.protobuf.encode<T>()\ntypia.protobuf.assertEncode<T>(): typia.assert<T>() + typia.protobuf.encode<T>()\ntypia.protobuf.validateEncode<T>(): typia.validate<T>() + typia.protobuf.encode<T>()\nAOT compilation\ntypia.protobuf.encode<T>() and other similar functions are still much faster than any other competitive libraries, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\nimport typia, { tags } from \"typia\";\nconst member: IMember = typia.random<IMember>();\nconst byte: Uint8Array = typia.protobuf.encode<IMember>(member);\nconsole.log(byte);\ninterface IMember {\n  id:\n    | (string & tags.Sequence<11>)\n    | (number & tags.Type<\"uint64\"> & tags.Sequence<12>)\n    | (Uint8Array & tags.Sequence<13>);\n  name: (string & tags.Sequence<20>) | null;\n  children: Array<IMember> & tags.Sequence<30>;\n  keywords: Map<string, string> & tags.Sequence<40>;\n  thumbnail:\n    | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">)\n    | Uint8Array;\n  email: string & tags.Format<\"email\">;\n  hobbies: Array<IHobby>;\n}\ninterface IHobby {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  valid: boolean;\n}\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__randomArray from \"typia/lib/internal/_randomArray.js\";\nimport * as __typia_transform__randomPick from \"typia/lib/internal/_randomPick.js\";\nimport * as __typia_transform__randomFormatUri from \"typia/lib/internal/_randomFormatUri.js\";\nimport * as __typia_transform__randomFormatEmail from \"typia/lib/internal/_randomFormatEmail.js\";\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomBoolean from \"typia/lib/internal/_randomBoolean.js\";\nimport * as __typia_transform__throwTypeGuardError from \"typia/lib/internal/_throwTypeGuardError.js\";\nimport * as __typia_transform__isTypeUint64 from \"typia/lib/internal/_isTypeUint64.js\";\nimport * as __typia_transform__isFormatUri from \"typia/lib/internal/_isFormatUri.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__ProtobufSizer from \"typia/lib/internal/_ProtobufSizer.js\";\nimport * as __typia_transform__ProtobufWriter from \"typia/lib/internal/_ProtobufWriter.js\";\nimport typia from \"typia\";\nconst member = (() => {\n  const _ro0 = (_recursive = true, _depth = 0) => ({\n    id: __typia_transform__randomPick._randomPick([\n      () =>\n        (_generator?.string ?? __typia_transform__randomString._randomString)({\n          type: \"string\",\n          \"x-protobuf-sequence\": 11,\n        }),\n      () =>\n        (\n          _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n        )({\n          type: \"integer\",\n          \"x-protobuf-sequence\": 12,\n        }),\n      () =>\n        new Uint8Array(\n          5 >= _depth\n            ? (\n                _generator?.array ?? __typia_transform__randomArray._randomArray\n              )({\n                type: \"array\",\n                element: () =>\n                  (\n                    _generator?.integer ??\n                    __typia_transform__randomInteger._randomInteger\n                  )({\n                    type: \"integer\",\n                    minimum: 0,\n                    maximum: 255,\n                  }),\n              })\n            : [],\n        ),\n    ])(),\n    name: __typia_transform__randomPick._randomPick([\n      () => null,\n      () =>\n        (_generator?.string ?? __typia_transform__randomString._randomString)({\n          type: \"string\",\n          \"x-protobuf-sequence\": 20,\n        }),\n    ])(),\n    children:\n      5 >= _depth\n        ? (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n            type: \"array\",\n            \"x-protobuf-sequence\": 30,\n            element: () => _ro0(true, _recursive ? 1 + _depth : _depth),\n          })\n        : [],\n    keywords: new Map(\n      5 >= _depth\n        ? (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n            type: \"array\",\n            element: () => [\n              (\n                _generator?.string ??\n                __typia_transform__randomString._randomString\n              )({\n                type: \"string\",\n              }),\n              (\n                _generator?.string ??\n                __typia_transform__randomString._randomString\n              )({\n                type: \"string\",\n              }),\n            ],\n          })\n        : [],\n    ),\n    thumbnail: __typia_transform__randomPick._randomPick([\n      () =>\n        (\n          _generator?.uri ?? __typia_transform__randomFormatUri._randomFormatUri\n        )(),\n      () =>\n        new Uint8Array(\n          5 >= _depth\n            ? (\n                _generator?.array ?? __typia_transform__randomArray._randomArray\n              )({\n                type: \"array\",\n                element: () =>\n                  (\n                    _generator?.integer ??\n                    __typia_transform__randomInteger._randomInteger\n                  )({\n                    type: \"integer\",\n                    minimum: 0,\n                    maximum: 255,\n                  }),\n              })\n            : [],\n        ),\n    ])(),\n    email: (\n      _generator?.email ??\n      __typia_transform__randomFormatEmail._randomFormatEmail\n    )(),\n    hobbies:\n      5 >= _depth\n        ? (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n            type: \"array\",\n            element: () => _ro1(true, _recursive ? 1 + _depth : _depth),\n          })\n        : [],\n  });\n  const _ro1 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n      },\n    ),\n    valid: (\n      _generator?.boolean ?? __typia_transform__randomBoolean._randomBoolean\n    )({\n      type: \"boolean\",\n    }),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconst byte = (() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"id\": ((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>));\n      if (input.id instanceof Uint8Array) {\n        writer.uint32(106);\n        writer.bytes(input.id);\n      } else if (\"number\" === typeof input.id) {\n        writer.uint32(96);\n        writer.uint64(input.id);\n      } else if (\"string\" === typeof input.id) {\n        writer.uint32(90);\n        writer.string(input.id);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.encode\",\n          expected:\n            '((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>))',\n          value: input.id,\n        });\n      // property \"name\": ((string & Sequence<20>) | null);\n      if (null !== input.name) {\n        writer.uint32(162);\n        writer.string(input.name);\n      }\n      // property \"children\": (Array<IMember> & Sequence<30>);\n      if (0 !== input.children.length) {\n        for (const elem of input.children) {\n          writer.uint32(242);\n          writer.fork();\n          _peo0(elem);\n          writer.ldelim();\n        }\n      }\n      // property \"keywords\": (Map<string, string> & Sequence<40>);\n      for (const [key, value] of input.keywords) {\n        writer.uint32(322);\n        writer.fork();\n        writer.uint32(10);\n        writer.string(key);\n        writer.uint32(18);\n        writer.string(value);\n        writer.ldelim();\n      }\n      // property \"thumbnail\": ((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array);\n      if (input.thumbnail instanceof Uint8Array) {\n        writer.uint32(330);\n        writer.bytes(input.thumbnail);\n      } else if (\"string\" === typeof input.thumbnail) {\n        writer.uint32(338);\n        writer.string(input.thumbnail);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.encode\",\n          expected:\n            '((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array)',\n          value: input.thumbnail,\n        });\n      // property \"email\": (string & Format<\"email\">);\n      writer.uint32(346);\n      writer.string(input.email);\n      // property \"hobbies\": Array<IHobby>;\n      if (0 !== input.hobbies.length) {\n        for (const elem of input.hobbies) {\n          writer.uint32(354);\n          writer.fork();\n          _peo1(elem);\n          writer.ldelim();\n        }\n      }\n    };\n    const _peo1 = (input) => {\n      // property \"id\": (string & Format<\"uuid\">);\n      writer.uint32(10);\n      writer.string(input.id);\n      // property \"name\": string;\n      writer.uint32(18);\n      writer.string(input.name);\n      // property \"valid\": boolean;\n      writer.uint32(24);\n      writer.bool(input.valid);\n    };\n    const _io0 = (input) =>\n      null !== input.id &&\n      undefined !== input.id &&\n      (\"string\" === typeof input.id ||\n        (\"number\" === typeof input.id &&\n          __typia_transform__isTypeUint64._isTypeUint64(input.id)) ||\n        input.id instanceof Uint8Array) &&\n      (null === input.name || \"string\" === typeof input.name) &&\n      Array.isArray(input.children) &&\n      input.children.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io0(elem),\n      ) &&\n      input.keywords instanceof Map &&\n      (() =>\n        [...input.keywords].every(\n          (elem) =>\n            Array.isArray(elem) &&\n            elem.length === 2 &&\n            \"string\" === typeof elem[0] &&\n            \"string\" === typeof elem[1],\n        ))() &&\n      null !== input.thumbnail &&\n      undefined !== input.thumbnail &&\n      ((\"string\" === typeof input.thumbnail &&\n        __typia_transform__isFormatUri._isFormatUri(input.thumbnail)) ||\n        input.thumbnail instanceof Uint8Array) &&\n      \"string\" === typeof input.email &&\n      __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n      Array.isArray(input.hobbies) &&\n      input.hobbies.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n      );\n    const _io1 = (input) =>\n      \"string\" === typeof input.id &&\n      __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n      \"string\" === typeof input.name &&\n      \"boolean\" === typeof input.valid;\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})()(member);\nconsole.log(byte);","reusable-functions#Reusable Functions":"export namespace protobuf {\n  export function encode<T>(): (input: T) => Uint8Array;\n  export function isEncode<T>(): (input: T) => Uint8Array | null;\n  export function assertEncode<T>(): (input: T) => Uint8Array;\n  export function validateEncode<T>(): (input: T) => IValidation<Uint8Array>;\n}\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\ninterface IValueOf<T> {\n  valueOf(): T;\n}\nReusable typia.protobuf.encode<T>() function generators.If you repeat to call typia.protobuf.encode<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.protobuf.createEncode<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\nexport const encode = typia.protobuf.createEncode<IMember>();\ninterface IMember {\n  id:\n    | (string & tags.Sequence<11>)\n    | (number & tags.Type<\"uint64\"> & tags.Sequence<12>)\n    | (Uint8Array & tags.Sequence<13>);\n  name: (string & tags.Sequence<20>) | null;\n  children: Array<IMember> & tags.Sequence<30>;\n  keywords: Map<string, string> & tags.Sequence<40>;\n  thumbnail:\n    | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">)\n    | Uint8Array;\n  email: string & tags.Format<\"email\">;\n  hobbies: Array<IHobby>;\n}\ninterface IHobby {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  valid: boolean;\n}\nimport * as __typia_transform__throwTypeGuardError from \"typia/lib/internal/_throwTypeGuardError.js\";\nimport * as __typia_transform__isTypeUint64 from \"typia/lib/internal/_isTypeUint64.js\";\nimport * as __typia_transform__isFormatUri from \"typia/lib/internal/_isFormatUri.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__ProtobufSizer from \"typia/lib/internal/_ProtobufSizer.js\";\nimport * as __typia_transform__ProtobufWriter from \"typia/lib/internal/_ProtobufWriter.js\";\nimport typia from \"typia\";\nexport const encode = (() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"id\": ((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>));\n      if (input.id instanceof Uint8Array) {\n        writer.uint32(106);\n        writer.bytes(input.id);\n      } else if (\"number\" === typeof input.id) {\n        writer.uint32(96);\n        writer.uint64(input.id);\n      } else if (\"string\" === typeof input.id) {\n        writer.uint32(90);\n        writer.string(input.id);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected:\n            '((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>))',\n          value: input.id,\n        });\n      // property \"name\": ((string & Sequence<20>) | null);\n      if (null !== input.name) {\n        writer.uint32(162);\n        writer.string(input.name);\n      }\n      // property \"children\": (Array<IMember> & Sequence<30>);\n      if (0 !== input.children.length) {\n        for (const elem of input.children) {\n          writer.uint32(242);\n          writer.fork();\n          _peo0(elem);\n          writer.ldelim();\n        }\n      }\n      // property \"keywords\": (Map<string, string> & Sequence<40>);\n      for (const [key, value] of input.keywords) {\n        writer.uint32(322);\n        writer.fork();\n        writer.uint32(10);\n        writer.string(key);\n        writer.uint32(18);\n        writer.string(value);\n        writer.ldelim();\n      }\n      // property \"thumbnail\": ((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array);\n      if (input.thumbnail instanceof Uint8Array) {\n        writer.uint32(330);\n        writer.bytes(input.thumbnail);\n      } else if (\"string\" === typeof input.thumbnail) {\n        writer.uint32(338);\n        writer.string(input.thumbnail);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected:\n            '((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array)',\n          value: input.thumbnail,\n        });\n      // property \"email\": (string & Format<\"email\">);\n      writer.uint32(346);\n      writer.string(input.email);\n      // property \"hobbies\": Array<IHobby>;\n      if (0 !== input.hobbies.length) {\n        for (const elem of input.hobbies) {\n          writer.uint32(354);\n          writer.fork();\n          _peo1(elem);\n          writer.ldelim();\n        }\n      }\n    };\n    const _peo1 = (input) => {\n      // property \"id\": (string & Format<\"uuid\">);\n      writer.uint32(10);\n      writer.string(input.id);\n      // property \"name\": string;\n      writer.uint32(18);\n      writer.string(input.name);\n      // property \"valid\": boolean;\n      writer.uint32(24);\n      writer.bool(input.valid);\n    };\n    const _io0 = (input) =>\n      null !== input.id &&\n      undefined !== input.id &&\n      (\"string\" === typeof input.id ||\n        (\"number\" === typeof input.id &&\n          __typia_transform__isTypeUint64._isTypeUint64(input.id)) ||\n        input.id instanceof Uint8Array) &&\n      (null === input.name || \"string\" === typeof input.name) &&\n      Array.isArray(input.children) &&\n      input.children.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io0(elem),\n      ) &&\n      input.keywords instanceof Map &&\n      (() =>\n        [...input.keywords].every(\n          (elem) =>\n            Array.isArray(elem) &&\n            elem.length === 2 &&\n            \"string\" === typeof elem[0] &&\n            \"string\" === typeof elem[1],\n        ))() &&\n      null !== input.thumbnail &&\n      undefined !== input.thumbnail &&\n      ((\"string\" === typeof input.thumbnail &&\n        __typia_transform__isFormatUri._isFormatUri(input.thumbnail)) ||\n        input.thumbnail instanceof Uint8Array) &&\n      \"string\" === typeof input.email &&\n      __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n      Array.isArray(input.hobbies) &&\n      input.hobbies.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n      );\n    const _io1 = (input) =>\n      \"string\" === typeof input.id &&\n      __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n      \"string\" === typeof input.name &&\n      \"boolean\" === typeof input.valid;\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})();","references#References":"Protocol Buffer supports special numeric types like int32 or uint64 that are not supported in TypeScript. Also, types of Protocol Buffer cannot fully meet TypeScript type specs either, as expression power of TypeScript types are much stronger than Protocol Buffer.To know how to define special numeric types like uint64, and to understand which TypeScript types are not supported in Protocol Buffer specs, it would better to read below documents. I recommend you to read them before using typia.protobuf.encode<T>() related functions.\nTypia Guide Documents > Protocol Buffer > Message Schema\nmessage() function\nType Tags\nComment Tags\nRestrictions"}},"/docs/protobuf/message":{"title":"Guide Documents > Protobuf > Schema","data":{"message-function#message() function":"export namespace protobuf {\n  export function message<T>(): string;\n}\ntypia.protobuf.message() function returns a Protocol Buffer message (structure) as a string value.With this message() function, you can share *.proto files with other languages. If you want to customize byte order or define specific type (that is not supported in the TypeScript) like uint32, use comment tags by following comment tags section.\nimport typia, { tags } from \"typia\";\ntypia.protobuf.message<IMember>();\ninterface IMember {\n  id:\n    | (string & tags.Sequence<11>)\n    | (number & tags.Type<\"uint64\"> & tags.Sequence<12>)\n    | (Uint8Array & tags.Sequence<13>);\n  name: (string & tags.Sequence<20>) | null;\n  children: Array<IMember> & tags.Sequence<30>;\n  keywords: Map<string, string> & tags.Sequence<40>;\n  thumbnail:\n    | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">)\n    | Uint8Array;\n  email: string & tags.Format<\"email\">;\n  hobbies: Array<IHobby>;\n}\ninterface IHobby {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  valid: boolean;\n}\nimport typia from \"typia\";\n[\n  'syntax = \"proto3\";',\n  \"\",\n  \"message IMember {\",\n  \"  oneof id {\",\n  \"    bytes v13 = 13;\",\n  \"    uint64 v12 = 12;\",\n  \"    string v11 = 11;\",\n  \"  }\",\n  \"  optional string name = 20;\",\n  \"  repeated IMember children = 30;\",\n  \"  map<string, string> keywords = 40;\",\n  \"  oneof thumbnail {\",\n  \"    bytes v41 = 41;\",\n  \"    string v42 = 42;\",\n  \"  }\",\n  \"  required string email = 43;\",\n  \"  repeated IHobby hobbies = 44;\",\n  \"}\",\n  \"\",\n  \"message IHobby {\",\n  \"  required string id = 1;\",\n  \"  required string name = 2;\",\n  \"  required bool valid = 3;\",\n  \"}\",\n].join(\"\\n\");","type-tags#Type Tags":"By using type tags, you can use special numeric types that are not supported in the TypeScript.Just import Type (or typia.tags.Type) type, and combine it with number or bigint type through intersection symbol number & typia.tagsType<\"float\"> case. If you want to declare an union numeric type, combine | and bracket (()) symbols properly like below.When you take a mistake that choosing different target type, TypeScript compiler would block it with compilation error message. Therefore, have a confidence when using the Type tag. For such type safety reason, I recommend to use Type tag instead of using comment tags as much as possible.\nnumber & (Type<\"uint32\"> | Type<\"double\">)\nnumber type can be both uint32 and double\n(number & Type<\"int32\">) | (bigint & Type<\"uint64\">)\nnumber is int32\nbigint is uint64\n(number & (Type<\"int32\">)| Type<\"float\">) | (bigint & Type<\"uint64\">)\nnumber can be both int32 and float\nbigint is uint64\nimport typia, { tags } from \"typia\";\ninterface TypeTagExample {\n  // ATOMIC TYPES\n  int32: number & tags.Type<\"int32\">;\n  uint32: number & tags.Type<\"uint32\">;\n  uint64: bigint & tags.Type<\"uint64\">;\n  int64: number & tags.Type<\"int64\">;\n  float: number & tags.Type<\"float\">;\n  double: number | undefined;\n  string: string | null;\n  // UNION TYPES\n  uint32_or_double: number & (tags.Type<\"uint32\"> | tags.Type<\"double\">);\n  int32_or_uint64:\n    | (number & tags.Type<\"int32\">)\n    | (bigint & tags.Type<\"uint64\">);\n  int32_or_float_or_uint64:\n    | (number & (tags.Type<\"int32\"> | tags.Type<\"float\">))\n    | (bigint & tags.Type<\"uint64\">);\n  // ARRAY AND MAP\n  uint64_array: Array<bigint & tags.Type<\"uint64\">>;\n  int32_map?: Map<number & tags.Type<\"int32\">, string> | null;\n}\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\ntypia.protobuf.message<TypeTagExample>();\n//----\n// DECODE FUNCTION\n//----\ntypia.protobuf.createDecode<TypeTagExample>();\n//----\n// ENCODE FUNCTION\n//----\ntypia.protobuf.createEncode<TypeTagExample>();\nimport * as __typia_transform__ProtobufReader from \"typia/lib/internal/_ProtobufReader.js\";\nimport * as __typia_transform__throwTypeGuardError from \"typia/lib/internal/_throwTypeGuardError.js\";\nimport * as __typia_transform__isTypeInt32 from \"typia/lib/internal/_isTypeInt32.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__isTypeInt64 from \"typia/lib/internal/_isTypeInt64.js\";\nimport * as __typia_transform__isTypeFloat from \"typia/lib/internal/_isTypeFloat.js\";\nimport * as __typia_transform__ProtobufSizer from \"typia/lib/internal/_ProtobufSizer.js\";\nimport * as __typia_transform__ProtobufWriter from \"typia/lib/internal/_ProtobufWriter.js\";\nimport typia from \"typia\";\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\n[\n  'syntax = \"proto3\";',\n  \"\",\n  \"message TypeTagExample {\",\n  \"  required int32 int32 = 1;\",\n  \"  required uint32 uint32 = 2;\",\n  \"  required uint64 uint64 = 3;\",\n  \"  required int64 int64 = 4;\",\n  \"  required float float = 5;\",\n  \"  optional double double = 6;\",\n  \"  optional string string = 7;\",\n  \"  oneof uint32_or_double {\",\n  \"    uint32 v8 = 8;\",\n  \"    double v9 = 9;\",\n  \"  }\",\n  \"  oneof int32_or_uint64 {\",\n  \"    int32 v10 = 10;\",\n  \"    uint64 v11 = 11;\",\n  \"  }\",\n  \"  oneof int32_or_float_or_uint64 {\",\n  \"    int32 v12 = 12;\",\n  \"    uint64 v13 = 13;\",\n  \"    float v14 = 14;\",\n  \"  }\",\n  \"  repeated uint64 uint64_array = 15;\",\n  \"  map<int32, string> int32_map = 16;\",\n  \"}\",\n].join(\"\\n\");\n//----\n// DECODE FUNCTION\n//----\n(() => {\n  const _pdo0 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      int32: undefined,\n      uint32: undefined,\n      uint64: undefined,\n      int64: undefined,\n      float: undefined,\n      double: undefined,\n      string: null,\n      uint32_or_double: undefined,\n      int32_or_uint64: undefined,\n      int32_or_float_or_uint64: undefined,\n      uint64_array: [],\n      int32_map: null,\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          // int32;\n          output.int32 = reader.int32();\n          break;\n        case 2:\n          // uint32;\n          output.uint32 = reader.uint32();\n          break;\n        case 3:\n          // uint64;\n          output.uint64 = reader.uint64();\n          break;\n        case 4:\n          // int64;\n          output.int64 = Number(reader.int64());\n          break;\n        case 5:\n          // float;\n          output.float = reader.float();\n          break;\n        case 6:\n          // double;\n          output.double = reader.double();\n          break;\n        case 7:\n          // string;\n          output.string = reader.string();\n          break;\n        case 8:\n          // uint32;\n          output.uint32_or_double = reader.uint32();\n          break;\n        case 9:\n          // double;\n          output.uint32_or_double = reader.double();\n          break;\n        case 10:\n          // int32;\n          output.int32_or_uint64 = reader.int32();\n          break;\n        case 11:\n          // uint64;\n          output.int32_or_uint64 = reader.uint64();\n          break;\n        case 12:\n          // int32;\n          output.int32_or_float_or_uint64 = reader.int32();\n          break;\n        case 13:\n          // uint64;\n          output.int32_or_float_or_uint64 = reader.uint64();\n          break;\n        case 14:\n          // float;\n          output.int32_or_float_or_uint64 = reader.float();\n          break;\n        case 15:\n          // Array<(bigint & Type<\"uint64\">)>;\n          if (2 === (tag & 7)) {\n            const piece = reader.uint32() + reader.index();\n            while (reader.index() < piece)\n              output.uint64_array.push(reader.uint64());\n          } else output.uint64_array.push(reader.uint64());\n          break;\n        case 16:\n          // Map<(number & Type<\"int32\">), string>;\n          (() => {\n            const piece = reader.uint32() + reader.index();\n            const entry = {\n              key: undefined,\n              value: \"\",\n            };\n            while (reader.index() < piece) {\n              const kind = reader.uint32();\n              switch (kind >>> 3) {\n                case 1:\n                  // int32;\n                  entry.key = reader.int32();\n                  break;\n                case 2:\n                  // string;\n                  entry.value = reader.string();\n                  break;\n                default:\n                  reader.skipType(kind & 7);\n                  break;\n              }\n            }\n            output.int32_map ??= new Map();\n            output.int32_map.set(entry.key, entry.value);\n          })();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  return (input) => {\n    const reader = new __typia_transform__ProtobufReader._ProtobufReader(input);\n    return _pdo0(reader);\n  };\n})();\n//----\n// ENCODE FUNCTION\n//----\n(() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"int32\": (number & Type<\"int32\">);\n      writer.uint32(8);\n      writer.int32(input.int32);\n      // property \"uint32\": (number & Type<\"uint32\">);\n      writer.uint32(16);\n      writer.uint32(input.uint32);\n      // property \"uint64\": (bigint & Type<\"uint64\">);\n      writer.uint32(24);\n      writer.uint64(input.uint64);\n      // property \"int64\": (number & Type<\"int64\">);\n      writer.uint32(32);\n      writer.int64(input.int64);\n      // property \"float\": (number & Type<\"float\">);\n      writer.uint32(45);\n      writer.float(input.float);\n      // property \"double\": (number | undefined);\n      if (undefined !== input.double) {\n        writer.uint32(49);\n        writer.double(input.double);\n      }\n      // property \"string\": (null | string);\n      if (null !== input.string) {\n        writer.uint32(58);\n        writer.string(input.string);\n      }\n      // property \"uint32_or_double\": (number & (Type<\"uint32\"> | Type<\"double\">));\n      if (\n        \"number\" === typeof input.uint32_or_double &&\n        Math.floor(input.uint32_or_double) === input.uint32_or_double &&\n        0 <= input.uint32_or_double &&\n        input.uint32_or_double <= 4294967295\n      ) {\n        writer.uint32(64);\n        writer.uint32(input.uint32_or_double);\n      } else if (\"number\" === typeof input.uint32_or_double && true) {\n        writer.uint32(73);\n        writer.double(input.uint32_or_double);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected: '(number & (Type<\"uint32\"> | Type<\"double\">))',\n          value: input.uint32_or_double,\n        });\n      // property \"int32_or_uint64\": ((bigint & Type<\"uint64\">) | (number & Type<\"int32\">));\n      if (\"number\" === typeof input.int32_or_uint64) {\n        writer.uint32(80);\n        writer.int32(input.int32_or_uint64);\n      } else if (\"bigint\" === typeof input.int32_or_uint64) {\n        writer.uint32(88);\n        writer.uint64(input.int32_or_uint64);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected: '((bigint & Type<\"uint64\">) | (number & Type<\"int32\">))',\n          value: input.int32_or_uint64,\n        });\n      // property \"int32_or_float_or_uint64\": ((bigint & Type<\"uint64\">) | (number & (Type<\"int32\"> | Type<\"float\">)));\n      if (\n        \"number\" === typeof input.int32_or_float_or_uint64 &&\n        Math.floor(input.int32_or_float_or_uint64) ===\n          input.int32_or_float_or_uint64 &&\n        -2147483648 <= input.int32_or_float_or_uint64 &&\n        input.int32_or_float_or_uint64 <= 2147483647\n      ) {\n        writer.uint32(96);\n        writer.int32(input.int32_or_float_or_uint64);\n      } else if (\"bigint\" === typeof input.int32_or_float_or_uint64) {\n        writer.uint32(104);\n        writer.uint64(input.int32_or_float_or_uint64);\n      } else if (\n        \"number\" === typeof input.int32_or_float_or_uint64 &&\n        -1.175494351e38 <= input.int32_or_float_or_uint64 &&\n        input.int32_or_float_or_uint64 <= 3.4028235e38\n      ) {\n        writer.uint32(117);\n        writer.float(input.int32_or_float_or_uint64);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected:\n            '((bigint & Type<\"uint64\">) | (number & (Type<\"int32\"> | Type<\"float\">)))',\n          value: input.int32_or_float_or_uint64,\n        });\n      // property \"uint64_array\": Array<bigint & Type<\"uint64\">>;\n      if (0 !== input.uint64_array.length) {\n        writer.uint32(122);\n        writer.fork();\n        for (const elem of input.uint64_array) {\n          writer.uint64(elem);\n        }\n        writer.ldelim();\n      }\n      // property \"int32_map\": (Map<(number & Type<\"int32\">), string> | null | undefined);\n      if (undefined !== input.int32_map && null !== input.int32_map) {\n        for (const [key, value] of input.int32_map) {\n          writer.uint32(130);\n          writer.fork();\n          writer.uint32(8);\n          writer.int32(key);\n          writer.uint32(18);\n          writer.string(value);\n          writer.ldelim();\n        }\n      }\n    };\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})();\nBy the way, how to specify the byte order of each properties?Even though typia automatically assigns byte order to each properties, but in sometimes, you may hope to determine the byte orders by yourself.In that case, you can specify the byte order of each properties by utilizing the tags.Sequence<N> type like below. If you have to define some union typed properties, combine the tags.Sequence<N> type with intersection symbol & to the target type.\nimport typia, { tags } from \"typia\";\ninterface TypeTagExample {\n  // ATOMIC TYPES\n  int32: number & tags.Type<\"int32\"> & tags.Sequence<10>;\n  uint32: number & tags.Type<\"uint32\"> & tags.Sequence<20>;\n  uint64: bigint & tags.Type<\"uint64\"> & tags.Sequence<30>;\n  int64: number & tags.Type<\"int64\"> & tags.Sequence<40>;\n  float: number & tags.Type<\"float\"> & tags.Sequence<50>;\n  double: (number & tags.Sequence<60>) | undefined;\n  string: (string & tags.Sequence<70>) | null;\n  // UNION TYPES\n  uint32_or_double: number &\n    (\n      | (tags.Type<\"uint32\"> & tags.Sequence<61>)\n      | (tags.Type<\"double\"> & tags.Sequence<62>)\n    );\n  int32_or_uint64:\n    | (number & tags.Type<\"int32\"> & tags.Sequence<71>)\n    | (bigint & tags.Type<\"uint64\"> & tags.Sequence<72>);\n  int32_or_float_or_uint64:\n    | (number &\n        (\n          | (tags.Type<\"int32\"> & tags.Sequence<81>)\n          | (tags.Type<\"float\"> & tags.Sequence<82>)\n        ))\n    | (bigint & tags.Type<\"uint64\"> & tags.Sequence<83>);\n  // ARRAY AND MAP\n  uint64_array: Array<bigint & tags.Type<\"uint64\">> & tags.Sequence<90>;\n  int32_map?:\n    | (Map<number & tags.Type<\"int32\">, string> & tags.Sequence<100>)\n    | null;\n}\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\ntypia.protobuf.message<TypeTagExample>();\n//----\n// DECODE FUNCTION\n//----\ntypia.protobuf.createDecode<TypeTagExample>();\n//----\n// ENCODE FUNCTION\n//----\ntypia.protobuf.createEncode<TypeTagExample>();\nimport * as __typia_transform__ProtobufReader from \"typia/lib/internal/_ProtobufReader.js\";\nimport * as __typia_transform__throwTypeGuardError from \"typia/lib/internal/_throwTypeGuardError.js\";\nimport * as __typia_transform__isTypeInt32 from \"typia/lib/internal/_isTypeInt32.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__isTypeInt64 from \"typia/lib/internal/_isTypeInt64.js\";\nimport * as __typia_transform__isTypeFloat from \"typia/lib/internal/_isTypeFloat.js\";\nimport * as __typia_transform__ProtobufSizer from \"typia/lib/internal/_ProtobufSizer.js\";\nimport * as __typia_transform__ProtobufWriter from \"typia/lib/internal/_ProtobufWriter.js\";\nimport typia from \"typia\";\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\n[\n  'syntax = \"proto3\";',\n  \"\",\n  \"message TypeTagExample {\",\n  \"  required int32 int32 = 10;\",\n  \"  required uint32 uint32 = 20;\",\n  \"  required uint64 uint64 = 30;\",\n  \"  required int64 int64 = 40;\",\n  \"  required float float = 50;\",\n  \"  optional double double = 60;\",\n  \"  optional string string = 70;\",\n  \"  oneof uint32_or_double {\",\n  \"    uint32 v61 = 61;\",\n  \"    double v62 = 62;\",\n  \"  }\",\n  \"  oneof int32_or_uint64 {\",\n  \"    int32 v71 = 71;\",\n  \"    uint64 v72 = 72;\",\n  \"  }\",\n  \"  oneof int32_or_float_or_uint64 {\",\n  \"    int32 v81 = 81;\",\n  \"    uint64 v83 = 83;\",\n  \"    float v82 = 82;\",\n  \"  }\",\n  \"  repeated uint64 uint64_array = 90;\",\n  \"  map<int32, string> int32_map = 100;\",\n  \"}\",\n].join(\"\\n\");\n//----\n// DECODE FUNCTION\n//----\n(() => {\n  const _pdo0 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      int32: undefined,\n      uint32: undefined,\n      uint64: undefined,\n      int64: undefined,\n      float: undefined,\n      double: undefined,\n      string: null,\n      uint32_or_double: undefined,\n      int32_or_uint64: undefined,\n      int32_or_float_or_uint64: undefined,\n      uint64_array: [],\n      int32_map: null,\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 10:\n          // int32;\n          output.int32 = reader.int32();\n          break;\n        case 20:\n          // uint32;\n          output.uint32 = reader.uint32();\n          break;\n        case 30:\n          // uint64;\n          output.uint64 = reader.uint64();\n          break;\n        case 40:\n          // int64;\n          output.int64 = Number(reader.int64());\n          break;\n        case 50:\n          // float;\n          output.float = reader.float();\n          break;\n        case 60:\n          // double;\n          output.double = reader.double();\n          break;\n        case 70:\n          // string;\n          output.string = reader.string();\n          break;\n        case 61:\n          // uint32;\n          output.uint32_or_double = reader.uint32();\n          break;\n        case 62:\n          // double;\n          output.uint32_or_double = reader.double();\n          break;\n        case 71:\n          // int32;\n          output.int32_or_uint64 = reader.int32();\n          break;\n        case 72:\n          // uint64;\n          output.int32_or_uint64 = reader.uint64();\n          break;\n        case 81:\n          // int32;\n          output.int32_or_float_or_uint64 = reader.int32();\n          break;\n        case 83:\n          // uint64;\n          output.int32_or_float_or_uint64 = reader.uint64();\n          break;\n        case 82:\n          // float;\n          output.int32_or_float_or_uint64 = reader.float();\n          break;\n        case 90:\n          // Array<(bigint & Type<\"uint64\">)>;\n          if (2 === (tag & 7)) {\n            const piece = reader.uint32() + reader.index();\n            while (reader.index() < piece)\n              output.uint64_array.push(reader.uint64());\n          } else output.uint64_array.push(reader.uint64());\n          break;\n        case 100:\n          // Map<(number & Type<\"int32\">), string>;\n          (() => {\n            const piece = reader.uint32() + reader.index();\n            const entry = {\n              key: undefined,\n              value: \"\",\n            };\n            while (reader.index() < piece) {\n              const kind = reader.uint32();\n              switch (kind >>> 3) {\n                case 1:\n                  // int32;\n                  entry.key = reader.int32();\n                  break;\n                case 2:\n                  // string;\n                  entry.value = reader.string();\n                  break;\n                default:\n                  reader.skipType(kind & 7);\n                  break;\n              }\n            }\n            output.int32_map ??= new Map();\n            output.int32_map.set(entry.key, entry.value);\n          })();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  return (input) => {\n    const reader = new __typia_transform__ProtobufReader._ProtobufReader(input);\n    return _pdo0(reader);\n  };\n})();\n//----\n// ENCODE FUNCTION\n//----\n(() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"int32\": (number & Type<\"int32\"> & Sequence<10>);\n      writer.uint32(80);\n      writer.int32(input.int32);\n      // property \"uint32\": (number & Type<\"uint32\"> & Sequence<20>);\n      writer.uint32(160);\n      writer.uint32(input.uint32);\n      // property \"uint64\": (bigint & Type<\"uint64\"> & Sequence<30>);\n      writer.uint32(240);\n      writer.uint64(input.uint64);\n      // property \"int64\": (number & Type<\"int64\"> & Sequence<40>);\n      writer.uint32(320);\n      writer.int64(input.int64);\n      // property \"float\": (number & Type<\"float\"> & Sequence<50>);\n      writer.uint32(405);\n      writer.float(input.float);\n      // property \"double\": ((number & Sequence<60>) | undefined);\n      if (undefined !== input.double) {\n        writer.uint32(481);\n        writer.double(input.double);\n      }\n      // property \"string\": ((string & Sequence<70>) | null);\n      if (null !== input.string) {\n        writer.uint32(562);\n        writer.string(input.string);\n      }\n      // property \"uint32_or_double\": (number & ((Type<\"uint32\"> & Sequence<61>) | (Type<\"double\"> & Sequence<62>)));\n      if (\n        \"number\" === typeof input.uint32_or_double &&\n        Math.floor(input.uint32_or_double) === input.uint32_or_double &&\n        0 <= input.uint32_or_double &&\n        input.uint32_or_double <= 4294967295\n      ) {\n        writer.uint32(488);\n        writer.uint32(input.uint32_or_double);\n      } else if (\"number\" === typeof input.uint32_or_double && true) {\n        writer.uint32(497);\n        writer.double(input.uint32_or_double);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected:\n            '(number & ((Type<\"uint32\"> & Sequence<61>) | (Type<\"double\"> & Sequence<62>)))',\n          value: input.uint32_or_double,\n        });\n      // property \"int32_or_uint64\": ((bigint & Type<\"uint64\"> & Sequence<72>) | (number & Type<\"int32\"> & Sequence<71>));\n      if (\"number\" === typeof input.int32_or_uint64) {\n        writer.uint32(568);\n        writer.int32(input.int32_or_uint64);\n      } else if (\"bigint\" === typeof input.int32_or_uint64) {\n        writer.uint32(576);\n        writer.uint64(input.int32_or_uint64);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected:\n            '((bigint & Type<\"uint64\"> & Sequence<72>) | (number & Type<\"int32\"> & Sequence<71>))',\n          value: input.int32_or_uint64,\n        });\n      // property \"int32_or_float_or_uint64\": ((bigint & Type<\"uint64\"> & Sequence<83>) | (number & ((Type<\"int32\"> & Sequence<81>) | (Type<\"float\"> & Sequence<82>))));\n      if (\n        \"number\" === typeof input.int32_or_float_or_uint64 &&\n        Math.floor(input.int32_or_float_or_uint64) ===\n          input.int32_or_float_or_uint64 &&\n        -2147483648 <= input.int32_or_float_or_uint64 &&\n        input.int32_or_float_or_uint64 <= 2147483647\n      ) {\n        writer.uint32(648);\n        writer.int32(input.int32_or_float_or_uint64);\n      } else if (\"bigint\" === typeof input.int32_or_float_or_uint64) {\n        writer.uint32(664);\n        writer.uint64(input.int32_or_float_or_uint64);\n      } else if (\n        \"number\" === typeof input.int32_or_float_or_uint64 &&\n        -1.175494351e38 <= input.int32_or_float_or_uint64 &&\n        input.int32_or_float_or_uint64 <= 3.4028235e38\n      ) {\n        writer.uint32(661);\n        writer.float(input.int32_or_float_or_uint64);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected:\n            '((bigint & Type<\"uint64\"> & Sequence<83>) | (number & ((Type<\"int32\"> & Sequence<81>) | (Type<\"float\"> & Sequence<82>))))',\n          value: input.int32_or_float_or_uint64,\n        });\n      // property \"uint64_array\": (Array<bigint & Type<\"uint64\">> & Sequence<90>);\n      if (0 !== input.uint64_array.length) {\n        writer.uint32(722);\n        writer.fork();\n        for (const elem of input.uint64_array) {\n          writer.uint64(elem);\n        }\n        writer.ldelim();\n      }\n      // property \"int32_map\": ((Map<(number & Type<\"int32\">), string> & Sequence<100>) | null | undefined);\n      if (undefined !== input.int32_map && null !== input.int32_map) {\n        for (const [key, value] of input.int32_map) {\n          writer.uint32(802);\n          writer.fork();\n          writer.uint32(8);\n          writer.int32(key);\n          writer.uint32(18);\n          writer.string(value);\n          writer.ldelim();\n        }\n      }\n    };\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})();","comment-tags#Comment Tags":"By using @type {target} comment tag, you also can use special numeric types.However, this way is not recommended, because it can't perform union numeric types, and cannot be used in Array and Map types. When you declare @type int32 statement, target number type be fixed as int32 type, and never can have another numeric type by declaring union statements.Also, those comment tags are not type safe. If you take a mistake when writing a comment tag, it will not be detected by the compiler, and will cause an error at runtime. For example, if you write a miss-spelled keyword like @type unit32, the target number type would be double type, and you can identify it just by running the program (or visiting playground website).\nWhy supports comment tags?\nDespite these disadvantages, the reason for maintaining comment tags is as follows.First, it is to support the legacy JSDoc style that had been used in the JS camp for a long time. If you had developed a legacy project and JSDoc being used, you can use it as is.Second, to support Prisma. If a comment is created in the Prisma Schema through the /// statement as shown below and a type is created, it is converted to a TS comment as it is. And since there is no way that union types, numeric Arrays or Maps are used in Prisma (database) schema, these comment tags are surprisingly compatible with Prisma.\nimport typia from \"typia\";\nexport interface CommentTagExample {\n  /**\n   * @type int32\n   */\n  int32: number;\n  /**\n   * @type uint32\n   */\n  uint32?: number | null;\n  /**\n   * @type uint64\n   */\n  uint64?: number;\n  /**\n   * @type int64\n   */\n  int64: number;\n  /**\n   * @type float\n   */\n  float: number | null;\n  double: number;\n  string: string;\n}\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\ntypia.protobuf.message<CommentTagExample>();\n//----\n// DECODE FUNCTION\n//----\ntypia.protobuf.createDecode<CommentTagExample>();\n//----\n// ENCODE FUNCTION\n//----\ntypia.protobuf.createEncode<CommentTagExample>();\nsyntax = \"proto3\";\nmessage CommentTagExample {\n  required int32 int32 = 1;\n  optional uint32 uint32 = 2;\n  optional uint64 uint64 = 3;\n  required int64 int64 = 4;\n  optional float float = 5;\n  required double double = 6;\n  required string string = 7;\n}\nimport * as __typia_transform__ProtobufReader from \"typia/lib/internal/_ProtobufReader.js\";\nimport * as __typia_transform__ProtobufSizer from \"typia/lib/internal/_ProtobufSizer.js\";\nimport * as __typia_transform__ProtobufWriter from \"typia/lib/internal/_ProtobufWriter.js\";\nimport typia from \"typia\";\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\n[\n  'syntax = \"proto3\";',\n  \"\",\n  \"message CommentTagExample {\",\n  \"  required int32 int32 = 1;\",\n  \"  optional uint32 uint32 = 2;\",\n  \"  optional uint64 uint64 = 3;\",\n  \"  required int64 int64 = 4;\",\n  \"  optional float float = 5;\",\n  \"  required double double = 6;\",\n  \"  required string string = 7;\",\n  \"}\",\n].join(\"\\n\");\n//----\n// DECODE FUNCTION\n//----\n(() => {\n  const _pdo0 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      int32: undefined,\n      uint32: null,\n      uint64: undefined,\n      int64: undefined,\n      float: null,\n      double: undefined,\n      string: \"\",\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          // int32;\n          output.int32 = reader.int32();\n          break;\n        case 2:\n          // uint32;\n          output.uint32 = reader.uint32();\n          break;\n        case 3:\n          // uint64;\n          output.uint64 = Number(reader.uint64());\n          break;\n        case 4:\n          // int64;\n          output.int64 = Number(reader.int64());\n          break;\n        case 5:\n          // float;\n          output.float = reader.float();\n          break;\n        case 6:\n          // double;\n          output.double = reader.double();\n          break;\n        case 7:\n          // string;\n          output.string = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  return (input) => {\n    const reader = new __typia_transform__ProtobufReader._ProtobufReader(input);\n    return _pdo0(reader);\n  };\n})();\n//----\n// ENCODE FUNCTION\n//----\n(() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"int32\": (number & Type<\"int32\">);\n      writer.uint32(8);\n      writer.int32(input.int32);\n      // property \"uint32\": ((number & Type<\"uint32\">) | null | undefined);\n      if (undefined !== input.uint32 && null !== input.uint32) {\n        writer.uint32(16);\n        writer.uint32(input.uint32);\n      }\n      // property \"uint64\": ((number & Type<\"uint64\">) | undefined);\n      if (undefined !== input.uint64) {\n        writer.uint32(24);\n        writer.uint64(input.uint64);\n      }\n      // property \"int64\": (number & Type<\"int64\">);\n      writer.uint32(32);\n      writer.int64(input.int64);\n      // property \"float\": ((number & Type<\"float\">) | null);\n      if (null !== input.float) {\n        writer.uint32(45);\n        writer.float(input.float);\n      }\n      // property \"double\": number;\n      writer.uint32(49);\n      writer.double(input.double);\n      // property \"string\": string;\n      writer.uint32(58);\n      writer.string(input.string);\n    };\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})();","restrictions#Restrictions":"You know what? Expression power of Protocol Buffer is extremely narrower than type system of TypeScript. For example, Protocol Buffer can't express complicate union type containing array. Also, Protocol Buffer can't express multi dimensional array type, either.In such reason, when converting TypeScript type to Protocol buffer message schema, lots of restrictions are exist. Let's study which types of TypeScript are not supported in Protocol Buffer. For reference, if you try to call typia.protobuf.message<T>() function with unsupported type, typia will generate compile errors like below example cases.At first, top level type must be a sole and static object.If you try to use number or Array<T> type as a top level type, typia will generate compile error like below. Dynamic object types like Record<string, T>, or Map<string, T> types are not allowed either. For reference, the sole object means that, union of object types is not allowed, either.\nimport typia from \"typia\";\ninterface Cat {\n    type: \"cat\";\n    name: string;\n    ribbon: boolean;\n}\ninterface Dog {\n    type: \"dog\";\n    name: string;\n    hunt: boolean;\n}\ntypia.protobuf.message<bigint>();\ntypia.protobuf.createDecode<Record<string, number>>();\ntypia.protobuf.createDecode<Map<number & typia.tags.Type<\"float\">, Dog>>();\ntypia.protobuf.createEncode<boolean[]>();\ntypia.protobuf.createEncode<Cat | Dog>();\nmain.ts:14:1 - error TS(typia.protobuf.message): unsupported type detected\n- bigint\n  - target type must be a sole and static object type\nmain.ts:15:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n- Record<string, number>\n  - target type must be a sole and static object type\nmain.ts:16:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n- Map<(number & Type<\"float\">), Dog>\n  - target type must be a sole and static object type\n- (number & Type<\"float\">)\n  - target type must be a sole and static object type\nmain.ts:17:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n- Array<boolean>\n  - target type must be a sole and static object type\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n- (Cat | Dog)\n  - target type must be a sole and static object type\nAt next, in Protocol Buffer, those types are categorized as container types.\nArray<T>\nMap<Key, T>\nRecord<string, T> (dynamic object)\nAlso, those container types does not allow over two-dimensional stacking. Therefore, it is not possible to declaring two dimensional array like number[][], or Array type in Map like Map<string, number[]>. Besides, value type of those container also do not support union type either.Additionally, about Map<Key, T> type, key type must be an atomic type. It means that, only boolean, number, bigint and string types are allowed. Also, key type cannot be union type, either.\nimport typia from \"typia\";\ninterface IPointer<T> {\n  value: T;\n}\ninterface Cat {\n  type: \"cat\";\n  name: string;\n  ribbon: boolean;\n}\ninterface Dog {\n  type: \"dog\";\n  name: string;\n  hunt: boolean;\n}\ntypia.protobuf.message<IPointer<number[][]>>();\ntypia.protobuf.createEncode<IPointer<Record<string, string[]>>>();\ntypia.protobuf.createDecode<IPointer<Map<string, Cat | Dog>>>();\ntypia.protobuf.message<IPointer<Map<Cat, string>>>();\ntypia.protobuf.message<IPointer<Map<number | string, Dog>>>();\nmain.ts:17:1 - error TS(typia.protobuf.message): unsupported type detected\n- IPointer<Array<Array<number>>>[key]: Array<Array<number>>\n  - does not support over two dimensional array type\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n- IPointer<Record<string, Array<string>>>[key]: Record<string, Array<string>>\n  - does not support dynamic object with array value type\nmain.ts:19:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n- IPointer<Map<string, Cat | Dog>>[key]: Map<string, (Cat | Dog)>\n  - does not support union type in map value type\nmain.ts:21:1 - error TS(typia.protobuf.message): unsupported type detected\n- IPointer<Map<Cat, string>>[key]: Map<Cat, string>\n  - does not support non-atomic key typed map\nmain.ts:22:1 - error TS(typia.protobuf.message): unsupported type detected\n- IPointer<Map<string | number, Dog>>[key]: Map<(number | string), Dog>\n  - does not support union key typed map\n  - does not support non-atomic key typed map\nAt last, those types are all not allowed.\nany\nfunctional type\nSet<T>, WeakSet<T> and WeakMap<T>\nDate, Boolean, BigInt, Number, String\nBinary classes except Uint8Array\nUint8ClampedArray, Uint16Array, Uint32Array, BigUint64Array\nInt8Array, Int16Array, Int32Array, BigInt64Array\nArrayBuffer, SharedArrayBuffer and DataView\nimport typia from \"typia\";\ninterface Something {\n  any: any;\n  unknown: unknown;\n  closure: () => void;\n  dict: Set<string> | WeakSet<Something> | WeakMap<Something, string>;\n  date: Date;\n  classic: String;\n  buffer: ArrayBuffer;\n}\ntypia.protobuf.message<Something>();\nmain.ts:13:1 - error TS(typia.protobuf.message): unsupported type detected\n- Something.any: any\n  - does not support any type\n- Something.unknown: any\n  - does not support any type\n- Something.closure: unknown\n  - does not support functional type\n- Something.dict: (Set<string> | WeakMap | WeakSet)\n  - does not support Set type\n  - does not support WeakSet type. Use Array type instead.\n  - does not support WeakMap type. Use Map type instead.\n- Something.date: Date\n  - does not support Date type. Use string type instead.\n- Something.classic: String\n  - does not support String type. Use string type instead.\n- Something.buffer: ArrayBuffer\n  - does not support ArrayBuffer type. Use Uint8Array type instead."}},"/docs/pure":{"title":"Guide Documents > Pure TypeScript Type","data":{"outline#Outline":"typia.assert<IBbsArticle>(article);\ntypia needs only one line with pure TypeScript type.You know what? Every other validator libraries need extra schema definition, that is different with pure TypeScript type. For an example, class-validator is the most famous validator due to used in NestJS. However, NestJS and class-validator force you to define triple duplicated DTO schema.\nTypeScript Type\nclass-validator decorators\n@nestjs/swagger decorators\nAnother famous validator library ajv requires JSON schema definition. Move to the #Demonstration, and click the ajv (JSON Schema) tab, then you may understand how it terrible. It requires hundreds of lines of JSON schema definition even just for a simple DTO.Those duplicated schema definitions are not only annoying, but also error-prone. If you take any mistake on the extra schema definition, such mistake can't be detected by TypeScript compiler. It will be detected only at runtime, therefore become a critical runtime error. Another words, it is not type safe.Besides, typia only needs pure TypeScript type. You don't need to define any extra schema like class-validator or ajv. Just define pure TypeScript type only (especially recommend to use interface type), then typia will do all the rest.","demonstration#Demonstration":"If you're confusing how typia is different with others, just see example codes below.At first, look at the first (class-validator) tab, and find the BbsArticle.files property, enhanced by blue colored blocks. Looking at the files property, how do you feel? Just defining an array object type, you've to call 7 decorator functions. If you take any mistake when using the decorator like omitting isArray property, it would be a critical runtime error.Besides, typia needs only one line. Click the third (typia) tab, and find the IAttachmentFile.files property. Only one line being used, and they are even not class, but just interface types. Comparing it to the first and second tabs, how do you feel? Isn't it more simple and readable?This is the power of typia, with pure TypeScript type.\nimport { ApiProperty } from \"@nestjs/swagger\";\nimport {\n  ArrayNotEmpty,\n  IsArray,\n  IsObject,\n  IsOptional,\n  IsString,\n  Match,\n  MaxLength,\n  Type,\n  ValidateNested,\n} from \"class-validator\";\nexport class BbsArticle {\n  @ApiProperty({\n    format: \"uuid\",\n  })\n  @IsString()\n  id!: string;\n  // DUPLICATED SCHEMA DEFINITION\n  // - duplicated function call + property type\n  // - have to specify `isArray` and `nullable` props by yourself\n  @ApiProperty({\n    type: () => AttachmentFile,\n    nullable: true,\n    isArray: true,\n    description: \"List of attached files.\",\n  })\n  @Type(() => AttachmentFile)\n  @IsArray()\n  @IsOptional()\n  @IsObject({ each: true })\n  @ValidateNested({ each: true })\n  files!: AttachmentFile[] | null;\n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    minLength: 5,\n    maxLength: 100,\n    description: \"Title of the article.\",\n  })\n  @IsOptional()\n  @IsString()\n  title!: string | null;\n  @ApiProperty({\n    description: \"Main content body of the article.\",\n  })\n  @IsString()\n  body!: string;\n  @ApiProperty({\n    format: \"date-time\",\n    description: \"Creation time of article\",\n  })\n  @IsString()\n  created_at!: string;\n}\nexport class AttachmentFile {\n  @ApiProperty({\n    type: \"string\",\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File name.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(255)\n  @IsString()\n  name!: string | null;\n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File extension.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(8)\n  @IsOptional()\n  @IsString()\n  extension!: string | null;\n  @ApiProperty({\n    format: \"url\",\n    description: \"URL of the file.\",\n  })\n  @IsString()\n  url!: string;\n}\n{\n  \"schemas\": [\n    {\n      \"$ref\": \"#/components/schemas/IBbsArticle\"\n    }\n  ],\n  \"components\": {\n    \"schemas\": {\n      \"IBbsArticle\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            },\n            \"nullable\": true,\n            \"title\": \"List of attached files\",\n            \"description\": \"List of attached files.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"maxLength\": 100,\n            \"minLength\": 5,\n            \"nullable\": true,\n            \"title\": \"Title of the article\",\n            \"description\": \"Title of the article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Main content body of the article\",\n            \"description\": \"Main content body of the article.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of article\",\n            \"description\": \"Creation time of article.\"\n          }\n        },\n        \"nullable\": false,\n        \"required\": [\n          \"id\",\n          \"files\",\n          \"title\",\n          \"body\",\n          \"created_at\"\n        ]\n      },\n      \"IAttachmentFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"maxLength\": 255,\n            \"pattern\": \"^[a-z0-9]+$\",\n            \"title\": \"File name\",\n            \"description\": \"File name.\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"maxLength\": 8,\n            \"pattern\": \"^[a-z0-9]+$\",\n            \"nullable\": true,\n            \"title\": \"File extension\",\n            \"description\": \"File extension.\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"title\": \"URL of the file\",\n            \"description\": \"URL of the file.\"\n          }\n        },\n        \"nullable\": false,\n        \"required\": [\n          \"name\",\n          \"extension\",\n          \"url\"\n        ]\n      }\n    }\n  },\n  \"purpose\": \"swagger\",\n  \"surplus\": false\n}\nimport typia, { tags } from \"typia\";\nexport interface IBbsArticle {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n  /**\n   * List of attached files.\n   */\n  files: null | IAttachmentFile[];\n  /**\n   * Title of the article.\n   */\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\n  /**\n   * Main content body of the article.\n   */\n  body: string;\n  /**\n   * Creation time of article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n}\nexport interface IAttachmentFile {\n  /**\n   * File name.\n   */\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\n  /**\n   * File extension.\n   */\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\n  /**\n   * URL of the file.\n   */\n  url: string;\n}","aot-compilation#AOT Compilation":"Someone may be suspicious of the phrase \"Pure TypeScript Type\".\n\"As you know, TypeScript types do not have any tangible instance when compiled to JS.However, with only these fictitious TypeScript types, how can typia validates types at runtime? How typia builds much faster JSON serializer only with these types? Are these things really possible without extra schema definition like class-validator or ajv?\"\nMy answer is: \"Yes, it is possible due to typia analyzes your server code, and performs AOT compilation\".Such compile time optimization is called AOT (Ahead of Time) compilation. And this is the secret why typia can do everything with only pure TypeScript type. Read below example codes, and just look how JavaScript file being compiled. Then you may understand why typia is much easier, and furthermore much faster.\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\nimport typia, { tags } from \"typia\";\nexport interface IBbsArticle {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n  /**\n   * List of attached files.\n   */\n  files: null | IAttachmentFile[];\n  /**\n   * Title of the article.\n   */\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\n  /**\n   * Main content body of the article.\n   */\n  body: string;\n  /**\n   * Creation time of article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n}\nexport interface IAttachmentFile {\n  /**\n   * File name.\n   */\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\n  /**\n   * File extension.\n   */\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\n  /**\n   * URL of the file.\n   */\n  url: string;\n}\nimport typia from \"typia\";\nimport { IBbsArticle } from \"./IBbsArticle\";\nexport const assertArticle = typia.createAssert<IBbsArticle>();\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatDateTime from \"typia/lib/internal/_isFormatDateTime.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nexport const assertArticle = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    (null === input.files ||\n      (Array.isArray(input.files) &&\n        input.files.every(\n          (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n        ))) &&\n    (null === input.title ||\n      (\"string\" === typeof input.title &&\n        5 <= input.title.length &&\n        input.title.length <= 100)) &&\n    \"string\" === typeof input.body &&\n    \"string\" === typeof input.created_at &&\n    __typia_transform__isFormatDateTime._isFormatDateTime(input.created_at);\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    RegExp(\"^[a-z0-9]+$\").test(input.name) &&\n    input.name.length <= 255 &&\n    (null === input.extension ||\n      (\"string\" === typeof input.extension &&\n        RegExp(\"^[a-z0-9]+$\").test(input.extension) &&\n        input.extension.length <= 8)) &&\n    \"string\" === typeof input.url;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    (null === input.files ||\n      ((Array.isArray(input.files) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".files\",\n            expected: \"(Array<IAttachmentFile> | null)\",\n            value: input.files,\n          },\n          _errorFactory,\n        )) &&\n        input.files.every(\n          (elem, _index2) =>\n            (((\"object\" === typeof elem && null !== elem) ||\n              __typia_transform__assertGuard._assertGuard(\n                _exceptionable,\n                {\n                  method: \"typia.createAssert\",\n                  path: _path + \".files[\" + _index2 + \"]\",\n                  expected: \"IAttachmentFile\",\n                  value: elem,\n                },\n                _errorFactory,\n              )) &&\n              _ao1(\n                elem,\n                _path + \".files[\" + _index2 + \"]\",\n                true && _exceptionable,\n              )) ||\n            __typia_transform__assertGuard._assertGuard(\n              _exceptionable,\n              {\n                method: \"typia.createAssert\",\n                path: _path + \".files[\" + _index2 + \"]\",\n                expected: \"IAttachmentFile\",\n                value: elem,\n              },\n              _errorFactory,\n            ),\n        )) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".files\",\n          expected: \"(Array<IAttachmentFile> | null)\",\n          value: input.files,\n        },\n        _errorFactory,\n      )) &&\n    (null === input.title ||\n      (\"string\" === typeof input.title &&\n        (5 <= input.title.length ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".title\",\n              expected: \"string & MinLength<5>\",\n              value: input.title,\n            },\n            _errorFactory,\n          )) &&\n        (input.title.length <= 100 ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".title\",\n              expected: \"string & MaxLength<100>\",\n              value: input.title,\n            },\n            _errorFactory,\n          ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".title\",\n          expected: \"((string & MinLength<5> & MaxLength<100>) | null)\",\n          value: input.title,\n        },\n        _errorFactory,\n      )) &&\n    (\"string\" === typeof input.body ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".body\",\n          expected: \"string\",\n          value: input.body,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.created_at &&\n      (__typia_transform__isFormatDateTime._isFormatDateTime(\n        input.created_at,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".created_at\",\n            expected: 'string & Format<\"date-time\">',\n            value: input.created_at,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".created_at\",\n          expected: '(string & Format<\"date-time\">)',\n          value: input.created_at,\n        },\n        _errorFactory,\n      ));\n  const _ao1 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.name &&\n      (RegExp(\"^[a-z0-9]+$\").test(input.name) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".name\",\n            expected: 'string & Pattern<\"^[a-z0-9]+$\">',\n            value: input.name,\n          },\n          _errorFactory,\n        )) &&\n      (input.name.length <= 255 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".name\",\n            expected: \"string & MaxLength<255>\",\n            value: input.name,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".name\",\n          expected: '(string & Pattern<\"^[a-z0-9]+$\"> & MaxLength<255>)',\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    (null === input.extension ||\n      (\"string\" === typeof input.extension &&\n        (RegExp(\"^[a-z0-9]+$\").test(input.extension) ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".extension\",\n              expected: 'string & Pattern<\"^[a-z0-9]+$\">',\n              value: input.extension,\n            },\n            _errorFactory,\n          )) &&\n        (input.extension.length <= 8 ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".extension\",\n              expected: \"string & MaxLength<8>\",\n              value: input.extension,\n            },\n            _errorFactory,\n          ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".extension\",\n          expected: '((string & Pattern<\"^[a-z0-9]+$\"> & MaxLength<8>) | null)',\n          value: input.extension,\n        },\n        _errorFactory,\n      )) &&\n    (\"string\" === typeof input.url ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".url\",\n          expected: \"string\",\n          value: input.url,\n        },\n        _errorFactory,\n      ));\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  return (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \"\",\n              expected: \"IBbsArticle\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \"\",\n            expected: \"IBbsArticle\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n})();\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13"}},"/docs/setup":{"title":"Guide Documents > Setup","data":{"summary#Summary":"npm install typia\nnpx typia setup\npnpm install typia\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn typia setup --manager yarn\nbun add typia\nbun typia setup --manager bun\nJust run npx typia setup command if you're using tsc. The setup wizard will do everything.By the way, if you use typia with bundlers(vite, rollup, webpack, etc), the third party library unplugin-typia is recommended.Otherwise non-standard compiler case, only the generation mode is available.\nStandard Compiler\nMicrosoft/TypeScript (tsc)\nNon-standard Compilers\nbabel\nesbuild -> covered by unplugin-typia\nSWC","transformation#Transformation":"","concepts#Concepts":"AOT (Ahead of Time) compilation mode.When you write a TypeScript code calling typia.createIs<IMember>() function and compile it through tsc command, typia will replace the typia.createIs<IMember>() statement to optimal validation code in the compiled JavaScript file, for the IMember type.This is the transform mode performing AOT (Ahead of Time) compilation.\nimport typia, { tags } from \"typia\";\nexport const check = typia.createIs<IMember>();\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport typia from \"typia\";\nexport const check = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    19 < input.age &&\n    input.age <= 100;\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();","setup-wizard#Setup Wizard":"npm install --save typia\nnpx typia setup\npnpm install --save typia\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn typia setup --manager yarn\nbun add typia\nbun typia setup --manager bun\nYou can turn on transformation mode just by running npx typia setup command.Setup wizard would be executed, and it will do everything for the transformation.","manual-setup#Manual Setup":"npm install --save typia\nnpm install --save-dev typescript ts-patch\npnpm install --save typia\npnpm install --save-dev typescript ts-patch\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn add -D typescript ts-patch\nbun add typia\nbun add -d typescript ts-patch\nIf you want to install typia manually, just follow the steps.Firstly install typia as a dependency. And then, install typescript and ts-patch as devDependencies.\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"strictNullChecks\": true, \n    \"skipLibCheck\": true,\n    \"plugins\": [\n      { \"transform\": \"typia/lib/transform\" }\n    ]\n  }\n}\nSecondly open your tsconfig.json file as shown above.As typia generates optimal operation code through transformation, it must be configured as a plugin. Also, never forget to configure strict (or strictNullChecks) to be true within your tsconfig.json compilerOptions. It is essential option for modern TypeScript development.\n{\n  \"scripts\": {\n    \"prepare\": \"ts-patch install\"\n  },\n  \"dependencies\": {\n    \"typia\": \"^6.0.6\"\n  },\n  \"devDependencies\": {\n    \"ts-patch\": \"^3.2.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}\nnpm run prepare\npnpm prepare\n# YARN BERRY IS NOT SUPPORTED\nyarn prepare\nbun prepare\nFinally open package.json file and configure npm run prepare command like above.Be sure to run npm run prepare once you have made these changes.For reference, ts-patch is an helper library of TypeScript compiler that supporting custom transformations by plugins. From now on, whenever you run tsc command, your typia function call statements would be transformed to the optimal operation codes in the compiled JavaScript files.","bundlers#Bundlers":"","unplugin-typia#unplugin-typia":"unplugin-typia is a plugin to integrate typia into your bundlers seamlessly.Currently, unplugin-typia supports the following bundlers:\nBun\nEsbuild\nFarm\nNext.js\nRolldown\nRollup\nRspack\nVite\nWebpack\nnpm install -D @ryoppippi/unplugin-typia\nnpm install --save typia\nnpx typia setup\npnpm install -D @ryoppippi/unplugin-typia\npnpm install typia\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\nyarn add -D @ryoppippi/unplugin-typia\nyarn add typia\nyarn typia setup --manager yarn\nbun add -D @ryoppippi/unplugin-typia\nbun add typia\nbun typia setup\nAt first, install both unplugin-typia and typia, with npx typia setup command.After that, follow the next section steps to integrate unplugin-typia into your bundlers.For reference, there are a couple of ways to integrate unplugin-typia into your bundlers. For the full integration guide, please refer to the unplugin-typia documentation.\nYou can use any plugins with unplugin-typia in Vite (including @vitejs/plugin-react-swc).\nunplugin-typia processes the TypeScript code before transforming it to JavaScript, so it can be used with any plugins.\nimport UnpluginTypia from '@ryoppippi/unplugin-typia/vite'\n \nexport default defineConfig({\n  plugins: [\n    UnpluginTypia({ /* options */ })\n  ],\n})\nimport unTypiaNext from \"@ryoppippi/unplugin-typia/next\";\n \n/** @type {import('next').NextConfig} */\nconst config = {\n  // your next.js config\n};\nexport default unTypiaNext(\n  config,\n  {} // options of unplugin-typia\n);\nimport { build } from 'esbuild'\nimport UnpluginTypia from '@ryoppippi/unplugin-typia/esbuild';\n \nbuild({\n  plugins: [\n    UnpluginTypia({ /* options */ }),\n  ],\n});\nFirst, create a preload.ts file and add the following code.\nimport { plugin } from 'bun';\nimport UnpluginTypia from '@ryoppippi/unplugin-typia/bun'\nplugin(UnpluginTypia({ /* options */ }))\nThen, add the preload option to your bunfig.toml file.\npreload = [\"./preload.ts\"]\n[test]\npreload = [\"./preload.ts\"]\nAnd, run the bun run command.\nbun run index.ts\nFor more details, please refer to the unplugin-typia documentation.\nimport UnpluginTypia from '@ryoppippi/unplugin-typia/bun'\nawait Bun.build({\n\tentrypoints: [\"./index.ts\"],\n\toutdir: \"./out\",\n\tplugins: [UnpluginTypia(/* options */)]\n});\nFor more details, please refer to the unplugin-typia documentation.","webpack#webpack":"unplugin-typia also supports webpack as well.\n# TYPIA\nnpm install typia\nnpx typia setup\n# WEBPACK + TS-LOADER\nnpm install --save-dev ts-loader\nnpm install --save-dev webpack webpack-cli\n# TYPIA\npnpm install typia\npnpm typia setup --manager pnpm\n# WEBPACK + TS-LOADER\npnpm install --save-dev ts-loader\npnpm install --save-dev webpack webpack-cli\n###########################################\n# YARN BERRY IS NOT SUPPORTED\n###########################################\n# TYPIA\nyarn add typia\nyarn typia setup --manager yarn\n# WEBPACK + TS-LOADER\nyarn add -D ts-loader\nyarn add -D webpack webpack-cli\n# TYPIA\nbun add typia\nbun typia setup\n# WEBPACK + TS-LOADER\nbun add -d ts-loader\nbun add -d webpack webpack-cli\nWhen you're using webpack as a bundler, you can still utilize the transformation mode.Just install ts-loader as well as webpack, and configure webpack.config.js file like below.\nconst path = require(\"path\");\nconst nodeExternals = require(\"webpack-node-externals\");\nmodule.exports = {\n  // CUSTOMIZE HERE\n  entry: [\"./src/index.tsx\"],\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"index.js\",\n  },\n  optimization: {\n    minimize: false,\n  },\n  // JUST KEEP THEM\n  mode: \"development\",\n  target: \"node\",\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        loader: \"ts-loader\",\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".js\"],\n  },\n};\nFrom now on, you can build the single JS file just by running the npx webpack command. By the way, when removing devDependencies for --production install, never forget to add the --ignore-scripts option to prevent the prepare script.\nnpx webpack\nnpm ci --omit=dev --ignore-scripts\npnpm webpack\npnpm install --production --ignore-scripts\nyarn webpack\nrm -rf node_modules\nyarn install --production --ignore-scripts --immutable\nbun webpack\nbun install --production --ignore-scripts\nAdditionally, if you're using typia in the NodeJS project especially for the backend development, Setup Guide Documents of nestia would be helpful. Even though you're not using NestJS, you can still utilize below documents, and \"Single JS file only\" mode would be especially helpful for you.\nNestia > Setup > Webpack\nWith node_modules\nSingle JS file only","nx#Nx":"npm install --save typia\nnpx typia setup\npnpm install --save typia\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn typia setup --manager yarn\nbun add typia\nbun typia setup --manager bun\nAfter installing typia like above, and ensuring the prepare script is something similar to ts-patch install you have to modify the tsconfig.lib.json on each @nx/js package to be similar to the below.\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"../../dist/out-tsc\",\n    \"declaration\": true,\n    \"types\": [],\n    \"plugins\": [{ \"transform\": \"typia/lib/transform\" }]\n  },\n  \"include\": [\"**/*.ts\"],\n  \"exclude\": [\"jest.config.ts\", \"**/*.spec.ts\", \"**/*.test.ts\"]\n}\nAfter this, when running nx <package-name>:build it should now output with the Typia transforms applied. But if Typia fails for any reason (for example it considers some type you have to be invalid), this error is not reported back via Nx. Nx will silent swallow these errors from ts-patch/typia, and the resulting transpiled code will not have typia transformations applied. This will result in an error such as the following when running you tests that use typia (nx <package-name>:test), dev versions of your application (nx <package-name>:serve), as well as running your application after building.\nError on typia.createAssert(): no transform has been configured.\nTo debug whether this is an issue with your setup or simply NX just silently swallowing typia errors, you can create a new task in your project.json file similar to the one below.\n \"targets\": {\n    \"build:validate:typia\": {\n      \"executor\": \"nx:run-commands\",\n      \"options\": {\n        \"commands\": [\n          \"tsc --project packages/<package-name>/tsconfig.lib.json --outDir dist/packages/typiaTest\"\n        ],\n      }\n    },\n    ...\n }\nRunning this task will show you the errors from Typia, and allow you to correct them, meaning that using the standard nx <package-name>:build task should now work the way you expect.Note: While Nx has a transformers feature on the @nx/js plugin, that won't work with Typia. The reason is because Nx is expecting a transformer to export a before hook, which Nx then plugs directly into TypeScript via the compiler API. Typia doesn't export that kind of hook, because Typia only works with ts-patch, which abstracts the need for creating a specific before hook in the way Nx wants.","generation#Generation":"# INSTALL TYPIA\nnpm install --save typia\nnpm install --save-dev typescript\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nnpx typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n# INSTALL TYPIA\npnpm install --save typia\npnpm install --save-dev typescript\n# GENERATE TRANSFORMED TYPESCRIPT CODES\npnpm typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n# INSTALL TYPIA\nyarn add typia\nyarn add -D typescript\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nyarn typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n# INSTALL TYPIA\nbun add typia\nbun add -d typescript\nbun typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\nFor frontend projects.If you are using a non-standard TypeScript compiler such as the following, you will need to fall back to generation mode\nNon-standard TypeScript compilers:\nBabel in Create-React-App\nesbuild in Vite -> covered by unplugin-typia\nSWC -> use unplugin-typia with your bundlers ( including next.js, vite, webpack, rollup, etc )\nInstead you should utilize the generation mode.Install typia through npm install command, and run typia generate command. Then, generator of typia reads your TypeScript codes of --input, and writes transformed TypeScript files into the --output directory, like below.For clarification, the input directory should contain one or more TypeScript files which define how you want to verify your associated type assertions. Commonly you will import your TypeScript type, then export a function which validates that type. See below.If you want to specify other TypeScript project file instead of tsconfig.json, you can use --project option.\nimport typia from \"typia\";\nimport { IMember } from \"../structures/IMember\";\nexport const check = typia.createIs<IMember>();\nimport typia from \"typia\";\nimport { IMember } from \"../structures/IMember\";\nexport const check = (input: any): input is IMember => {\n  const $is_uuid = (typia.createIs as any).is_uuid;\n  const $is_email = (typia.createIs as any).is_email;\n  return (\n    \"object\" === typeof input &&\n    null !== input &&\n    \"string\" === typeof input.id &&\n    $is_uuid(input.id) &&\n    \"string\" === typeof input.email &&\n    $is_email(input.email) &&\n    \"number\" === typeof input.age &&\n    19 <= input.age &&\n    100 >= input.age\n  );\n};\nWhy not support non-standard compilers?Non-standard TypeScript compilers are removing every type information, and skipping type checks for rapid compilation. By the way, without those type information, typia can't do anything. This is the reason why typia doesn't support non-standard TypeScript compilers."}},"/docs/utilization/trpc":{"title":"Guide Documents > Utilization Cases > tRPC","data":{"":"import { initTRPC } from \"@trpc/server\";\nimport { v4 } from \"uuid\";\nimport typia from \"typia\";\nimport { IBbsArticle } from \"../structures/IBbsArticle\";\nconst server = initTRPC.create();\nexport const appRouter = server.router({\n  store: server.procedure\n    .input(typia.createAssert<IBbsArticle.IStore>())\n    .output(typia.createAssert<IBbsArticle>())\n    .query(({ input }) => {\n      return {\n        id: v4(),\n        writer: input.writer,\n        title: input.title,\n        body: input.body,\n        created_at: new Date().toString(),\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;"}},"/docs/validators/assert":{"title":"Guide Documents > Runtime Validators > assert() functions","data":{"assert-function#assert() function":"export function assert<T>(input: T): T;\nexport function assert<T>(input: unknown): T;\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nAsserts a value type.typia.assert<T>() function throws a TypeGuardError when wrong type comes.The TypeGuardError instance has only the first type error info, with access path and expected type. In the below example case, as the age property is wrong with its definition (@exclusiveMinimum), such TypeGuardError would be thrown:\nmethod: typia.assert()\npath: input.age\nvalue: 18,\nexpected: number & ExclusiveMinimum<19>\nAOT compilation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\ntypia.assert<IMember>({\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 18, // wrong, must be greater than 19\n});\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n(() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.assert\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.email &&\n      (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.assert\",\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.assert\",\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        },\n        _errorFactory,\n      ));\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  return (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.assert\",\n              path: _path + \"\",\n              expected: \"IMember\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.assert\",\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n})()({\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 18, // wrong, must be greater than 19\n});","assertequals-function#assertEquals() function":"export function assertEquals<T>(input: T): T;\nexport function assertEquals<T>(input: unknown): T;\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nMore strict assert function prohibiting superfluous properties.typia.assert<T>() function inspects input value type and throws TypeGuardError when mismatched, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, therefore throws an TypeGuardError when superfluous property exists, use typia.assertEquals<T()> function instead.In the below example case, as sex property is not defined in the IMember type, such TypeGuardError would be thrown:\nmethod: typia.assertEquals()\npath: input.sex\nvalue: 1,\n expected: undefined\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\ntypia.assert<IMember>({\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 30,\n  sex: 1, // extra\n});\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n(() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.assert\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.email &&\n      (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.assert\",\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.assert\",\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        },\n        _errorFactory,\n      ));\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  return (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.assert\",\n              path: _path + \"\",\n              expected: \"IMember\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.assert\",\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n})()({\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 30,\n  sex: 1, // extra\n});","assertguard-functions#assertGuard() functions":"export function assertGuard<T>(input: T): asserts input is T;\nexport function assertGuard<T>(input: unknown): asserts input is T;\nexport function assertGuardEquals<T>(input: T): asserts input is T;\nexport function assertGuardEquals<T>(input: unknown): asserts input is T;\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nAssertion guard of a value type.typia.assertGuard<T>() is similar with typia.assert<T>() throwing a TypeGuardError when wrong type.However, typia.assert<T>() returns the paramteric input value itself when there's no type problem on the parametric input value, whereas the typia.assertGuard<T>() function returns nothing. Instead, the parametric input value would be automatically cased to the type T. This is the concept of \"Assertion Guard\" of a value type.Such similarities and differences of typia.assertGuard<T>() and typia.assert<T>() functions are the same in the case of typia.assertGuardEquals<T>() and typia.assertEquals<T>() functions. If there's no type problem on the typia.assertGuardEquals<T>() function, it also performs the \"Assertion Guard\".Look at the below code, then you may understand what the \"Assertion Guard\" means.\nimport typia from \"typia\";\ninterface IPoint {\n  x: number;\n  y: number;\n}\nconst input: unknown = { x: 1, y: 2 };\n// PERFORM THE ASSERTION GUARD\ntypia.assertGuard<IPoint>(input);\n// FROM NOW ON, \"input\" IS THE \"IPoint\" TYPE\ninput.x; // OK\ninput.y; // OK","reusable-functions#Reusable functions":"export function createAssert<T>(): (input: unknown) => T;\nexport function createAssertEquals<T>(): (input: unknown) => T;\nexport function createAssertGuard<T>(): AssertionGuard<T>;\nexport function createAssertGuardEquals<T>(): AssertionGuard<T>;\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\nexport type AssertionGuard<T> = (input: unknown) => asserts input is T;\nReusable typia.assert<T>() function generators.If you repeat to call typia.assert<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createAssert<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\nexport const assertMember = typia.createAssert<IMember>();\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nexport const assertMember = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.email &&\n      (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        },\n        _errorFactory,\n      ));\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  return (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \"\",\n              expected: \"IMember\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n})();\nExplicitly of Assertion Guard\nBe careful when using typia.createAssertGuard<T>() or typia.createAssertGuardEquals<T>() functions.When calling those functions, you've to declare the variable type explicit on the caller variable. If you don't do it, so that the caller variables come the implicit function type, TypeScript compiler throws an error like below. This is a special limitation of TypeScript compiler about the \"Assertion Guard\".\nimport typia, { AssertionGuard } from \"typia\";\n//MUST DECLARE THE VARIABLE TYPE\nconst explicit: AssertionGuard<number> = typia.createAssertGuard<number>();\n// IF NOT, COMPILATION ERROR BE OCCURRED\nconst implicit = typia.createAssertGuard<number>();\nAssertions require every name in the call target to be declared with an explicit type annotation.","restrictions#Restrictions":"typia.assert<T>() function does not check function and user-defined class types.It validates only the primitive properties. Therefore, typia.assert<T>() function does not perform the instanceof ClassName for user-defined classes. If you want to validate the user-defined class type in addition to the property types, do it by yourself. Also, typia.assert<T>() function does not validate the function type either, unless configuring functional property of plugin option in the tsconfig.json file.\n{\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\",\n        \"functional\": true\n      }\n    ]\n  }\n}\nBy the way, there're some exception cases.If JS native class type like Date, Uint8Array, or Map<Key, T> being utilized, typia.assert<T>() function validates them. Especially about the Set<T>, and Map<Key, T> class cases, typia.assert<T>() function validates all of their contained element types, too.Therefore, the instanceof statement does not be used only for the user-defined classes.\nimport typia from \"typia\";\ntypia.createIs<Map<string, boolean | number | string>>();\nimport typia from \"typia\";\n(() => {\n  return (input) =>\n    input instanceof Map &&\n    (() =>\n      [...input].every(\n        (elem) =>\n          Array.isArray(elem) &&\n          elem.length === 2 &&\n          \"string\" === typeof elem[0] &&\n          (\"string\" === typeof elem[1] ||\n            \"number\" === typeof elem[1] ||\n            \"boolean\" === typeof elem[1]),\n      ))();\n})();","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\nexport const assertSomething = typia.createAssert<Something>();\n//----\n// DEFINE CUSTOM TYPE TAGS\n//----\ntype Dollar = tags.TagBase<{\n  kind: \"dollar\";\n  target: \"string\";\n  value: undefined;\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\ntype Postfix<Value extends string> = tags.TagBase<{\n  kind: \"postfix\";\n  target: \"string\";\n  value: Value;\n  validate: `$input.endsWith(\"${Value}\")`;\n}>;\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\n  kind: \"isEven\";\n  target: Value extends number ? \"number\" : \"bigint\";\n  value: undefined;\n  validate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\n}>;\ntype Numeric<Value extends number | bigint> = Value extends number\n  ? Value\n  : `BigInt(${Value})`;\n//----\n// VALIDATION\n//----\ninterface Something {\n  dollar: string & Dollar;\n  postfix: string & Postfix<\"!!!\">;\n  isEven: number & IsEven<number>;\n}\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nexport const assertSomething = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.dollar &&\n    input.dollar[0] === \"$\" &&\n    !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n    \"string\" === typeof input.postfix &&\n    input.postfix.endsWith(\"!!!\") &&\n    \"number\" === typeof input.isEven &&\n    input.isEven % 2 === 0;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.dollar &&\n      ((input.dollar[0] === \"$\" &&\n        !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\")))) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".dollar\",\n            expected: \"string & Dollar\",\n            value: input.dollar,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".dollar\",\n          expected: \"(string & Dollar)\",\n          value: input.dollar,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.postfix &&\n      (input.postfix.endsWith(\"!!!\") ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".postfix\",\n            expected: 'string & Postfix<\"!!!\">',\n            value: input.postfix,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".postfix\",\n          expected: '(string & Postfix<\"!!!\">)',\n          value: input.postfix,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.isEven &&\n      (input.isEven % 2 === 0 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".isEven\",\n            expected: \"number & IsEven<number>\",\n            value: input.isEven,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".isEven\",\n          expected: \"(number & IsEven<number>)\",\n          value: input.isEven,\n        },\n        _errorFactory,\n      ));\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  return (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \"\",\n              expected: \"Something\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \"\",\n            expected: \"Something\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n})();","performance#Performance":"Super-fast and super-safe.Comparing typia.assert<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\t\nC.V. means class-validator"}},"/docs/validators/is":{"title":"Guide Documents > Runtime Validators > is() functions","data":{"is-function#is() function":"export function is<T>(input: T): input is T;\nexport function is<T>(input: unknown): input is T;\nTests a value type.When you need to test an instance type, just call typia.is<T>() function.If the input value is following type T, true value would be returned. Otherwise, false would be returned.\nAOT compilation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.","equals-function#equals() function":"export function equals<T>(input: T): input is T;\nexport function equals<T>(input: unknown): input is T;\nMore strict checker prohibiting superfluous properties.typia.is<T>() can test instance type, but it allows superfluous properties.If you want to prohibit those superfluous properties, you can use typia.equals<T>() function instead.\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nconst input: unknown = {\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 30,\n  extra: \"superfluous property\", // extra\n};\nconst is: boolean = typia.is<IMember>(input);\nconst equals: boolean = typia.equals<IMember>(input);\nconsole.log(is, equals); // true, false\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\nconst input = {\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 30,\n  extra: \"superfluous property\", // extra\n};\nconst is = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})()(input);\nconst equals = (() => {\n  const _io0 = (input, _exceptionable = true) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100 &&\n    (3 === Object.keys(input).length ||\n      Object.keys(input).every((key) => {\n        if ([\"id\", \"email\", \"age\"].some((prop) => key === prop)) return true;\n        const value = input[key];\n        if (undefined === value) return true;\n        return false;\n      }));\n  return (input, _exceptionable = true) =>\n    \"object\" === typeof input && null !== input && _io0(input, true);\n})()(input);\nconsole.log(is, equals); // true, false","reusable-functions#Reusable functions":"export function createIs<T>(): (input: unknown) => input is T;\nexport function createEquals<T>(): (input: unknown) => input is T;\nReusable typia.is<T>() function generators.If you repeat to call typia.is<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIs<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\nexport const check = typia.createIs<IMember>();\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport typia from \"typia\";\nexport const check = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();","auto-type-casting#Auto Type Casting":"export function is<T>(input: unknown): input is T;\nexport function equals<T>(input: unknown): input is T;\nexport function createIs<T>(): (input: unknown) => input is T;\nexport function createEquals<T>(): (input: unknown) => input is T;\ntypia.is<T>() function can be used for type casting.When target input value is following the type T, therefore true value be returned, typia.is<T>() function automatically casts the input value to the type T. Therefore, you can utilize the typia.is<T>() function for safe type casting tool like below:\nconst input: unknown = {\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 30,\n} as any;\nif (typia.is<IMember>(input)) {\n  // auto type casting\n  console.log(input.id, input.email, input.age);\n}","restrictions#Restrictions":"typia.is<T>() function does not check function and user-defined class types.It validates only the primitive properties. Therefore, typia.is<T>() function does not perform the instanceof ClassName for user-defined classes. If you want to validate the user-defined class type in addition to the property types, do it by yourself. Also, typia.is<T>() function does not validate the function type either, unless configuring functional property of plugin option in the tsconfig.json file.\n{\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\",\n        \"functional\": true\n      }\n    ]\n  }\n}\nBy the way, there're some exception cases.If JS native class type like Date, Uint8Array, or Map<Key, T> being utilized, typia.is<T>() function validates them. Especially about the Set<T>, and Map<Key, T> class cases, typia.is<T>() function validates all of their contained element types, too.Therefore, the instanceof statement does not be used only for the user-defined classes.\nimport typia from \"typia\";\ntypia.createIs<Map<string, boolean | number | string>>();\nimport typia from \"typia\";\n(() => {\n  return (input) =>\n    input instanceof Map &&\n    (() =>\n      [...input].every(\n        (elem) =>\n          Array.isArray(elem) &&\n          elem.length === 2 &&\n          \"string\" === typeof elem[0] &&\n          (\"string\" === typeof elem[1] ||\n            \"number\" === typeof elem[1] ||\n            \"boolean\" === typeof elem[1]),\n      ))();\n})();","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\nexport const checkSomething = typia.createIs<Something>();\n//----\n// DEFINE CUSTOM TYPE TAGS\n//----\ntype Dollar = tags.TagBase<{\n  kind: \"dollar\";\n  target: \"string\";\n  value: undefined;\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\ntype Postfix<Value extends string> = tags.TagBase<{\n  kind: \"postfix\";\n  target: \"string\";\n  value: Value;\n  validate: `$input.endsWith(\"${Value}\")`;\n}>;\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\n  kind: \"isEven\";\n  target: Value extends number ? \"number\" : \"bigint\";\n  value: undefined;\n  validate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\n}>;\ntype Numeric<Value extends number | bigint> = Value extends number\n  ? Value\n  : `BigInt(${Value})`;\n//----\n// VALIDATION\n//----\ninterface Something {\n  dollar: string & Dollar;\n  postfix: string & Postfix<\"!!!\">;\n  isEven: number & IsEven<number>;\n}\nimport typia from \"typia\";\nexport const checkSomething = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.dollar &&\n    input.dollar[0] === \"$\" &&\n    !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n    \"string\" === typeof input.postfix &&\n    input.postfix.endsWith(\"!!!\") &&\n    \"number\" === typeof input.isEven &&\n    input.isEven % 2 === 0;\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();","performance#Performance":"Super-fast and super-safe.Comparing typia.is<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\t\nC.V. means class-validator"}},"/docs/validators/tags":{"title":"Guide Documents > Runtime Validators > Special Tags","data":{"outline#Outline":"typia can perform additional validation through type tags and comment tags.When you need additional validation logic that is not supported in pure TypeScript type spec, you can use type tags and comment tags for it. For example, if you define a type with intersection symbol like number & typia.tags.Type<\"uint32\"> and validates it, typia will check the target numeric value is unsigned integer or not.Also, in TypeScript (and JavaScript), writing @ character in comment is called Comment Tag and typia utilizes such comment tags for enhancing type validation logic. As you can see from below example code, typia analyzes @tagName value patterned comment tags, and generates optimal validation logic in the compilation level.Therefore, don't be afraid typia uses only pure TypeScript types for type validation schema. Don't be afraid about TypeScript does not support integer type. With those type tags and comment tags, you can express every types in the world.\nQ: How to validate integer type? TypeScript does not support it\nA1: Use type tag number & typia.tags.Type<\"int32\">\nA2: Write a comment tag @type int32 on the target property\nQ: Type Tag vs Comment Tags, which one is better\nA1: Type Tag is recommended because it is much safer and generous\nA2: Comment Tag is designed for legacy JSDoc styled projects\nimport typia, { tags } from \"typia\";\nexport const checkCustomTag = typia.createIs<CustomTag>();\ninterface CustomTag {\n  /**\n   * @type uint32\n   */\n  type: number;\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n  /**\n   * @minLength 3\n   */\n  string: string;\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n  /**\n   * Type tag can perform union type.\n   *\n   * In here case, format can be oneof `ipv4` or `ipv6` format.\n   */\n  format: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">)) | null;\n  /**\n   * In the Array case, only type tag can restrict element type.\n   */\n  array: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n  /**\n   * Also, only type tag can handle map type.\n   */\n  map: Map<\n    number & tags.Type<\"uint32\">,\n    Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>\n  >;\n}\nimport * as __typia_transform__isFormatIpv4 from \"typia/lib/internal/_isFormatIpv4.js\";\nimport * as __typia_transform__isFormatIpv6 from \"typia/lib/internal/_isFormatIpv6.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport typia from \"typia\";\nexport const checkCustomTag = (() => {\n  const _io0 = (input) =>\n    \"number\" === typeof input.type &&\n    Math.floor(input.type) === input.type &&\n    0 <= input.type &&\n    input.type <= 4294967295 &&\n    (undefined === input.number ||\n      (\"number\" === typeof input.number &&\n        19 < input.number &&\n        input.number <= 100)) &&\n    \"string\" === typeof input.string &&\n    3 <= input.string.length &&\n    \"string\" === typeof input.pattern &&\n    RegExp(\"^[a-z]+$\").test(input.pattern) &&\n    (null === input.format ||\n      (\"string\" === typeof input.format &&\n        (__typia_transform__isFormatIpv4._isFormatIpv4(input.format) ||\n          __typia_transform__isFormatIpv6._isFormatIpv6(input.format)))) &&\n    Array.isArray(input.array) &&\n    3 <= input.array.length &&\n    input.array.length <= 100 &&\n    input.array.every(\n      (elem) =>\n        \"string\" === typeof elem &&\n        __typia_transform__isFormatUuid._isFormatUuid(elem),\n    ) &&\n    input.map instanceof Map &&\n    (() =>\n      [...input.map].every(\n        (elem) =>\n          Array.isArray(elem) &&\n          elem.length === 2 &&\n          \"number\" === typeof elem[0] &&\n          __typia_transform__isTypeUint32._isTypeUint32(elem[0]) &&\n          Array.isArray(elem[1]) &&\n          1 <= elem[1].length &&\n          elem[1].every(\n            (elem) =>\n              \"string\" === typeof elem &&\n              __typia_transform__isFormatUuid._isFormatUuid(elem),\n          ),\n      ))();\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();","type-tags#Type Tags":"By using type tags, you can utilize additional validation logics.Just import one of type tags from typia, and combine it with target through intersection symbol like number & typia.tags.Type<\"uint32\"> case. If you want to declare an union validation logic, combine | and bracket (()) symbols properly like below:\nnumber & (Type<\"uint32\"> | Type<\"double\">)\nnumber type can be both uint32 and double\n(number & Type<\"int32\">) | (bigint & Type<\"uint64\">)\nnumber is int32\nbigint is uint64\n(number & (Type<\"int32\">)| Type<\"float\">) | (bigint & Type<\"uint64\">)\nnumber can be both int32 and float\nbigint is uint64\nHere is the entire list of type tags that typia basically supports.For reference, when you take a mistake that choosing different target type, TypeScript compiler would block it with compilation error message. Also, if you take a mistake that placing invalid argument on the type, it would also be blocked IDE and compiler. Therefore, have a confidence when using them.\nnumber\nnumber & Type<{keyword}>\nint32\nuint32\nuint64\nint64\nfloat\ndouble\nnumber & Minimum<{number}>\nnumber & Maximum<{number}>\nnumber & ExclusiveMaximum<{number}>\nnumber & ExclusiveMinimum<{number}>\nnumber & MultipleOf<{number}>\nbigint\nbigint & Type<{keyword}>\nint64\nuint64\nbigint & Minimum<{bigint}>\nbigint & Maximum<{bigint}>\nbigint & ExclusiveMaximum<{bigint}>\nbigint & ExclusiveMinimum<{bigint}>\nbigint & MultipleOf<{bigint}>\nstring\nstring & MinLength<{number}>\nstring & MaxLength<{number}>\nstring & Pattern<{regex}>\nstring & Format<{keyword}>\nbyte\npassword\nregex\nuuid\nemail\nhostname\nidn-email\nidn-hostname\niri\niri-reference\nipv4\nipv6\nuri\nuri-reference\nuri-template\nurl\ndate-time\ndate\ntime\nduration\njson-pointer\nrelative-json-pointer\narray\nArray<T> & MinItems<{number}>\nArray<T> & MaxItems<{number}>\nArray<T> & UniqueItems\nAlso, if you need custom validation logic, just make it by yourself referencing Customization section. It is easy to define. For such type safety and generous use case reasons even customization supporting, I recommend you to use type tags instead of comment tags, unless you are maintaining a legacy JSDoc styled project.\nimport typia, { tags } from \"typia\";\nexport const checkCustomTag = typia.createIs<CustomTag>();\ninterface CustomTag {\n  type: number & tags.Type<\"uint32\">;\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n  string: string & tags.MinLength<3>;\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n  /**\n   * Type tag can perform union type.\n   *\n   * In here case, format can be oneof `ipv4` or `ipv6` format.\n   */\n  format: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">)) | null;\n  /**\n   * In the Array case, only type tag can restrict element type.\n   */\n  array: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n  /**\n   * Also, only type tag can handle map type.\n   */\n  map: Map<\n    number & tags.Type<\"uint32\">,\n    Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>\n  >;\n}\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__isFormatIpv4 from \"typia/lib/internal/_isFormatIpv4.js\";\nimport * as __typia_transform__isFormatIpv6 from \"typia/lib/internal/_isFormatIpv6.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport typia from \"typia\";\nexport const checkCustomTag = (() => {\n  const _io0 = (input) =>\n    \"number\" === typeof input.type &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.type) &&\n    (undefined === input.number ||\n      (\"number\" === typeof input.number &&\n        19 < input.number &&\n        input.number <= 100)) &&\n    \"string\" === typeof input.string &&\n    3 <= input.string.length &&\n    \"string\" === typeof input.pattern &&\n    RegExp(\"^[a-z]+$\").test(input.pattern) &&\n    (null === input.format ||\n      (\"string\" === typeof input.format &&\n        (__typia_transform__isFormatIpv4._isFormatIpv4(input.format) ||\n          __typia_transform__isFormatIpv6._isFormatIpv6(input.format)))) &&\n    Array.isArray(input.array) &&\n    3 <= input.array.length &&\n    input.array.length <= 100 &&\n    input.array.every(\n      (elem) =>\n        \"string\" === typeof elem &&\n        __typia_transform__isFormatUuid._isFormatUuid(elem),\n    ) &&\n    input.map instanceof Map &&\n    (() =>\n      [...input.map].every(\n        (elem) =>\n          Array.isArray(elem) &&\n          elem.length === 2 &&\n          \"number\" === typeof elem[0] &&\n          __typia_transform__isTypeUint32._isTypeUint32(elem[0]) &&\n          Array.isArray(elem[1]) &&\n          1 <= elem[1].length &&\n          elem[1].every(\n            (elem) =>\n              \"string\" === typeof elem &&\n              __typia_transform__isFormatUuid._isFormatUuid(elem),\n          ),\n      ))();\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();","comment-tags#Comment Tags":"typia supports those comment tags, too.Here is the entire list of comment tags that typia supports.\nnumber\n@type {string}\nint / int32\nuint / uint32\nint64\nuint64\nfloat\n@minimum {number}\n@maximum {number}\n@exclusiveMinimum {number}\n@exclusiveMaximum {number}\n@multipleOf {number}\nbigint\n@type uint64\n@minimum {bigint}\n@maximum {bigint}\n@exclusiveMinimum {bigint}\n@exclusiveMaximum {bigint}\n@multipleOf {bigint}\nstring\n@minLength {number}\n@maxLength {number}\n@pattern {regex}\n@format {keyword}\nbyte\npassword\nregex\nuuid\nemail\nhostname\nidn-email\nidn-hostname\niri\niri-reference\nipv4\nipv6\nuri\nuri-reference\nuri-template\nurl\ndate-time\ndate\ntime\nduration\njson-pointer\nrelative-json-pointer\narray\n@minItems {number}\n@maxItems {number}\n@uniqueItems\nBy the way, I do not recommend this way, because it can't perform union numeric types, and can be used for only object property type. It can't be used standalone, and cannot be used for element type of Array and Map even when they're declared on object property. Also, When you declare @type int32 statement, target number type be fixed as int32 type, and never can have another numeric type by declaring union statements.Also, those comment tags are not type safe. If you take a mistake when writing a comment tag, it will not be detected by the compiler, and will cause an error at runtime. For example, if you write a miss-spelled keyword like @type unit32, the target number type would be double type, and you can identify it just by running the program (or visiting playground website).\nWhy supports comment tags?\nDespite these disadvantages, the reason for maintaining comment tags is as follows.First, it is to support the legacy JSDoc style that had been used in the JS camp for a long time. If you had developed a legacy project and JSDoc being used, you can use it as is.Second, to support Prisma. If a comment is created in the Prisma Schema through the /// statement as shown below and a type is created, it is converted to a TS comment as it is. And since there is no way that union types, numeric Arrays or Maps are used in Prisma (database) schema, these comment tags are surprisingly compatible with Prisma.\nimport typia from \"typia\";\nexport const checkCustomTag = typia.createIs<CustomTag>();\ninterface CustomTag {\n  /**\n   * @type uint32\n   */\n  type: number;\n  /**\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n  /**\n   * @minLength 3\n   */\n  string: string;\n  /**\n   * @Pattern /^[a-z]+$/\n   */\n  pattern: string;\n  // NO WAY WHEN COMMENT TAG\n  // /**\n  //  * Type tag can perform union type.\n  //  *\n  //  * In here case, format can be oneof `ipv4` or `ipv6` format.\n  //  */\n  // format: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">)) | null;\n  // NO WAY WHEN COMMENT TAG\n  // /**\n  //  * In the Array case, only type tag can restrict element type.\n  //  */\n  // array: Array<string & tags.Format<\"uuid\">>\n  //     & tags.MinItems<3>\n  //     & tags.MaxItems<100>;\n  // NO WAY WHEN COMMENT TAG\n  // /**\n  //  * Also, only type tag can handle map type.\n  //  */\n  // map: Map<\n  //     number & tags.Type<\"uint32\">,\n  //     Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>\n  // >;\n}\nimport typia from \"typia\";\nexport const checkCustomTag = (() => {\n  const _io0 = (input) =>\n    \"number\" === typeof input.type &&\n    Math.floor(input.type) === input.type &&\n    0 <= input.type &&\n    input.type <= 4294967295 &&\n    (undefined === input.number ||\n      (\"number\" === typeof input.number &&\n        19 < input.number &&\n        input.number <= 100)) &&\n    \"string\" === typeof input.string &&\n    3 <= input.string.length &&\n    \"string\" === typeof input.pattern;\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();","customization#Customization":"export type TagBase<Props extends TagBase.IProps<any, any, any, any, any>> = {\n  /**\n   * This is a dummy property for compilation.\n   *\n   * It does not mean anything in runtime.\n   */\n  \"typia.tag\"?: Props;\n};\nexport namespace TagBase {\n  export interface IProps<\n    Target extends \"bigint\" | \"number\" | \"string\" | \"array\",\n    Kind extends string,\n    Value extends boolean | bigint | number | string | undefined,\n    Validate extends\n      | string\n      | {\n          [key in Target]?: string;\n        },\n    Exclusive extends boolean | string[],\n  > {\n    /**\n     * Target type.\n     *\n     * If user tries to adapt this tag to a different type, it would be a compile\n     * error.\n     *\n     * For example, you've configured target type as `string`, but user adapted it\n     * onto a `number` type (`number & YourCustomTag<Value>`), then it would be\n     * blocked by TypeScript compiler.\n     */\n    target: Target;\n    /**\n     * What kind of tag is this?\n     */\n    kind: Kind;\n    /**\n     * Value to be configured by user.\n     */\n    value: Value;\n    /**\n     * Validation code.\n     *\n     * This code would be inserted into the generated validation function.\n     * In here script, target variable name must be `$input`. The variable name\n     * `$input` would be transformed to the suitable when compilation.\n     *\n     * Also, If you've take a mistake on this script, compile error would be\n     * occurred. So, define it with confidence. Compiler will block all your\n     * mistakes.\n     */\n    validate: Validate;\n    /**\n     * Exclusive option.\n     *\n     * If this property configured as `true`, same {@link kind} tag cannot be\n     * duplicated in the target type. Otherwise, if you've configured this property\n     * as string array, all of the {@link kind} value assigned tag cannot be\n     * compatible in the target type.\n     *\n     * @default false\n     */\n    exclusive?: Exclusive | string[];\n  }\n}\nimport { TagBase } from \"./TagBase\";\nexport type Minimum<Value extends number | bigint> = TagBase<{\n  target: Value extends number ? \"number\" : \"bigint\";\n  kind: \"minimum\";\n  value: Value;\n  validate: `${Numeric<Value>} <= $input`;\n  exclusive: [\"minimum\", \"exclusiveMinimum\"];\n}>;\ntype Numeric<Value extends number | bigint> = Value extends number\n  ? Value\n  : `BigInt(${Value})`;\nimport { TagBase } from \"./TagBase\";\nexport type Type<\n  Value extends \"int32\" | \"uint32\" | \"int64\" | \"uint64\" | \"float\" | \"double\",\n> = TagBase<{\n  target: Value extends \"int64\" | \"uint64\" ? \"bigint\" | \"number\" : \"number\";\n  kind: \"type\";\n  value: Value;\n  validate: Value extends \"int32\"\n    ? `Math.floor($input) === $input && -2147483648 <= $input && $input <= 2147483647`\n    : Value extends \"uint32\"\n    ? `Math.floor($input) === $input && 0 <= $input && $input <= 4294967295`\n    : Value extends \"int64\"\n    ? {\n        number: `Math.floor($input) === $input && -9223372036854775808 <= $input && $input <= 9223372036854775807`;\n        bigint: `true`;\n      }\n    : Value extends \"uint64\"\n    ? {\n        number: `Math.floor($input) === $input && 0 <= $input && $input <= 18446744073709551615`;\n        bigint: `BigInt(0) <= $input`;\n      }\n    : Value extends \"float\"\n    ? `-1.175494351e38 <= $input && $input <= 3.4028235e38`\n    : `true`;\n  exclusive: true;\n}>;\nimport { TagBase } from \"./TagBase\";\nexport type Pattern<Value extends string> = TagBase<{\n  target: \"string\";\n  kind: \"pattern\";\n  value: Value;\n  validate: `/${Value}/.test($input)`;\n}>;\nAbove types are supported by typia basically.If you make a custom type tag extending typia.tags.TagBase<Props> type, and utilize it on your type with intersection symbol like number & Minimum<3>, its validation logic 3 <= $input would be inserted into the compiled JavaScript file.Also, as you can see from the typia.tags.TagBase<Props> type, you have to specify which target type is the tag for, and need to define the tag can be compatible with others or not through exclusive options. If your custom tag has multiple target types, you can support all of those target types by defining validate property as Record<Target, string> type like Type tag case.In the Korean proverb, there's a word that, \"it is much better to do it once than to hear it a hundred times\". Let's see how custom type tag of typia can be defined and utilized through an example code. I'll define three custom tag types, Postfix, Dollar and IsEven.Here is the example code, and I think that it may easy to understand.\nimport typia from \"typia\";\nexport const checkTagCustom = typia.createIs<TagCustom>();\ninterface TagCustom {\n  id: string & typia.tags.Format<\"uuid\">;\n  dollar: string & Dolloar;\n  postfix: string & Postfix<\"abcd\">;\n  powerOf: number & PowerOf<2>;\n}\ntype Dolloar = typia.tags.TagBase<{\n  kind: \"dollar\";\n  target: \"string\";\n  value: undefined;\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\ntype Postfix<Value extends string> = typia.tags.TagBase<{\n  kind: \"postfix\";\n  target: \"string\";\n  value: Value;\n  validate: `$input.endsWith(\"${Value}\")`;\n}>;\ntype PowerOf<Value extends number> = typia.tags.TagBase<{\n  kind: \"powerOf\";\n  target: \"number\";\n  value: Value;\n  validate: `(() => {\n        const denominator: number = Math.log(${Value});\n        const value: number = Math.log($input) / denominator;\n        return Math.abs(value - Math.round(value)) < 0.00000001;\n    })()`;\n}>;\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport typia from \"typia\";\nexport const checkTagCustom = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.dollar &&\n    input.dollar[0] === \"$\" &&\n    !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n    \"string\" === typeof input.postfix &&\n    input.postfix.endsWith(\"abcd\") &&\n    \"number\" === typeof input.powerOf &&\n    (() => {\n      const denominator = Math.log(2);\n      const value = Math.log(input.powerOf) / denominator;\n      return Math.abs(value - Math.round(value)) < 1e-8;\n    })();\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();"}},"/docs/validators/validate":{"title":"Guide Documents > Runtime Validators > validate() functions","data":{"validate-function#validate() function":"export function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\nValidates a value type.typia.validate<T>() function validates input value type, and archives every type errors detaily into IValidation.IFailure.errors array, when the input value is not following the promised type T. Of course, if the parametric input value is following the type T, IValidation.ISuccess instance would be returned.In the below example case, as id and age values are different with its definition of IMember, such errors would be archived into the IValidation.IFailure.errors array.\nerrors[0]\npath: input.id\nexpected: string & Format<\"uuid\">\nvalue: 5\nerrors[1]\npath: input.age\nexpected: number & Format<\"uint32\">\nvalue: 20.75\nAOT compilation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\nimport typia, { tags } from \"typia\";\nconst res: typia.IValidation<IMember> = typia.validate<IMember>({\n  id: 5, // wrong, must be string (uuid)\n  age: 20.75, // wrong, not integer\n  email: \"samchon.github@gmail.com\",\n});\nif (!res.success) console.log(res.errors);\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__validateReport from \"typia/lib/internal/_validateReport.js\";\nimport typia from \"typia\";\nconst res = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _vo0 = (input, _path, _exceptionable = true) =>\n    [\n      (\"string\" === typeof input.id &&\n        (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n          $report(_exceptionable, {\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        }),\n      (\"string\" === typeof input.email &&\n        (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n          $report(_exceptionable, {\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        }),\n      (\"number\" === typeof input.age &&\n        (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          })) &&\n        (19 < input.age ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          })) &&\n        (input.age <= 100 ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        }),\n    ].every((flag) => flag);\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let errors;\n  let $report;\n  return (input) => {\n    if (false === __is(input)) {\n      errors = [];\n      $report = __typia_transform__validateReport._validateReport(errors);\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          })) &&\n          _vo0(input, _path + \"\", true)) ||\n        $report(true, {\n          path: _path + \"\",\n          expected: \"IMember\",\n          value: input,\n        }))(input, \"$input\", true);\n      const success = 0 === errors.length;\n      return {\n        success,\n        errors,\n        data: success ? input : undefined,\n      };\n    }\n    return {\n      success: true,\n      errors: [],\n      data: input,\n    };\n  };\n})()({\n  id: 5, // wrong, must be string (uuid)\n  age: 20.75, // wrong, not integer\n  email: \"samchon.github@gmail.com\",\n});\nif (!res.success) console.log(res.errors);","validateequals-function#validateEquals() function":"export function validateEquals<T>(input: T): IValidation<T>;\nexport function validateEquals<T>(input: unknown): IValidation<T>;\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\nMore strict validate function prohibiting superfluous properties.typia.validate<T> function detects every type errors of input value, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, so that archive them into IValidation.IFailure.errors array, use typia.validateEquals<T>() function instead.In the below example case, as id property is different with its type definition and sex property is not defined in the IMember type, such errors would be archived into the IValidation.IFailure.errors array:\nerrors[0]\npath: input.id\nexpected: string (@format uuid)\nvalue: something\nerrors[1]\npath: input.sex\nexpected: undefined\nvalue: 1\nimport typia, { tags } from \"typia\";\nconst res: typia.IValidation<IMember> = typia.validateEquals<IMember>({\n  age: 30,\n  email: \"samchon.github@gmail.com\",\n  id: \"something\", // wrong, must be string (uuid)\n  sex: 1, // extra property\n});\nif (!res.success) console.log(res.errors);\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__accessExpressionAsString from \"typia/lib/internal/_accessExpressionAsString.js\";\nimport * as __typia_transform__validateReport from \"typia/lib/internal/_validateReport.js\";\nimport typia from \"typia\";\nconst res = (() => {\n  const _io0 = (input, _exceptionable = true) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100 &&\n    (3 === Object.keys(input).length ||\n      Object.keys(input).every((key) => {\n        if ([\"id\", \"email\", \"age\"].some((prop) => key === prop)) return true;\n        const value = input[key];\n        if (undefined === value) return true;\n        return false;\n      }));\n  const _vo0 = (input, _path, _exceptionable = true) =>\n    [\n      (\"string\" === typeof input.id &&\n        (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n          $report(_exceptionable, {\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        }),\n      (\"string\" === typeof input.email &&\n        (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n          $report(_exceptionable, {\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        }),\n      (\"number\" === typeof input.age &&\n        (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          })) &&\n        (19 < input.age ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          })) &&\n        (input.age <= 100 ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        }),\n      3 === Object.keys(input).length ||\n        false === _exceptionable ||\n        Object.keys(input)\n          .map((key) => {\n            if ([\"id\", \"email\", \"age\"].some((prop) => key === prop))\n              return true;\n            const value = input[key];\n            if (undefined === value) return true;\n            return $report(_exceptionable, {\n              path:\n                _path +\n                __typia_transform__accessExpressionAsString._accessExpressionAsString(\n                  key,\n                ),\n              expected: \"undefined\",\n              value: value,\n            });\n          })\n          .every((flag) => flag),\n    ].every((flag) => flag);\n  const __is = (input, _exceptionable = true) =>\n    \"object\" === typeof input && null !== input && _io0(input, true);\n  let errors;\n  let $report;\n  return (input) => {\n    if (false === __is(input)) {\n      errors = [];\n      $report = __typia_transform__validateReport._validateReport(errors);\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          })) &&\n          _vo0(input, _path + \"\", true)) ||\n        $report(true, {\n          path: _path + \"\",\n          expected: \"IMember\",\n          value: input,\n        }))(input, \"$input\", true);\n      const success = 0 === errors.length;\n      return {\n        success,\n        errors,\n        data: success ? input : undefined,\n      };\n    }\n    return {\n      success: true,\n      errors: [],\n      data: input,\n    };\n  };\n})()({\n  age: 30,\n  email: \"samchon.github@gmail.com\",\n  id: \"something\", // wrong, must be string (uuid)\n  sex: 1, // extra property\n});\nif (!res.success) console.log(res.errors);","reusable-functions#Reusable functions":"export function createValidate<T> = (input: unknown) => IValidation<T>;\nexport function createValidateEquals<T> = (input: unknown) => IValidation<T>;\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\nReusable typia.validate<T>() function generators.If you repeat to call typia.validate<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createValidate<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\nexport const validateMember = typia.createValidate<IMember>();\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__validateReport from \"typia/lib/internal/_validateReport.js\";\nimport typia from \"typia\";\nexport const validateMember = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _vo0 = (input, _path, _exceptionable = true) =>\n    [\n      (\"string\" === typeof input.id &&\n        (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n          $report(_exceptionable, {\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        }),\n      (\"string\" === typeof input.email &&\n        (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n          $report(_exceptionable, {\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        }),\n      (\"number\" === typeof input.age &&\n        (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          })) &&\n        (19 < input.age ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          })) &&\n        (input.age <= 100 ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        }),\n    ].every((flag) => flag);\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let errors;\n  let $report;\n  return (input) => {\n    if (false === __is(input)) {\n      errors = [];\n      $report = __typia_transform__validateReport._validateReport(errors);\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          })) &&\n          _vo0(input, _path + \"\", true)) ||\n        $report(true, {\n          path: _path + \"\",\n          expected: \"IMember\",\n          value: input,\n        }))(input, \"$input\", true);\n      const success = 0 === errors.length;\n      return {\n        success,\n        errors,\n        data: success ? input : undefined,\n      };\n    }\n    return {\n      success: true,\n      errors: [],\n      data: input,\n    };\n  };\n})();","restrictions#Restrictions":"typia.validate<T>() function does not check function and user-defined class types.It validates only the primitive properties. Therefore, typia.validate<T>() function does not perform the instanceof ClassName for user-defined classes. If you want to validate the user-defined class type in addition to the property types, do it by yourself. Also, typia.validate<T>() function does not validate the function type either, unless configuring functional property of plugin option in the tsconfig.json file.\n{\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\",\n        \"functional\": true\n      }\n    ]\n  }\n}\nBy the way, there're some exception cases.If JS native class type like Date, Uint8Array, or Map<Key, T> being utilized, typia.validate<T>() function validates them. Especially about the Set<T>, and Map<Key, T> class cases, typia.validate<T>() function validates all of their contained element types, too.Therefore, the instanceof statement does not be used only for the user-defined classes.\nimport typia from \"typia\";\ntypia.createIs<Map<string, boolean | number | string>>();\nimport typia from \"typia\";\n(() => {\n  return (input) =>\n    input instanceof Map &&\n    (() =>\n      [...input].every(\n        (elem) =>\n          Array.isArray(elem) &&\n          elem.length === 2 &&\n          \"string\" === typeof elem[0] &&\n          (\"string\" === typeof elem[1] ||\n            \"number\" === typeof elem[1] ||\n            \"boolean\" === typeof elem[1]),\n      ))();\n})();","discriminated-union#Discriminated Union":"export function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\nexport function createValidate<T>(): (input: unknown) => IValidation<T>;\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\nSpecify type through if condition.typia.IValidation<T> is an union type of typia.IValidation.ISuccess<T> and typia.IValidation.IFailure. Also, they have a common property success of boolean type, but different literal values. In that case, if you write a if condition about the success property, you can specify the union type like below.In TypeScript, such union type specification through common property (of different literal value() is called \"Discriminated Union\". Therefore, when using typia.validate<T>() function, let's utilize such discriminated union specification for convenience.\nimport typia from \"typia\";\nconst something: unknown = ...;\nconst result: typia.IValidation<string> = typia.validate<string>(something);\nif (results.success) {\n  // become typia.IValidation.Success<string> type\n  result.data; // accessible\n} else {\n  // become typia.IValidation.Failure type\n  result.errors; //accessible\n}","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\nexport const validateSomething = typia.createValidate<Something>();\n//----\n// DEFINE CUSTOM TYPE TAGS\n//----\ntype Dollar = tags.TagBase<{\n  kind: \"dollar\";\n  target: \"string\";\n  value: undefined;\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\ntype Postfix<Value extends string> = tags.TagBase<{\n  kind: \"postfix\";\n  target: \"string\";\n  value: Value;\n  validate: `$input.endsWith(\"${Value}\")`;\n}>;\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\n  kind: \"isEven\";\n  target: Value extends number ? \"number\" : \"bigint\";\n  value: undefined;\n  validate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\n}>;\ntype Numeric<Value extends number | bigint> = Value extends number\n  ? Value\n  : `BigInt(${Value})`;\n//----\n// VALIDATION\n//----\ninterface Something {\n  dollar: string & Dollar;\n  postfix: string & Postfix<\"!!!\">;\n  isEven: number & IsEven<number>;\n}\nimport typia from \"typia\";\nexport const validateSomething = (() => {\n  const $io0 = (input) =>\n    \"string\" === typeof input.dollar &&\n    input.dollar[0] === \"$\" &&\n    !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n    \"string\" === typeof input.postfix &&\n    input.postfix.endsWith(\"!!!\") &&\n    \"number\" === typeof input.isEven &&\n    input.isEven % 2 === 0;\n  const $vo0 = (input, _path, _exceptionable = true) =>\n    [\n      (\"string\" === typeof input.dollar &&\n        ((input.dollar[0] === \"$\" &&\n          !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\")))) ||\n          $report(_exceptionable, {\n            path: _path + \".dollar\",\n            expected: \"string & Dollar\",\n            value: input.dollar,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".dollar\",\n          expected: \"(string & Dollar)\",\n          value: input.dollar,\n        }),\n      (\"string\" === typeof input.postfix &&\n        (input.postfix.endsWith(\"!!!\") ||\n          $report(_exceptionable, {\n            path: _path + \".postfix\",\n            expected: 'string & Postfix<\"!!!\">',\n            value: input.postfix,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".postfix\",\n          expected: '(string & Postfix<\"!!!\">)',\n          value: input.postfix,\n        }),\n      (\"number\" === typeof input.isEven &&\n        (input.isEven % 2 === 0 ||\n          $report(_exceptionable, {\n            path: _path + \".isEven\",\n            expected: \"number & IsEven<number>\",\n            value: input.isEven,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".isEven\",\n          expected: \"(number & IsEven<number>)\",\n          value: input.isEven,\n        }),\n    ].every((flag) => flag);\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && $io0(input);\n  let errors;\n  let $report;\n  return (input) => {\n    if (false === __is(input)) {\n      errors = [];\n      $report = typia.createValidate.report(errors);\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"Something\",\n            value: input,\n          })) &&\n          $vo0(input, _path + \"\", true)) ||\n        $report(true, {\n          path: _path + \"\",\n          expected: \"Something\",\n          value: input,\n        }))(input, \"$input\", true);\n      const success = 0 === errors.length;\n      return {\n        success,\n        errors,\n        data: success ? input : undefined,\n      };\n    }\n    return {\n      success: true,\n      errors: [],\n      data: input,\n    };\n  };\n})();","performance#Performance":"Super-fast and super-safe.Comparing typia.validate<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\t\nC.V. means class-validator"}},"/":{"title":"Home","data":{"transformer#Transformer":"Guide Documents · Playground (Online IDE) · Github Repository\ntypia is a transformer library converting TypeScript types to runtime function.If you call one of the typia function, it would be compiled like below. This is the key concept of typia, transforming TypeScript type to a runtime function. The typia.is<T>() function is transformed to a dedicated type checker by analyzing the target type T in the compilation level.This feature enables developers to ensure type safety in their applications, leveraging TypeScript's static typing while also providing runtime validation. Instead of defining additional schemas, you can simply utilize the pure TypeScript type itself.\n//----\n// examples/checkString.ts\n//----\nimport typia, { tags } from \"typia\";\nexport const checkString = typia.createIs<string>();\n//----\n// examples/checkUUID.js\n//----\nimport typia from \"typia\";\nexport const checkString = (() => {\n  return (input) => \"string\" === typeof input;\n})();","key-features#Key Features":"","sponsors#Sponsors":"Thanks for your support.Your donation encourages typia development.Also, typia is re-distributing half of donations to core contributors of typia.\nnonara/ts-patch\nryoppippi/unplugin-typia"}}}