{"/docs/json/parse":{"title":"Guide Documents > JSON < parse() functions","data":{"parse-functions#parse() functions":"export namespace json {\n  export function isParse<T>(input: string): Primitive<T> | null;\n  export function assertParse<T>(input: string): Primitive<T>;\n  export function validateParse<T>(input: string): IValidation<Primitive<T>>;\n}\nType safe JSON parser.Unlike native JSON.parse() function which returns any typed instance without type checking, typia.json.assertParse<T>() function validates instance type after the parsing. If the parsed value is not following the promised type T, it throws TypeGuardError with the first type error info.If you want to know every type error infos detaily, you can use typia.json.validateParse<T>() function instead. Otherwise, you just only want to know whether the parsed value is following the type T or not, just call typia.json.isParse<T>() function.\ntypia.json.isParse<T>(): JSON.parse() + typia.is<T>()\ntypia.json.assertParse<T>(): JSON.parse() + typia.assert<T>()\ntypia.json.validateParse<T>(): JSON.parse() + typia.validate<T>()\nLook at the below code, then you may understand how the typia.json.assertParse<T>() function works.","reusable-functions#Reusable functions":"export namespace json {\n  export function createIsParse<T>(): (input: string) => Primitive<T> | null;\n  export function createAssertParse<T>(): (input: string) => Primitive<T>;\n  export function createValidateParse<T>(): (\n    input: string,\n  ) => IValidation<Primitive<T>>;\n}\nReusable typia.json.isParse<T>() function generators.If you repeat to call typia.json.isParse<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIsParse<T>() function.Just look at the code below, then you may understand how to use it."}},"/docs/json/schema":{"title":"Guide Documents > JSON > Schema","data":{"schemas-function#schemas() function":"export namespace json {\n  export function schemas<\n    Schemas extends unknown[],\n    Version extends \"3.0\" | \"3.1\" = \"3.1\",\n  >(): IJsonSchemaCollection<Version>;\n}\nJSON schema generator.\nDefinitions:\nIJsonSchemaCollection\nOpenAPI v3.0\nOpenAPI v3.1\nWhen you need JSON schema, do not write it by yourself, but just call typia.json.schemas() function.If you call the typia.json.schemas() with specialization of target Schemas, typia will analyze your Schemas and generate JSON schema definition in the compilation level. However, note that, JSON schema definitions of \"OpenAPI v3.0\" and \"OpenAPI v3.1\" are a little bit different. Therefore, you have to consider which value to assign in the Version argument.\nSwagger can't express tuple type\nSwagger can't express pattern property","specialization#Specialization":"You can utilize type tags (or validator's comment tags) to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. Also, there're special comment tags only for JSON schema definition that are different with validator's comment tags like below.\n@deprecated\n@hidden\n@internal\n@title {string}\nLet's see how those type tags, comment tags and description comments are working with example code.","customization#Customization":"If what you want is not just filling regular properties of JSON schema specification, but to adding custom properties into the JSON schema definition, you can do it through the tags.TagBase.schema property type or tags.JsonSchemaPlugin type.For reference, the custom property must be started with x- prefix. It's a rule of JSON schema.","restrictions#Restrictions":"JSON schema does not support bigint type.So if you use bigint type in one of your onetarget schemas, typia will make compile error like below.\nimport typia, { tags } from \"typia\";\ninterface Something {\n  bigint: bigint;\n  array: bigint[];\n  nested: Nested;\n}\ninterface Nested {\n  uint64: bigint & tags.Type<\"uint64\">;\n}\ntypia.json.schemas<[Something]>();\nmain.ts:12:1 - error TS(typia.json.schemas): unsupported type detected\n- Something.bigint: bigint\n  - JSON does not support bigint type.\n- Something.array: bigint\n  - JSON does not support bigint type.\n- Nested.uint64: (bigint & Type<\"uint64\">)\n  - JSON does not support bigint type.\nAlso, if you put any type of native classes like Map or Uint8Array, it would also be error, either. By the way, only Date class is exceptional, and it would be considered as string & Format<\"date-time\"> type like below.\nimport typia from \"typia\";\ninterface Native {\n  date: Date;\n}\ntypia.json.schemas<[Native]>();\nimport typia from \"typia\";\n({\n  version: \"3.1\",\n  components: {\n    schemas: {\n      Native: {\n        type: \"object\",\n        properties: {\n          date: {\n            type: \"string\",\n            format: \"date-time\",\n          },\n        },\n        required: [\"date\"],\n      },\n    },\n  },\n  schemas: [\n    {\n      $ref: \"#/components/schemas/Native\",\n    },\n  ],\n});"}},"/docs/json/stringify":{"title":"Guide Documents > JSON > stringify() function","data":{"stringify-functions#stringify() functions":"export namespace json {\n  export function stringify<T>(input: T): string;\n  export function isStringify<T>(input: T | unknown): string | null;\n  export function assertStringify<T>(input: T | unknown): string;\n  export function validateStringify<T>(input: T | unknown): IValidation<string>;\n}\nYou can boost up JSON serialization speed just by calling typia.json.stringify<T>() function. Also, you even can ensure type safety of JSON serialization by calling other functions like typia.json.isStringify() and typia.json.assertStringify() functions.As typia.json.stringify<T>() function writes dedicated JSON serialization code only for the target type T, its performance is much faster than native JSON.stringify() function. However, because of the dedicated optimal JSON serialization code, when wrong typed data comes, unexpected error be occurred.Instead, typia supports type safe JSON serialization functions like typia.json.isStringify(). The typia.json.isStringify() is a combination function of typia.is<T>() and typia.json.stringify<T>() function. It checks whether the input value is valid for the target type T or not first, and operate JSON serialization later. If the input value is not matched with the type T, it returns null value.\ntypia.json.isStringify(): typia.is<T>() + typia.json.stringify<T>()\ntypia.json.assertStringify(): typia.assert<T>() + typia.json.stringify<T>()\ntypia.json.validateStringify(): typia.validate<T>() + typia.json.stringify<T>()\nAOT compilation\ntypia.json.isStringify() and other similar functions are still much faster than native JSON.stringify() function, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.","reusable-functions#Reusable functions":"export namespace json {\n  export function createStringify<T>(): (input: T) => string;\n  export function createIsStringify<T>(): (input: unknown) => string | null;\n  export function createAssertStringify<T>(\n   errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n  ): (input: unknown) => string; \n  export function createValidateStringify<T>(): (input: unknown) => IValidation<string>;\n}\nReusable typia.json.stringify<T>() function generators.If you repeat to call typia.json.stringify<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.json.createStringify<T>() function.Just look at the code below, then you may understand how to use it.","performance#Performance":"Comparing JSON serialization speed with others, it is maximum 200x faster than class-transformer.For reference, class-transformer is the most famous library used in NestJS with class-validator. Also, fast-json-stringify is another famous one used in fastify. However, whether they are fast or slow, both of them require extra schema definition, that is different with TypeScript type. If you see the code below without experience of them, you may get shocked: how complicate and inefficient they are:\nfast-json-stringify requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13","server-performance#Server Performance":"Someone may ask:\nJSON serialization speed affects on the server performance?I think that the JSON serialization is just a tiny thing in the server side, isn't it?\nMy answer is, \"Yes, it affects on the server performance\".Most operations in NodeJS server are asynchronously executed in background thread, what are called \"event based non-blocking I/O model\". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13"}},"/docs/llm/application":{"title":"Guide Documents > Large Language Model > application() function","data":{"application-function#application() function":"export namespace llm {\n  // LLM FUNCTION CALLING APPLICATION SCHEMA\n  export function application<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplication.IOptions<Model>, \"separate\">>,\n  ): ILlmApplication<Model>;\n  // STRUCTURED OUTPUT\n  export function parameters<\n    Parameters extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(): ILlmSchema.ModelParameters[Model];\n  // TYPE SCHEMA\n  export function schema<\n    T,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    ...$defs: Extract<\n      ILlmSchema.ModelSchema[Model],\n      { $ref: string }\n    > extends never\n      ? []\n      : [Record<string, ILlmSchema.ModelSchema[Model]>]\n  ): ILlmSchema.ModelSchema[Model];\n}\nLLM function calling application schema from a native TypeScript class or interface type.typia.llm.application<App, Model>() is a function composing LLM (Large Language Model) calling application schema from a native TypeScript class or interface type. The function returns an ILlmApplication instance, which is a data structure representing a collection of LLM function calling schemas.If you put LLM function schema instances registered in the ILlmApplication.functions to the LLM provider like OpenAI ChatGPT, the LLM will select a proper function to call with parameter values of the target function in the conversations with the user. This is the \"LLM Function Calling\".You can specify the LLM provide model by the second Model template argument. It's because detailed specification of the function schema is different by the LLM provider model. Here is the list of LLM schema definitions of each model. Determine one of them carefully reading the LLM schema definitions.If you've determined, let's make A.I. Chatbot super-easily with typia.llm.application<App, Model>() function.\nSupported schemas\nIChatGptSchema: OpenAI ChatGPT\nIClaudeSchema: Anthropic Claude\nIGeminiSchema: Google Gemini\nILlamaSchema: Meta Llama\nMidldle layer schemas\nILlmSchemaV3: middle layer based on OpenAPI v3.0 specification\nILlmSchemaV3_1: middle layer based on OpenAPI v3.1 specification\nLLM Function Calling and Structured OutputLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"LLM function calling\" means that LLM automatically selects a proper function and fills parameter values from conversation with the user (may by chatting text).Structured output is another feature of LLM. The \"structured output\" means that LLM automatically transforms the output conversation into a structured data format like JSON.\nhttps://platform.openai.com/docs/guides/function-calling\nhttps://platform.openai.com/docs/guides/structured-outputs\nðŸ’» Playground Link","validation-feedback#Validation Feedback":"Is LLM Function Calling perfect? No, absolutely not.LLM (Large Language Model) service vendor like OpenAI takes a lot of type level mistakes when composing the arguments of function calling or structured output. Even though target schema is super simple like Array<string> type, LLM often fills it just by a string typed value.In my experience, OpenAI gpt-4o-mini (8b parameters) is taking about 70% of type level mistakes when filling the arguments of function calling to Shopping Mall service. To overcome the imperfection of such LLM function calling, typia.llm.application<App, Model>() function embeds typia.validate<T>() function for the validation feedback strategy.The key concept of validation feedback strategy is, let LLM function calling to construct invalid typed arguments first, and informing detailed type errors to the LLM, so that induce LLM to emend the wrong typed arguments at the next turn. In this way, I could uprise the success rate of function calling from 30% to 99% just by one step validation feedback. Even though the LLM is still occurs type error, it always has been caught at the next turn.For reference, the embedded typia.validate<T>() function creates validation logic by analyzing TypeScript source codes and types in the compilation level. Therefore, it is accurate and detailed than any other validator libraries. This is exactly what is needed for function calling, and I can confidentelly say that typia is the best library for LLM function calling.\nAdditionally, this validation feedback strategy is useful for some LLM providers do not supporting restriction properties of JSON schema like OpenAI (IChatGptSchema) and Gemini (IGeminiSchema). For example, OpenAI and Gemini do not support format property of JSON schema, so that cannot understand the UUID like type. Even though typia.llm.application<App, Model>() function is writing the restriction information to the description property of JSON schema, but LLM provider does not reflect it perfectly.Also, some LLM providers which have not specified the JSON schema version like Claude (IClaudeSchema) and Llama (ILlamaSchema), they tend to fail a lot of function calling about the restriction properties. In fact, Llama does not support function calling formally, so you have to detour it by prompt template, and its success rate is lower than others.In that case, if you give validation feedback from ILlmFunction.validate() function to the LLM agent, the LLM agent will be able to understand the restriction information exactly and fill the arguments properly.\nRestriction properties of JSON schema\nstring: minLength, maxLength, pattern, format, contentMediaType\nnumber: minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf\narray: minItems, maxItems, uniqueItems, items","parameters-separation#Parameters' Separation":"Parameter values from both LLM and Human sides.When composing parameter arguments through the LLM (Large Language Model) function calling, there can be a case that some parameters (or nested properties) must be composed not by LLM, but by Human. File uploading feature, or sensitive information like secret key (password) cases are the representative examples.In that case, you can configure the LLM function calling schemas to exclude such Human side parameters (or nested properties) by ILlmApplication.options.separate property. Instead, you have to merge both Human and LLM composed parameters into one by calling the HttpLlm.mergeParameters() before the LLM function call execution.Here is the example separating the parameter schemas.\nðŸ’» Playground Link","restrictions#Restrictions":"typia.llm.application<App, Model>() follows the same restrictions of below.About the function parameters type, it follows the restriction of both typia.llm.parameters<Params, Models>() and typia.llm.schema<T, Model>() functions. Therefore, the parameters must be a keyworded object type with static keys without any dynamic keys. Also, the object type must not be nullable or optional.About the return value type, it follows the restriction of typia.llm.schema<T, Model>() function. By the way, if the return type is union type with undefined, it would be compilation error, due to OpenAPI (JSON schema) specification does not support the undefindable union type.\ntypia.llm.parameters<Params, Models>()\ntypia.llm.schema<T, Model>()\nimport { ILlmApplication } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\"\n>();\nconsole.log(app);\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle | undefined>;\n  erase(id: string & tags.Format<\"uuid\">): Promise<void>;\n}\nsrc/examples/llm.application.violation.ts:4:41 - error TS(typia.llm.application): unsupported type detected    \n- BbsArticleController.create: unknown\n  - LLM application's function (\"create\")'s return type must not be union type with undefined.    \n- BbsArticleController.erase: unknown\n  - LLM application's function (\"erase\")'s parameter must be an object type.\n4 const app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n                                          ~~~~~~~~~~~~~~~~~~~~~~\n5   BbsArticleController,\n  ~~~~~~~~~~~~~~~~~~~~~~~\n6   \"chatgpt\"\n  ~~~~~~~~~~~\n7 >();\n  ~~~\nFound 1 error in src/examples/llm.application.violation.ts:4"}},"/docs/llm/parameters":{"title":"Guide Documents > Large Language Model > parameters() function","data":{"parameters-function#parameters() function":"export namespace llm {\n  // LLM FUNCTION CALLING APPLICATION SCHEMA\n  export function application<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplication.IOptions<Model>, \"separate\">>,\n  ): ILlmApplication<Model>;\n  // STRUCTURED OUTPUT\n  export function parameters<\n    Parameters extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(): ILlmSchema.ModelParameters[Model];\n  // TYPE SCHEMA\n  export function schema<\n    T,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    ...$defs: Extract<\n      ILlmSchema.ModelSchema[Model],\n      { $ref: string }\n    > extends never\n      ? []\n      : [Record<string, ILlmSchema.ModelSchema[Model]>]\n  ): ILlmSchema.ModelSchema[Model];\n}\nStructured output schema of LLM (Large Language Model).typia.llm.parameters<Parameters, Model>() is a function generating structured output of LLM (Large Language Model) from a TypeScript object type. It is used to LLM function calling or structured output feature provided by OpenAI like LLM providers.Return value type ILlmSchema.IParameters is a similar with the JSON schema definition's object type. However, its detailed specification becomes different by LLM provider model you've chosen. Here is the list of LLM schema definitions of each model. Determine one of them carefully reading the LLM schema definitions.\nSupported schemas\nIChatGptSchema: OpenAI ChatGPT\nIClaudeSchema: Anthropic Claude\nIGeminiSchema: Google Gemini\nILlamaSchema: Meta Llama\nMidldle layer schemas\nILlmSchemaV3: middle layer based on OpenAPI v3.0 specification\nILlmSchemaV3_1: middle layer based on OpenAPI v3.1 specification\nLLM Function Calling and Structured OutputLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"LLM function calling\" means that LLM automatically selects a proper function and fills parameter values from conversation with the user (may by chatting text).Structured output is another feature of LLM. The \"structured output\" means that LLM automatically transforms the output conversation into a structured data format like JSON.\nhttps://platform.openai.com/docs/guides/function-calling\nhttps://platform.openai.com/docs/guides/structured-outputs\nðŸ“– Playground Link","structured-output#Structured Output":"import OpenAI from \"openai\";\nimport typia, { tags } from \"typia\";\ninterface IMember {\n  email: string & tags.Format<\"email\">;\n  name: string;\n  age: number;\n  hobbies: string[];\n  joined_at: string & tags.Format<\"date\">;\n}\nconst main = async (): Promise<void> => {\n  const client: OpenAI = new OpenAI({\n    apiKey: TestGlobal.env.CHATGPT_API_KEY,\n    // apiKey: \"<YOUR_OPENAI_API_KEY>\",\n  });\n  const completion: OpenAI.ChatCompletion =\n    await client.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            \"I am a new member of the community.\",\n            \"\",\n            \"My name is John Doe, and I am 25 years old.\",\n            \"I like playing basketball and reading books,\",\n            \"and joined to this community at 2022-01-01.\",\n          ].join(\"\\n\"),\n        },\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"member\",\n          schema: typia.llm.parameters<IMember, \"chatgpt\">() as any,\n        },\n      },\n    });\n  console.log(JSON.parse(completion.choices[0].message.content!));\n};\nmain().catch(console.error);\n{\n  email: 'john.doe@example.com',\n  name: 'John Doe',\n  age: 25,\n  hobbies: [ 'playing basketball', 'reading books' ],\n  joined_at: '2022-01-01'\n}\nYou can utilize the typia.llm.parameters<Parameters, Model>() function to generate structured output like above.Just configure output mode as JSON schema, and deliver the typia.llm.parameters<Parameters, Model>() function returned value to the LLM provider like OpenAI (ChatGPT). Then, the LLM provider will automatically transform the output conversation into a structured data format of the Parameters type.","validation-feedback#Validation Feedback":"import OpenAI from \"openai\";\nimport typia, { IValidation, tags } from \"typia\";\ninterface IMember {\n  email: string & tags.Format<\"email\">;\n  name: string;\n  age: number;\n  hobbies: string[];\n  joined_at: string & tags.Format<\"date\">;\n}\nconst step = async (\n  failure?: IValidation.IFailure | undefined,\n): Promise<IValidation<IMember>> => {\n  const client: OpenAI = new OpenAI({\n    apiKey: \"<YOUR_OPENAI_API_KEY>\",\n  });\n  const completion: OpenAI.ChatCompletion =\n    await client.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            \"I am a new member of the community.\",\n            \"\",\n            \"My name is John Doe, and I am 25 years old.\",\n            \"I like playing basketball and reading books,\",\n            \"and joined to this community at 2022-01-01.\",\n          ].join(\"\\n\"),\n        },\n        ...(failure\n          ? [\n              {\n                role: \"system\",\n                content: [\n                  \"You A.I. agent had taken a mistak that\",\n                  \"returning wrong typed structured data.\",\n                  \"\",\n                  \"Here is the detailed list of type errors.\",\n                  \"Review and correct them at the next step.\",\n                  \"\",\n                  \"```json\",\n                  JSON.stringify(failure.errors, null, 2),\n                  \"```\",\n                ].join(\"\\n\"),\n              } satisfies OpenAI.ChatCompletionSystemMessageParam,\n            ]\n          : []),\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"member\",\n          schema: typia.llm.parameters<IMember, \"chatgpt\">() as any,\n        },\n      },\n    });\n  const member: IMember = JSON.parse(completion.choices[0].message.content!);\n  return typia.validate(member);\n};\nconst main = async (): Promise<void> => {\n  let result: IValidation<IMember> | undefined = undefined;\n  for (let i: number = 0; i < 2; ++i) {\n    if (result && result.success === true) break;\n    result = await step(result);\n  }\n  console.log(result);\n};\nmain().catch(console.error);\n{\n  email: 'john.doe@example.com',\n  name: 'John Doe',\n  age: 25,\n  hobbies: [ 'playing basketball', 'reading books' ],\n  joined_at: '2022-01-01'\n}\nIs LLM Structured Output perfect? No, absolutely not.LLM (Large Language Model) service vendor like OpenAI takes a lot of type level mistakes when composing the arguments of function calling or structured output. Even though target schema is super simple like Array<string> type, LLM often fills it just by a string typed value.In my experience, OpenAI gpt-4o-mini (8b parameters) is taking about 70% of type level mistakes when filling the arguments of structured output to Shopping Mall service. To overcome the imperfection of such structured output, you have to utilize the validation feedback strategy with typia.validate<T>() function.The key concept of validation feedback strategy is, let LLM structured output to construct invalid typed arguments first, and informing detailed type errors to the LLM, so that induce LLM to emend the wrong typed arguments at the next turn. In this way, I could uprise the success rate of structured output from 30% to 99% just by one step validation feedback. Even though the LLM is still occurs type error, it always has been caught at the next turn.For reference, the typia.validate<T>() function creates validation logic by analyzing TypeScript source codes and types in the compilation level. Therefore, it is accurate and detailed than any other validator libraries. This is exactly what is needed for function calling, and I can confidentelly say that typia is the best library for LLM structured output.\nAdditionally, this validation feedback strategy is useful for some LLM providers do not supporting restriction properties of JSON schema like OpenAI (IChatGptSchema) and Gemini (IGeminiSchema). For example, OpenAI and Gemini do not support format property of JSON schema, so that cannot understand the UUID like type. Even though typia.llm.application<App, Model>() function is writing the restriction information to the description property of JSON schema, but LLM provider does not reflect it perfectly.Also, some LLM providers which have not specified the JSON schema version like Claude (IClaudeSchema) and Llama (ILlamaSchema), they tend to fail a lot of function calling about the restriction properties. In fact, Llama does not support the structured output formally, so you have to detour it by prompt template, and its success rate is lower than others.In that case, if you give validation feedback from ILlmFunction.validate() function to the LLM agent, the LLM agent will be able to understand the restriction information exactly and fill the arguments properly.\nRestriction properties of JSON schema\nstring: minLength, maxLength, pattern, format, contentMediaType\nnumber: minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf\narray: minItems, maxItems, uniqueItems, items","restrictions#Restrictions":"typia.llm.parameters<Parameters, Model>() follows the same restrictions typia.llm.schema<T, Model>() function. Also, it has only one additional restriction; the keyworded argument.In the LLM function calling and structured output, the parameters must be a keyworded object type with static keys without any dynamic keys. Also, the object type must not be nullable or optional.If you don't follow the LLM's keyworded arguments rule, typia.llm.parameters<Parameters, Model>() will throw compilation error like below.\nimport typia from \"typia\";\ntypia.llm.parameters<string>();\ntypia.llm.parameters<Record<string, boolean>, \"chatgpt\">();\ntypia.llm.parameters<Array<number>>();\nsrc/examples/llm.parameters.violation.ts:3:1 - error TS(typia.llm.parameters): unsupported type detected       \n- string\n  - LLM parameters must be an object type.        \n3 typia.llm.parameters<string, \"chatgpt\">();     \n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      \nsrc/examples/llm.parameters.violation.ts:3:22 - error TS2344: Type 'string' does not satisfy the constraint 'Record<string, any>'.\n3 typia.llm.parameters<string, \"chatgpt\">();     \n                       ~~~~~~\nsrc/examples/llm.parameters.violation.ts:4:1 - error TS(typia.llm.parameters): unsupported type detected       \n- Recordstringboolean\n  - LLM parameters must be an object type.        \n- Recordstringboolean\n  - LLM parameters must not have dynamic keys.   \n  - LLM schema of \"gemini\" does not support dynamic property in object.\n- Recordstringboolean: Recordstringboolean       \n  - LLM schema of \"gemini\" does not support dynamic property in object.\n4 typia.llm.parameters<Record<string, boolean>, \"gemini\">();\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/examples/llm.parameters.violation.ts:5:1 - error TS(typia.llm.parameters): unsupported type detected       \n- Arraynumber\n  - LLM parameters must be an object type.        \n5 typia.llm.parameters<Array<number>, \"claude\">();\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nFound 4 errors in the same file, starting at: src/examples/llm.parameters.violation.ts"}},"/docs/llm/schema":{"title":"Guide Documents > Large Language Model > schema() function","data":{"schema-function#schema() function":"export namespace llm {\n  // LLM FUNCTION CALLING APPLICATION SCHEMA\n  export function application<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplication.IOptions<Model>, \"separate\">>,\n  ): ILlmApplication<Model>;\n  // STRUCTURED OUTPUT\n  export function parameters<\n    Parameters extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(): ILlmSchema.ModelParameters[Model];\n  // TYPE SCHEMA\n  export function schema<\n    T,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    ...$defs: Extract<\n      ILlmSchema.ModelSchema[Model],\n      { $ref: string }\n    > extends never\n      ? []\n      : [Record<string, ILlmSchema.ModelSchema[Model]>]\n  ): ILlmSchema.ModelSchema[Model];\n}\nType schema in the LLM function calling application.typia.llm.schema<T, Model>() is a function generating type schema which is used in the LLM (Large Language Model) function calling application schema or structured output, especially composed by the typia.llm.parameters<Parameters, Model>() and typia.llm.application<App, Model>() functions.Return value type ILlmSchema is similar with the JSON schema definition. However, its detailed specification becomes different by the LLM provider model you've chosen. Here is the list of LLM schema definitions of each model. Determine one of them carefully reading the LLM schema definitions.\nSupported schemas\nIChatGptSchema: OpenAI ChatGPT\nIClaudeSchema: Anthropic Claude\nIGeminiSchema: Google Gemini\nILlamaSchema: Meta Llama\nMidldle layer schemas\nILlmSchemaV3: middle layer based on OpenAPI v3.0 specification\nILlmSchemaV3_1: middle layer based on OpenAPI v3.1 specification\nLLM Function Calling and Structured OutputLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"LLM function calling\" means that LLM automatically selects a proper function and fills parameter values from conversation with the user (may by chatting text).Structured output is another feature of LLM. The \"structured output\" means that LLM automatically transforms the output conversation into a structured data format like JSON.\nhttps://platform.openai.com/docs/guides/function-calling\nhttps://platform.openai.com/docs/guides/structured-outputs","specialization#Specialization":"You can utilize type tags (or validator's comment tags) to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. Also, there're special comment tags only for JSON schema definition that are different with validator's comment tags like below.\n@deprecated\n@hidden\n@internal\n@title {string}\nLet's see how those type tags, comment tags and description comments are working with example code.","customziation#Customziation":"If what you want is not just filling regular properties of LLM schema specification, but to adding custom properties into the JSON schema definition, you can do it through the tags.TagBase.schema property type or tags.JsonSchemaPlugin type.For reference, the custom property must be started with x- prefix. It's a rule of LLM schema.","restrictions#Restrictions":"LLM schema does not support bigint type.LLM schema is based on the JSON schema definition of the OpenAPI v3.0 specification. Therefore, limitations of the JSON schema is also applied to the LLM schema, and the bigint type is not supported in the LLM function calling schema composition.Also, LLM schema does not support the tuple type, which is represented by the OpenApi.IJsonSchema.ITuple type. It's no LLM providers are supporting the tuple type, and such tuple type harms the separation option of the typia.llm.application<App, Model>() function. If you need a tuple type, just change the tuple type to a regular object type instead.\nimport typia from \"typia\";\ntypia.llm.schema<bigint, \"chatgpt\">({});\ntypia.llm.schema<[number, string], \"claude\">({});\nsrc/examples/llm.schema.bigint-and-tuple.ts:3:1 - error TS(typia.llm.schema): unsupported type detected\n- bigint\n  - LLM schema does not support bigint type.\n3 typia.llm.schema<bigint, \"chatgpt\">({});\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/examples/llm.schema.bigint-and-tuple.ts:4:1 - error TS(typia.llm.schema): failed to convert JSON schema to LLM schema.\n  - $input.schema: LLM does not allow tuple type.\n4 typia.llm.schema<[number, string], \"claude\">({});\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIf you're using Google Gemini (IGeminiSchema) or middle layer schema of ILlmSchemaV3, they do not support the reference type that is embodied by the OpenApi.IJsonSchema.IReference type with $ref property. Therefore, if recursive type comes, no way to express it perfectly in those IGeminiSchema and ILlmSchemaV3. They just repeat the recursive structure 3 times, and remove the recursive type after the 4 depths.For reference, if the recursive type comes from the array type, it would be zero length array type at the fourth step. Otherwise the recursive type comes from a property and the property is optional, the 4th property would be removed from the object type. At last, if the recursive type is combined as an oneOf type, the type would be removed from there.\nAnd OpenAI ChatGPT (IChatGptSchema) and Google Gemini (IGeminiSchema) do not support the OpenApi.IJsonSchema.IObject.additionalProperties type, which represent the dynamic key typed object like Record<string, T> type in the TypeScript. Therefore, if you put the dynamic Record<string, T> type like below, typia.llm.schema<T, \"chatgpt\">() and typia.llm.schema<T, \"gemini\"> functions throw the compilation error like below.Therefore, if you want to utilzie OpenAI hatGPT (IChatGptSchema) or Google Gemini (IGeminiSchema), you have to change the Record<string, T> type to an array of regular object type like below. Note that, as LLM providers do not support the tuple type, you don't have to define the array type containing the tuple type.\nrecommended: Array<{ key: string, value: T }>\nnot recommended: Array<[string, T]>\nimport typia from \"typia\";\ntypia.llm.schema<Record<string, number>, \"chatgpt\">({});\ntypia.llm.schema<Record<string, number>, \"gemini\">();\nsrc/examples/llm.schema.additionalProperties.ts:3:1 - error TS(typia.llm.schema): unsupported type detected\n- Recordstringnumber\n  - LLM schema of \"chatgpt\" does not support dynamic property in object.  \n- Recordstringnumber: Recordstringnumber\n  - LLM schema of \"chatgpt\" does not support dynamic property in object.  \n3 typia.llm.schema<Record<string, number>, \"chatgpt\">({});\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/examples/llm.schema.additionalProperties.ts:4:1 - error TS(typia.llm.schema): unsupported type detected\n- Recordstringnumber\n  - LLM schema of \"gemini\" does not support dynamic property in object.   \n- Recordstringnumber: Recordstringnumber\n  - LLM schema of \"gemini\" does not support dynamic property in object.   \n4 typia.llm.schema<Record<string, number>, \"gemini\">();\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"}},"/docs/llm/strategy":{"title":"Guide Documents > Large Language Model > Documentation Strategy","data":{"description-comment#Description Comment":"Create a new article.\nWrites a new article and archives it into the DB.\nHere is the example code utilizing the typia.llm.application<App, Model>() function.As you can see, above example code is writing detailed descriptions for every functions and their parameter/return types. Such detailed descriptions are very important to teach the purpose of the function to the LLM (Language Large Model), and LLM actually determines which function to call by the description. Therefore, donâ€™t forget to writing detailed descriptions. Itâ€™s very import feature for the LLM function calling.Also, ILlmFunction type which has only description property about the comment, but ILlmSchema has two descriptive properties; description and title. The title property of the ILlmSchema can be filled by two ways. The first way is closing the first line of the description comment with a period (.). By the way, this way's description property would be the entire description comment even including the first line.If you don't want that, you can adapt the second way that writing @title {string} comment tag. In that case, the title value would not be contained in the description value. For reference, it is possible to fill the description property of the ILlmSchema by the comment tag @description, but you have to take care of the indentation like below.","namespace-strategy#Namespace Strategy":"Information of the article to create.\n------------------------------\nDescription of the current {@link IBbsArticle.ICreate} type:\nInformation of the article to create.\n> Description of the parent {@link IBbsArticle} type: Article entity.\n> \n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\ntypia.llm.application<App, Model>() copies the parent namespaced type description comment to the children types. typia calls this comment writing strategy as namespace documentation, and it is recommended for the efficient documentation.As you can see from the above example, BbsArticleController has many CRUD functions about the IBbsArticle namespaced type. By the way, the above IBbsArticle.ICreate and IBbsArticle.IUpdate types are not repeating same description comments about the IBbsArticle type. Instead, just writing the short description comment about them, and just compose the LLM function calling application schema.In that case, the IBbsArticle type's description comment would be copied to the IBbsArticle.ICreate and IBbsArticle.IUpdate types like above \"Console Output\" case. It's a good strategy to avoid repeating same description comments, and also to deliver enough information to the LLM function calling.","function-hiding#Function Hiding":"Hiding some functions by comment tag.If you write @hidden, @human or @internal tag onto a function description comment, the function would not participate in the LLM (Large Language Model) function calling application composition. ILlmFunction schema does not be generated in the ILlmApplication.functions collection.It's a good feature to hide some internal functions, so that avoiding the LLM function calling.","specialization#Specialization":"You can utilize type tags (or validator's comment tags) to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. Also, there're special comment tags only for JSON schema definition that are different with validator's comment tags like below.\n@deprecated\n@hidden\n@internal\n@title {string}\nLet's see how those type tags, comment tags and description comments are working with example code.","customization#Customization":"If what you want is not just filling regular properties of LLM schema specification, but to adding custom properties into the JSON schema definition, you can do it through the tags.TagBase.schema property type or tags.JsonSchemaPlugin type.For reference, the custom property must be started with x- prefix. It's a rule of LLM schema."}},"/docs/misc":{"title":"Guide Documents > Miscellaneous","data":{"misc-module#misc module":"","clone-functions#clone() functions":"export namespace misc {\n  export function clone<T>(input: T): T;\n  export function assertClone<T>(input: T | unknown): Resolved<T>;\n  export function isClone<T>(input: T | unknown): Resolved<T> | null;\n  export function validateClone<T>(input: T | unknown): IValidation<Resolved<T>>;\n  export function createClone<T>(): (input: T) => Resolved<T>;\n  export function createAssertClone<T>(): (input: T | unknown) => Resolved<T>;\n  export function createIsClone<T>(): (input: T | unknown) => Resolved<T> | null;\n  export function createValidateClone<T>(): (\n      input: T | unknown\n  ) => IValidation<Resolved<T>>;\n}\nDeep copy functions.When you want to copy an instance, just call typia.misc.clone() function. It would perform deep copy including nested objects, so you can get a new instance with same values. Also, if you want type safe deep copy function, you can use typia.misc.isClone(), typia.misc.assertClone() or typia.misc.validateClone() functions instead.\ntypia.misc.assertClone(): typia.assert<T>() + typia.misc.clone<T>()\ntypia.misc.isClone(): typia.is<T>() + typia.misc.clone<T>()\ntypia.misc.validateClone(): typia.validate<T>() + typia.misc.clone<T>()","prune-functions#prune() functions":"export function prune<T>(input: T): void;\nexport function assertPrune<T>(input: T | unknown): T;\nexport function isPrune<T>(input: T | unknown): T | null;\nexport function validatePrune<T>(input: T | unknown): IValidation<T>;\nexport function createPrune<T>(): (input: T) => void;\nexport function createAssertPrune<T>(): (input: T | unknown) => T;\nexport function createIsPrune<T>(): (input: T | unknown) => T | null;\nexport function createValidatePrune<T>(): (input: T | unknown) => IValidation<T>;\nDeep prune functions.When you want to remove every extra properties that are not defined in the type including nested objects, you can use typia.misc.prune<T>() function. Also, if you want to perform type safe pruning, you can use typia.misc.isPrune<T>(), typia.misc.assertPrune<T>() or typia.misc.validatePrune<T>() functions instead.\ntypia.misc.isPrune(): typia.is<T>() + typia.misc.prune<T>()\ntypia.misc.assertPrune(): typia.assert<T>() + typia.misc.prune<T>()\ntypia.misc.validatePrune(): typia.validate<T>() + typia.misc.prune<T>()","literals-function#literals() function":"export namespace misc {\n  export function literals<\n    T extends boolean | number | string | bigint | null,\n  >(): T[];\n}\nUnion literal type to array.When you call typia.misc.literals<T>() function with union literal type, it returns an array of literal values listed in the generic T argument. This typia.misc.literals<T> function is useful when you are developing test program, especially handling some discriminated union types.","notations-module#notations module":"","camel-functions#camel() functions":"export namespace notations {\n  export function camel<T>(input: T): CamelCase<T>;\n  export function assertCamel<T>(input: T | unknown): CamelCase<T>;\n  export function isCamel<T>(input: T | unknown): CamelCase<T> | null;\n  export function validateCamel<T>(\n    input: T | unknown,\n  ): IValidation<CamelCase<T>>;\n  export function createCamel<T>(): (input: T) => CamelCase<T>;\n  export function createAssertCamel<T>(): (input: T | unknown) => CamelCase<T>;\n  export function createIsCamel<T>(): (\n    input: T | unknown,\n  ) => CamelCase<T> | null;\n  export function createValidateCamel<T>(): (\n    input: T | unknown,\n  ) => IValidation<CamelCase<T>>;\n}\nCamel case converters.Convert every property names of nested objects to be camel case notation.When you need type safe functions, you can utilize below them.\ntypia.notations.assertCamel<T>(): typia.assert<T>() + typia.notations.camel<T>()\ntypia.notations.isCamel<T>: typia.is<T>() + typia.notations.camel<T>()\ntypia.notations.validateCamel<T>: typia.validate<T>() + typia.notations.camel<T>()","pascal-functions#pascal() functions":"export namespace notations {\n  export function pascal<T>(input: T): PascalCase<T>;\n  export function assertPascal<T>(input: T | unknown): PascalCase<T>;\n  export function isPascal<T>(input: T | unknown): PascalCase<T> | null;\n  export function validatePascal<T>(\n    input: T | unknown,\n  ): IValidation<PascalCase<T>>;\n  export function createPascal<T>(): (input: T) => PascalCase<T>;\n  export function createAssertPascal<T>(): (\n    input: T | unknown,\n  ) => PascalCase<T>;\n  export function createIsPascal<T>(): (\n    input: T | unknown,\n  ) => PascalCase<T> | null;\n  export function createValidatePascal<T>(): (\n    input: T | unknown,\n  ) => IValidation<PascalCase<T>>;\n}\nPascal case converters.Convert every property names of nested objects to be pascal case notation.When you need type safe functions, you can utilize below them.\ntypia.notations.assertPascal<T>(): typia.assert<T>() + typia.notations.pascal<T>()\ntypia.notations.isPascal<T>: typia.is<T>() + typia.notations.pascal<T>()\ntypia.notations.validatePascal<T>: typia.validate<T>() + typia.notations.pascal<T>()","snake-functions#snake() functions":"export namespace notations {\n  export function snake<T>(input: T): SnakeCase<T>;\n  export function assertSnake<T>(input: T | unknown): SnakeCase<T>;\n  export function isSnake<T>(input: T | unknown): SnakeCase<T> | null;\n  export function validateSnake<T>(\n    input: T | unknown,\n  ): IValidation<SnakeCase<T>>;\n  export function createSnake<T>(): (input: T) => SnakeCase<T>;\n  export function createAssertSnake<T>(): (input: T | unknown) => SnakeCase<T>;\n  export function createIsSnake<T>(): (\n    input: T | unknown,\n  ) => SnakeCase<T> | null;\n  export function createValidateSnake<T>(): (\n    input: T | unknown,\n  ) => IValidation<SnakeCase<T>>;\n}\nSnake case converters.Convert every property names of nested objects to be snake case notation.When you need type safe functions, you can utilize below them.\ntypia.notations.assertSnake<T>(): typia.assert<T>() + typia.notations.snake<T>()\ntypia.notations.isSnake<T>: typia.is<T>() + typia.notations.snake<T>()\ntypia.notations.validateSnake<T>: typia.validate<T>() + typia.notations.snake<T>()","http-module#http module":"Nestia Supporting\nhttp module has been designed to support the nestia project.\nquery() functions -> @TypedQuery()\nheaders() functions -> @TypedHeaders()\nparameter() function -> @TypedParam()","query-functions#query() functions":"export namespace http {\n  export function query<T extends object>(input: Query): Resolved<T>;\n  export function assertQuery<T extends object>(input: Query): Resolved<T>;\n  export function isQuery<T extends object>(input: Query): Resolved<T> | null;\n  export function validateQuery<T extends object>(\n    input: Query,\n  ): IValidation<Resolved<T>>;\n  export function createQuery<T extends object>(): (\n    input: Query,\n  ) => Resolved<T>;\n  export function createAssertQuery<T extends object>(): (\n    input: Query,\n  ) => Resolved<T>;\n  export function createIsQuery<T extends object>(): (\n    input: Query,\n  ) => Resolved<T> | null;\n  export function createValidateQuery<T extends object>(): (\n    input: Query,\n  ) => IValidation<Resolved<T>>;\n}\ntype Query = string | URLSearchParams;\nURL query decoder functions.typia.http.query<T>() is a function decoding a query string or an URLSearchParams instance, with automatic type casting to the expected type. When property type be defined as boolean or number type, typia.http.query<T>() will cast the value to the expected type when decoding.By the way, as URL query is not enough to express complex data structures, typia.http.query<T>() function has some limitations. If target type T is not following those restrictions, compilation errors would be occurred.\nType T must be an object type\nDo not allow dynamic property\nOnly boolean, bigint, number, string or their array types are allowed\nBy the way, union type never be not allowed\nAlso, typia.http.query<T>() function does not perform validation about the decoded value. Therefore, if you can't sure that input data is following the T type, it would better to call one of below functions instead.\ntypia.http.assertQuery<T>(): typia.assert<T>() + typia.http.query<T>()\ntypia.http.isQuery<T>(): typia.is<T>() + typia.http.query<T>()\ntypia.http.validateQuery<T>(): typia.validate<T>() + typia.http.query<T>()","headers-functions#headers() functions":"export namespace http {\n  export function headers<T extends object>(input: Headers): Resolved<T>;\n  export function assertHeaders<T extends object>(input: Headers): Resolved<T>;\n  export function isHeaders<T extends object>(\n    input: Headers,\n  ): Resolved<T> | null;\n  export function validateHeaders<T extends object>(\n    input: Headers,\n  ): IValidation<Resolved<T>>;\n  export function createHeaders<T extends object>(): (\n    input: Headers,\n  ) => Resolved<T>;\n  export function createAssertHeaders<T extends object>(): (\n    input: Headers,\n  ) => Resolved<T>;\n  export function createIsHeaders<T extends object>(): (\n    input: Headers,\n  ) => Resolved<T> | null;\n  export function createValidateHeaders<T extends object>(): (\n    input: Headers,\n  ) => IValidation<Resolved<T>>;\n}\ntype Headers = Record<string, string | string[] | undefined>;\nHeaders decoder (for express and fastify).typia.http.headers<t>() is a function decoding an header instance, with automatic type casting to the expected type. When property type be defined as boolean or number type, typia.http.headers<t>() will cast the value to the expected type.By the way, as HTTP headers are not enough to express complex data structures, typia.http.headers<t>() function has some limitations. If target type T is not following those restrictions, compilation errors would be occurred.\nType T must be an object type\nDo not allow dynamic property\nProperty key must be lower case\nProperty value cannot be null, but undefined is possible\nOnly boolean, bigint, number, string or their array types are allowed\nBy the way, union type never be not allowed\nProperty set-cookie must be array type\nThose properties cannot be array type\nage\nauthorization\ncontent-length\ncontent-type\netag\nexpires\nfrom\nhost\nif-modified-since\nif-unmodified-since\nlast-modified\nlocation\nmax-forwards\nproxy-authorization\nreferer\nretry-after\nserver\nuser-agent\nAlso, typia.http.headers<t>() function does not perform validation about the decoded value. Therefore, if you can't sure that input data is following the T type, it would better to call one of below functions instead.\ntypia.http.assertHeaders<T>(): typia.assert<T>() + typia.http.headers<T>()\ntypia.http.isHeaders<T>(): typia.is<T>() + typia.http.headers<T>()\ntypia.http.validateHeaders<T>(): typia.validate<T>() + typia.http.headers<T>()","parameter-functions#parameter() functions":"export namespace http {\n  export function parameter<T extends Atomic.Type | null>(input: string): T;\n  export function createParameter<T extends Atomic.Type | null>(): (\n    input: string,\n  ) => T;\n}\nURL path parameter decoder.typia.http.parameter<T>() is a function decoding a path parameter, with automatic type casting to the expected type. When type T has been defined as boolean or number type, typia.http.parameter<T>() will cast the value to the expected type.Also, typia.http.parameter<T>() performs type assertion to the decoded value by combining with assert function. Therefore, when the decoded value is not following the T type, TypeGuardError would be thrown."}},"/docs/protobuf/decode":{"title":"Guide Documents > Protobuf > decode() functions","data":{"decode-functions#decode() functions":"export namespace protobuf {\n  export function decode<T>(buffer: Uint8Array): Resolved<T>;\n  export function isDecode<T>(buffer: Uint8Array): Resolved<T> | null;\n  export function assertDecode<T>(buffer: Uint8Array): Resolved<T>;\n  export function validateDecode<T>(\n    buffer: Uint8Array,\n  ): IValidation<Resolved<T>>;\n}\nProtocol Buffer Decoder.You can easily convert a Protocol Buffer's binary data to a JavaScript object, without any extra Protocol Buffer Message Schema definition. typia.protobuf.decode<T>() function analyzes your type T, and generates a Protocol Buffer Message Schema internally.And then, it converts the binary data to a JavaScript object.By the way, as Protocol Buffer handles binary data directly, there's no way when input binary data was not encoded from the T typed value. In that case, unexpected behavior or internal error would be occurred. Therefore, I recommend you to encode binary data of Protocol Buffer from type safe encode functions like below, Use typia.protobuf.encode<T>() function only when you can trust it.\ntypia.protobuf.isEncode<T>()\ntypia.protobuf.assertEncode<T>()\ntypia.protobuf.validateEncode<T>()\nFor reference, typia provides type safe decorators like below, but they are just for additional type validation like number & Minimum<7> or string & Format<\"uuid\"> cases, that are represented by Special Tags. Thus, I repeat that, you've to ensure type safety when using decoder function.\ntypia.protobuf.isDecode<T>(): typia.is<T>() + typia.protobuf.decode<T>()\ntypia.protobuf.assertDecode<T>(): typia.assert<T>() + typia.protobuf.decode<T>()\ntypia.protobuf.validateDecode<T>(): typia.validate<T>() + typia.protobuf.decode<T>()\nAOT compilation\ntypia.protobuf.decode<T>() and other similar functions are still much faster than any other competitive libraries, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.","reusable-functions#Reusable functions":"export namespace protobuf {\n  export function createDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\n  export function createIsDecode<T>: (buffer: Uint8Array) => Resolved<T> | null;\n  export function createAssertDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\n  export function createValidateDecode<T>(): (\n      buffer: Uint8Array\n  ) => IValidation<Resolved<T>>;\n}\nReusable typia.protobuf.decode<T>() function generators.If you repeat to call typia.protobuf.decode<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.protobuf.createDecode<T>() function.Just look at the code below, then you may understand how to use it.","references#References":"Protocol Buffer supports special numeric types like int32 or uint64 that are not supported in TypeScript. Also, types of Protocol Buffer cannot fully meet TypeScript type specs either, as expression power of TypeScript types are much stronger than Protocol Buffer.To know how to define special numeric types like uint64, and to understand which TypeScript types are not supported in Protocol Buffer specs, it would better to read below documents. I recommend you to read them before using typia.protobuf.decode<T>() related functions.\nTypia Guide Documents > Protocol Buffer > Message Schema\nmessage() function\nType Tags\nComment Tags\nRestrictions"}},"/docs/protobuf/encode":{"title":"Guide Documents > Protobuf > encode() functions","data":{"encode-functions#encode() functions":"export namespace protobuf {\n  export function encode<T>(input: T): Uint8Array;\n  export function isEncode<T>(input: T): Uint8Array | null;\n  export function assertEncode<T>(input: T): Uint8Array;\n  export function validateEncode<T>(input: T): IValidation<Uint8Array>;\n}\nProtocol Buffer Encoder.You can easily convert a JavaScript object to a binary data of Protocol Buffer, without any extra Protocol Buffer Message Schema definition. typia.protobuf.encode<T>() function analyzes your type T, and generates a Protocol Buffer Message Schema internally. And then, it converts the input instance to the binary data of Protocol Buffer format.By the way, typia.protobuf.encode<T>() function does not validate the input value. It just believes user and input value, and converts to the Protocol Buffer binary data directly without any validation. By the way, if the input value was not validate, the encoded binary data never can be decoded. So, if you can't sure the input value type, you should use below functions instead.\ntypia.protobuf.isEncode<T>(): typia.is<T>() + typia.protobuf.encode<T>()\ntypia.protobuf.assertEncode<T>(): typia.assert<T>() + typia.protobuf.encode<T>()\ntypia.protobuf.validateEncode<T>(): typia.validate<T>() + typia.protobuf.encode<T>()\nAOT compilation\ntypia.protobuf.encode<T>() and other similar functions are still much faster than any other competitive libraries, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.","reusable-functions#Reusable Functions":"export namespace protobuf {\n  export function encode<T>(): (input: T) => Uint8Array;\n  export function isEncode<T>(): (input: T) => Uint8Array | null;\n  export function assertEncode<T>(): (input: T) => Uint8Array;\n  export function validateEncode<T>(): (input: T) => IValidation<Uint8Array>;\n}\nReusable typia.protobuf.encode<T>() function generators.If you repeat to call typia.protobuf.encode<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.protobuf.createEncode<T>() function.Just look at the code below, then you may understand how to use it.","references#References":"Protocol Buffer supports special numeric types like int32 or uint64 that are not supported in TypeScript. Also, types of Protocol Buffer cannot fully meet TypeScript type specs either, as expression power of TypeScript types are much stronger than Protocol Buffer.To know how to define special numeric types like uint64, and to understand which TypeScript types are not supported in Protocol Buffer specs, it would better to read below documents. I recommend you to read them before using typia.protobuf.encode<T>() related functions.\nTypia Guide Documents > Protocol Buffer > Message Schema\nmessage() function\nType Tags\nComment Tags\nRestrictions"}},"/docs/random":{"title":"Guide Documents > random() function","data":{"random-function#random() function":"export function random<T>(g?: IRandomGenerator): Resolved<T>;\nYou can make every random data just by calling typia.random<T>() function.When you call the typia.random<T>() function, typia will analyze your type T, and writes optimal random generation code for the type T, in the compilation level. This is called AOT (Ahead of Time) compilation, and you may understand what it is just by reading below example code.","reusable-function#Reusable function":"export function createRandom<T>(): (g?: IRandomGenerator) => Resolved<T>;","special-tags#Special Tags":"Runtime validators of typia provides additional type checking logic through Type Tags and Comment Tags. typia.random<T>() function also like that. typia.random<T>() function can utilize those tags to specialize the behavior of random data generation.For reference, whether you choose Type Tags or Comment Tags. typia.random<T>(), it is not a matter for typia.random<T>() function. Below two TypeScript codes are generating exactly same JavaScript code. Therefore, you can choose whatever you want considering your preference.","customization#Customization":"export function random<T>(g?: IRandomGenerator): Resolved<T>;\nYou can add custom type tags for random data generation.As above IRandomGenerator.CustomMap has a little bit complicate type, it may hard to understand for newcomers. However, such newcomers may easily understand, how to customize the random generation, just by reading the following example.Just define custom type tags like below, then everything would be done.For reference, when defining custom type tag, typia enforces user to define validate function literal for type safety. Never forget it when you define custom type tags for random generation. Such validation logic definition may enhance your random data generator logic when combining with typia.assert<T>() function."}},"/docs/utilization/hono":{"title":"Guide Documents > Utilization Cases > Hono","data":{"":"Hono is a small, simple, and ultrafast web framework for the Edges.If you are using Hono with typia, you can use  @hono/typia-validator  to validate the request body.\nimport { Hono } from \"hono\";\nimport { typiaValidator } from '@hono/typia-validator'\nimport typia, { type tags } from \"typia\";\nimport { IBbsArticle } from \"../structures/IBbsArticle\";\n/** create a validate function */\nconst validate = typia.createValidate<IBbsArticle>();\nconst app = new Hono();\napp.post(\"/\",\n  typiaValidator('json', validate),\n  (c) => {\n    const data = c.req.valid(\"json\");\n    return c.json({\n      id: data.id,\n      title: data.title,\n      body: data.body,\n      created_at: data.created_at,\n    });\n  });\nexport default app;"}},"/docs/utilization/nestjs":{"title":"Guide Documents > Utilization Cases > NestJS","data":{"":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: superfast decorators using typia\n@nestia/sdk: evolved SDK and Swagger generators\n@nestia/migrate: Swagger to NestJS\nnestia: just CLI (command line interface) tool\nimport { Controller } from \"@nestjs/common\";\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\nimport type { IBbsArticle } from \"@bbs-api/structures/IBbsArticle\";\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  /**\n   * Store a new content.\n   *\n   * @param input Content to store\n   * @returns Newly archived article\n   */\n  @TypedRoute.Post() // 200x faster and safer JSON.stringify()\n  public async store(\n    @TypedBody() input: IBbsArticle.IStore, // 20,000x faster validator\n  ): Promise<IBbsArticle>;\n    // do not need DTO class definition,\n    // just fine with interface\n}\nLeft: NestJS server code\nRight: Client code using SDK"}},"/docs/validators/assert":{"title":"Guide Documents > Runtime Validators > assert() functions","data":{"assert-function#assert() function":"export function assert<T>(input: T): T;\nexport function assert<T>(input: unknown): T;\nAsserts a value type.typia.assert<T>() function throws a TypeGuardError when wrong type comes.The TypeGuardError instance has only the first type error info, with access path and expected type. In the below example case, as the age property is wrong with its definition (@exclusiveMinimum), such TypeGuardError would be thrown:\nmethod: typia.assert()\npath: input.age\nvalue: 18,\nexpected: number & ExclusiveMinimum<19>\nAOT compilation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.","assertequals-function#assertEquals() function":"export function assertEquals<T>(input: T): T;\nexport function assertEquals<T>(input: unknown): T;\nMore strict assert function prohibiting superfluous properties.typia.assert<T>() function inspects input value type and throws TypeGuardError when mismatched, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, therefore throws an TypeGuardError when superfluous property exists, use typia.assertEquals<T()> function instead.In the below example case, as sex property is not defined in the IMember type, such TypeGuardError would be thrown:\nmethod: typia.assertEquals()\npath: input.sex\nvalue: 1,\nexpected: undefined","assertguard-functions#assertGuard() functions":"export function assertGuard<T>(input: T): asserts input is T;\nexport function assertGuard<T>(input: unknown): asserts input is T;\nexport function assertGuardEquals<T>(input: T): asserts input is T;\nexport function assertGuardEquals<T>(input: unknown): asserts input is T;\nAssertion guard of a value type.typia.assertGuard<T>() is similar with typia.assert<T>() throwing a TypeGuardError when wrong type.However, typia.assert<T>() returns the paramteric input value itself when there's no type problem on the parametric input value, whereas the typia.assertGuard<T>() function returns nothing. Instead, the parametric input value would be automatically cased to the type T. This is the concept of \"Assertion Guard\" of a value type.Such similarities and differences of typia.assertGuard<T>() and typia.assert<T>() functions are the same in the case of typia.assertGuardEquals<T>() and typia.assertEquals<T>() functions. If there's no type problem on the typia.assertGuardEquals<T>() function, it also performs the \"Assertion Guard\".Look at the below code, then you may understand what the \"Assertion Guard\" means.","reusable-functions#Reusable functions":"export function createAssert<T>(): (input: unknown) => T;\nexport function createAssertEquals<T>(): (input: unknown) => T;\nexport function createAssertGuard<T>(): AssertionGuard<T>;\nexport function createAssertGuardEquals<T>(): AssertionGuard<T>;\nexport type AssertionGuard<T> = (input: unknown) => asserts input is T;\nReusable typia.assert<T>() function generators.If you repeat to call typia.assert<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createAssert<T>() function.Just look at the code below, then you may understand how to use it.\nExplicitly of Assertion Guard\nBe careful when using typia.createAssertGuard<T>() or typia.createAssertGuardEquals<T>() functions.When calling those functions, you've to declare the variable type explicit on the caller variable. If you don't do it, so that the caller variables come the implicit function type, TypeScript compiler throws an error like below. This is a special limitation of TypeScript compiler about the \"Assertion Guard\".","restrictions#Restrictions":"typia.assert<T>() function does not check function and user-defined class types.It validates only the primitive properties. Therefore, typia.assert<T>() function does not perform the instanceof ClassName for user-defined classes. If you want to validate the user-defined class type in addition to the property types, do it by yourself. Also, typia.assert<T>() function does not validate the function type either, unless configuring functional property of plugin option in the tsconfig.json file.\n{\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\",\n        \"functional\": true\n      }\n    ]\n  }\n}\nBy the way, there're some exception cases.If JS native class type like Date, Uint8Array, or Map<Key, T> being utilized, typia.assert<T>() function validates them. Especially about the Set<T>, and Map<Key, T> class cases, typia.assert<T>() function validates all of their contained element types, too.Therefore, the instanceof statement does not be used only for the user-defined classes.","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization","performance#Performance":"Super-fast and super-safe.Comparing typia.assert<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tObject (simple)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (hierarchical)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (recursive)\tâœ”\tâŒ\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (union, implicit)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tObject (union, explicit)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâŒ\tObject (additional tags)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (template literal types)\tâœ”\tâœ”\tâœ”\tâŒ\tâŒ\tâŒ\tObject (dynamic properties)\tâœ”\tâœ”\tâœ”\tâŒ\tâŒ\tâŒ\tArray (rest tuple)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tArray (hierarchical)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tArray (recursive)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâŒ\tArray (recursive, union)\tâœ”\tâœ”\tâŒ\tâœ”\tâœ”\tâŒ\tArray (R+U, implicit)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tArray (repeated)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tArray (repeated, union)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tUltimate Union Type\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\t\nC.V. means class-validator"}},"/docs/validators/functional":{"title":"Guide Documents > Runtime Validators > Functional Module","data":{"assertfunction#assertFunction()":"export namespace functional {\n  export function assertFunction<T extends Function>(func: T): T;\n  export function assertParameters<T extends Function>(func: T): T;\n  export function assertReturn<T extends Function>(func: T): T;\n  export function assertEqualsFunction<T extends Function>(func: T): T;\n  export function assertEqualsParameters<T extends Function>(func: T): T;\n  export function assertEqualsReturn<T extends Function>(func: T): T;\n}\nAsserts a function.typia.functional.assertFunction<T>() asserts a function, by wrapping the parameter function and checking its parameters and return value through typia.assert<T>() function. If some parameter or return value does not match the expected type, it throws a TypeGuardError error.For reference, TypeGuardError.path would be a little bit different with individual typia.assert<T>() function. If TypeGuardError occurs from some parameter, the path would start from $input.parameters[<index>]. Otherwise the path would start from $input.return.\n$input.parameters[0].~\n$input.return.~\nBy the way, if you don't want to assert both parameters and return value, but one of them, you can use typia.functional.assertParameters<T>() or typia.functional.assertReturn<T>() instead. Otherwise, if you want to prohibit superfluous properties, typia.functional.assertEqualsFunction<T>() would be helpful.Also, if what you want is not just finding the first type error through assertion, but also finding every type errors, utilize typia.functional.validateFunction<T>() function instead. Otherwise, you don't need the reason why, but just want to know whether the function is valid or not, use typia.functional.isFunction<T>() function.","isfunction#isFunction()":"export namespace functional {\n  export function isFunction<T extends (...args: any[]) => any>(\n    func: T,\n  ): T extends (...args: infer Arguments) => infer Output\n    ? Output extends Promise<infer R>\n      ? (...args: Arguments) => Promise<R | null>\n      : (...args: Arguments) => Output | null\n    : never;\n  export function isParameters<T extends (...args: any[]) => any>(\n    func: T,\n  ): T extends (...args: infer Arguments) => infer Output\n    ? (...args: Arguments) => Output | null\n    : never;\n  export function isReturn<T extends (...args: any[]) => any>(\n    func: T,\n  ): T extends (...args: infer Arguments) => infer Output\n    ? (...args: Arguments) => Output | null\n    : never;\n  export function isEqualsFunction;\n  export function isEqualsParameters;\n  export function isEqualsReturn;\n}\nTests a function.typia.functional.isFunction<T>() tests a function, by wrapping the parameter function and checking its parameters and return value through typia.is<T>() function. If some parameter or return value does not match the expected type, it returns null. Otherwise, it returns the return value of the parameter function.By the way, if you don't want to test both parameters and return value, but one of them, you can use typia.functional.isParameters<T>() or typia.functional.isReturn<T>() instead. Otherwise, if you want to prohibit superfluous properties, typia.functional.equalsFunction<T>() would be helpful.Also, if what you want is not just type checking, but want to know the detailed reason(s) why, utilize typia.functional.assertFunction<T>() or typia.functional.validateFunction<T>() instead.\nValidates a function.typia.functional.validateFunction<T>() validates a function, by wrapping the parameter function and checking its parameters and return value through typia.validate<T>() function. If some parameter or return value does not match the expected type, it returns a IValidation.IFailure typed object. Otherwise, it returns a IValidation.ISuccess typed object instead.For reference, IValidation.IError.path would be a little bit different with individual typia.validate<T>() function. If IValidation.IError occurs from some parameter, the path would start from $input.parameters[<index>]. Otherwise the path would start from $input.return.\n$input.parameters[0].~\n$input.return.~\nBy the way, if you don't want to validate both parameters and return value, but one of them, you can use typia.functional.validateParameters<T>() or typia.functional.validateReturn<T>() instead. Otherwise, if you want to prohibit superfluous properties, typia.functional.validateEqualsFunction<T>() would be helpful.Also, if what you want is not retrieving every type errors, but just finding the first type error, utilize typia.functional.assertFunction<T>() function instead. Otherwise, you don't need the reason why, but just want to know whether the function is valid or not, use typia.functional.isFunction<T>() function."}},"/docs/validators/is":{"title":"Guide Documents > Runtime Validators > is() functions","data":{"is-function#is() function":"export function is<T>(input: T): input is T;\nexport function is<T>(input: unknown): input is T;\nTests a value type.When you need to test an instance type, just call typia.is<T>() function.If the input value is following type T, true value would be returned. Otherwise, false would be returned.\nAOT compilation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.","equals-function#equals() function":"export function equals<T>(input: T): input is T;\nexport function equals<T>(input: unknown): input is T;\nMore strict checker prohibiting superfluous properties.typia.is<T>() can test instance type, but it allows superfluous properties.If you want to prohibit those superfluous properties, you can use typia.equals<T>() function instead.","reusable-functions#Reusable functions":"export function createIs<T>(): (input: unknown) => input is T;\nexport function createEquals<T>(): (input: unknown) => input is T;\nReusable typia.is<T>() function generators.If you repeat to call typia.is<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIs<T>() function.Just look at the code below, then you may understand how to use it.","auto-type-casting#Auto Type Casting":"export function is<T>(input: unknown): input is T;\nexport function equals<T>(input: unknown): input is T;\nexport function createIs<T>(): (input: unknown) => input is T;\nexport function createEquals<T>(): (input: unknown) => input is T;\ntypia.is<T>() function can be used for type casting.When target input value is following the type T, therefore true value be returned, typia.is<T>() function automatically casts the input value to the type T. Therefore, you can utilize the typia.is<T>() function for safe type casting tool like below:","restrictions#Restrictions":"typia.is<T>() function does not check function and user-defined class types.It validates only the primitive properties. Therefore, typia.is<T>() function does not perform the instanceof ClassName for user-defined classes. If you want to validate the user-defined class type in addition to the property types, do it by yourself. Also, typia.is<T>() function does not validate the function type either, unless configuring functional property of plugin option in the tsconfig.json file.\n{\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\",\n        \"functional\": true\n      }\n    ]\n  }\n}\nBy the way, there're some exception cases.If JS native class type like Date, Uint8Array, or Map<Key, T> being utilized, typia.is<T>() function validates them. Especially about the Set<T>, and Map<Key, T> class cases, typia.is<T>() function validates all of their contained element types, too.Therefore, the instanceof statement does not be used only for the user-defined classes.","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization","performance#Performance":"Super-fast and super-safe.Comparing typia.is<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tObject (simple)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (hierarchical)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (recursive)\tâœ”\tâŒ\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (union, implicit)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tObject (union, explicit)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâŒ\tObject (additional tags)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (template literal types)\tâœ”\tâœ”\tâœ”\tâŒ\tâŒ\tâŒ\tObject (dynamic properties)\tâœ”\tâœ”\tâœ”\tâŒ\tâŒ\tâŒ\tArray (rest tuple)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tArray (hierarchical)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tArray (recursive)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâŒ\tArray (recursive, union)\tâœ”\tâœ”\tâŒ\tâœ”\tâœ”\tâŒ\tArray (R+U, implicit)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tArray (repeated)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tArray (repeated, union)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tUltimate Union Type\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\t\nC.V. means class-validator"}},"/docs/validators/validate":{"title":"Guide Documents > Runtime Validators > validate() functions","data":{"validate-function#validate() function":"export function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\nValidates a value type.typia.validate<T>() function validates input value type, and archives every type errors detaily into IValidation.IFailure.errors array, when the input value is not following the promised type T. Of course, if the parametric input value is following the type T, IValidation.ISuccess instance would be returned.In the below example case, as id and age values are different with its definition of IMember, such errors would be archived into the IValidation.IFailure.errors array.\nerrors[0]\npath: input.id\nexpected: string & Format<\"uuid\">\nvalue: 5\nerrors[1]\npath: input.age\nexpected: number & Format<\"uint32\">\nvalue: 20.75\nAOT compilation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.","validateequals-function#validateEquals() function":"export function validateEquals<T>(input: T): IValidation<T>;\nexport function validateEquals<T>(input: unknown): IValidation<T>;\nMore strict validate function prohibiting superfluous properties.typia.validate<T> function detects every type errors of input value, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, so that archive them into IValidation.IFailure.errors array, use typia.validateEquals<T>() function instead.In the below example case, as id property is different with its type definition and sex property is not defined in the IMember type, such errors would be archived into the IValidation.IFailure.errors array:\nerrors[0]\npath: input.id\nexpected: string (@format uuid)\nvalue: something\nerrors[1]\npath: input.sex\nexpected: undefined\nvalue: 1","reusable-functions#Reusable functions":"export function createValidate<T> = (input: unknown) => IValidation<T> & StandardSchemaV1<unknown, T>;\nexport function createValidateEquals<T> = (input: unknown) => IValidation<T> & StandardSchemaV1<unknown, T>;\nReusable typia.validate<T>() function generators.If you repeat to call typia.validate<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createValidate<T>() function.Just look at the code below, then you may understand how to use it.\nThis reusable function implements Standard Schema interface. Therefore, you can use this function with a library which accepts Standard Schema interface, such as upfetch:\nimport typia from \"typia\";\nimport { up } from \"up-fetch\";\nconst upfetch = up(fetch);\nconst schema = typia.createValidate<ISmallTodo>();\n// passes\nawait upfetch(\"https://jsonplaceholder.typicode.com/todos/1\", {\n  schema,\n});\n// fails\nawait upfetch(\"https://jsonplaceholder.typicode.com/todos/10\", {\n  schema,\n})\ninterface ISmallTodo {\n  userId: number;\n  /** @maximum 5 */\n  id: number;\n  title: string;\n  completed: boolean;\n}","restrictions#Restrictions":"typia.validate<T>() function does not check function and user-defined class types.It validates only the primitive properties. Therefore, typia.validate<T>() function does not perform the instanceof ClassName for user-defined classes. If you want to validate the user-defined class type in addition to the property types, do it by yourself. Also, typia.validate<T>() function does not validate the function type either, unless configuring functional property of plugin option in the tsconfig.json file.\n{\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\",\n        \"functional\": true\n      }\n    ]\n  }\n}\nBy the way, there're some exception cases.If JS native class type like Date, Uint8Array, or Map<Key, T> being utilized, typia.validate<T>() function validates them. Especially about the Set<T>, and Map<Key, T> class cases, typia.validate<T>() function validates all of their contained element types, too.Therefore, the instanceof statement does not be used only for the user-defined classes.","discriminated-union#Discriminated Union":"export function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\nexport function createValidate<T>(): (input: unknown) => IValidation<T>;\nSpecify type through if condition.typia.IValidation<T> is an union type of typia.IValidation.ISuccess<T> and typia.IValidation.IFailure. Also, they have a common property success of boolean type, but different literal values. In that case, if you write a if condition about the success property, you can specify the union type like below.In TypeScript, such union type specification through common property (of different literal value() is called \"Discriminated Union\". Therefore, when using typia.validate<T>() function, let's utilize such discriminated union specification for convenience.\nimport typia from \"typia\";\nconst something: unknown = ...;\nconst result: typia.IValidation<string> = typia.validate<string>(something);\nif (results.success) {\n  // become typia.IValidation.Success<string> type\n  result.data; // accessible\n} else {\n  // become typia.IValidation.Failure type\n  result.errors; //accessible\n}","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization","performance#Performance":"Super-fast and super-safe.Comparing typia.validate<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tObject (simple)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (hierarchical)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (recursive)\tâœ”\tâŒ\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (union, implicit)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tObject (union, explicit)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâŒ\tObject (additional tags)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tObject (template literal types)\tâœ”\tâœ”\tâœ”\tâŒ\tâŒ\tâŒ\tObject (dynamic properties)\tâœ”\tâœ”\tâœ”\tâŒ\tâŒ\tâŒ\tArray (rest tuple)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tArray (hierarchical)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tArray (recursive)\tâœ”\tâœ”\tâœ”\tâœ”\tâœ”\tâŒ\tArray (recursive, union)\tâœ”\tâœ”\tâŒ\tâœ”\tâœ”\tâŒ\tArray (R+U, implicit)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tArray (repeated)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tArray (repeated, union)\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\tUltimate Union Type\tâœ…\tâŒ\tâŒ\tâŒ\tâŒ\tâŒ\t\nC.V. means class-validator"}},"/playground":{"title":"Playground","data":{}},"/docs":{"title":"Guide Documents > Introduction","data":{"outline#Outline":"// RUNTIME VALIDATORS\nexport function is<T>(input: unknown): input is T; // returns boolean\nexport function assert<T>(input: unknown): T; // throws TypeGuardError\nexport function assertGuard<T>(input: unknown): asserts input is T;\nexport function validate<T>(input: unknown): IValidation<T>; // detailed\n// JSON FUNCTIONS\nexport namespace json {\n  export function application<T>(): IJsonApplication; // JSON schema\n  export function assertParse<T>(input: string): T; // type safe parser\n  export function assertStringify<T>(input: T): string; // safe and faster\n}\n// LLM FUNCTION CALLING SCHEMA\nexport namespace llm {\n  // collection of function calling schemas\n  export function application<Class, Model>(): ILlmApplication<Class>;\n  export function controller<Class, Model>(\n    name: string,\n    execute: Class,\n  ): ILlmController<Model>; // +executor\n  // structured output\n  export function parameters<P, Model>(): ILlmSchema.IParameters<Model>; \n  export function schema<T, Model>(): ILlmSchema<Model>; // type schema\n}\n// PROTOCOL BUFFER\nexport namespace protobuf {\n  export function message<T>(): string; // Protocol Buffer message\n  export function assertDecode<T>(buffer: Uint8Array): T; // safe decoder\n  export function assertEncode<T>(input: T): Uint8Array; // safe encoder\n}\n// RANDOM GENERATOR\nexport function random<T>(g?: Partial<IRandomGenerator>): T;\ntypia is a transformer library supporting below features:\nSuper-fast Runtime Validators\nEnhanced JSON functions\nLLM function calling schema and structured output\nProtocol Buffer encoder and decoder\nRandom data generator\nOnly one line required, with pure TypeScript type\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer","transformation#Transformation":"If you call typia function, it would be compiled like below.This is the key concept of typia, transforming TypeScript type to a runtime function. The typia.is<T>() function is transformed to a dedicated type checker by analyzing the target type T in the compilation level.This feature enables developers to ensure type safety in their applications, leveraging TypeScript's static typing while also providing runtime validation. Instead of defining additional schemas, you can simply utilize the pure TypeScript type itself.\n//----\n// examples/checkString.ts\n//----\nimport typia, { tags } from \"typia\";\nexport const checkString = typia.createIs<string>();\n//----\n// examples/checkString.js\n//----\nimport typia from \"typia\";\nexport const checkString = (() => {\n  return (input) => \"string\" === typeof input;\n})();","sponsors#Sponsors":"Thanks for your support.Your donation encourages typia development.Also, typia is re-distributing half of donations to core contributors of typia.\nnonara/ts-patch\nryoppippi/unplugin-typia"}},"/docs/llm/chat":{"title":"Guide Documents > Large Language Model > AI Chatbot Development","data":{"agentica#Agentica":"https://github.com/wrtnlabs/agenticaThe simplest Agentic AI framework, specialized in LLM Function Calling.With @agentica, you can build Agentic AI chatbot only with TypeScript class types. Complex agent workflows and graphs required in conventional AI agent develoopment are not necessary in @agentica. Only with TypeScript class types, @agentica will do everything with the function calling.Look at below demonstration, and and feel how @agentica is powerful. Now, you can let users to read and write articles only with conversation texts. The TypeScript class functions would be adequately called in the AI chatbot with LLM function calling.\n@nestia/agent had been migrated to @agentica/* for enhancements and separation to multiple packages extending the functionalities.\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\nimport { BbsArticleService } from \"./BbsArticleService\";\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  service: {\n    api: new OpenAI({ apiKey: \"*****\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    typia.llm.controller<BbsArticleService, \"chatgpt\">(\n      \"bbs\",\n      new BbsArticleService(),\n    ),\n  ],\n});\nawait agent.conversate(\"Hello, I want to create an article.\");\nBBS A.I. Chatbot Application: https://nestia.io/chat/bbs","swagger-chatbot#Swagger Chatbot":"You also can make the super A.I. chatbot by Swagger document too.With @agentica, you can build Agentic AI chatbot only with Swagger document built by @nestia/sdk. Complex agent workflows and graphs required in conventional AI agent development are not necessary in @agentica. Only with the Swagger document, @agentica will do everything with the function calling.Look at below demonstration, and feel how @agentica is powerful. Now, you can let users to search and purchase products only with conversation texts. The backend API functions would be adequately called in the AI chatbot with LLM function calling.\nimport { Agentica, assertHttpController } from \"@agentica/core\";\nimport OpenAI from \"openai\";\nimport typia from \"typia\";\n \nimport { MobileFileSystem } from \"./services/MobileFileSystem\";\n \nconst agent = new Agentica({\n  vendor: {\n    api: new OpenAI({ apiKey: \"********\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    // functions from TypeScript class\n    typia.llm.controller<MobileFileSystem, \"chatgpt\">(\n      \"filesystem\",\n      MobileFileSystem(),\n    ),\n    // functions from Swagger/OpenAPI\n    assertHttpController({\n      name: \"shopping\",\n      model: \"chatgpt\",\n      document: await fetch(\n        \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n      ).then(r => r.json()),\n      connection: {\n        host: \"https://shopping-be.wrtn.ai\",\n        headers: { Authorization: \"Bearer ********\" },\n      },\n    }),\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\nShopping A.I. Chatbot Application: https://nestia.io/chat/shopping\nShopping Backend Repository: https://github.com/samchon/shopping-backend\nShopping Swagger Document (@nestia/editor): https://nestia.io/editor/?url=...","principles#Principles":"","agent-strategy#Agent Strategy":"When user says, @agentica/core delivers the conversation text to the selector agent, and let the selector agent to find (or cancel) candidate functions from the context. If the selector agent could not find any candidate function to call and there is not any candidate function previously selected either, the selector agent will work just like a plain ChatGPT.And @agentica/core enters to a loop statement until the candidate functions to be empty. In the loop statement, caller agent tries to LLM function calling by analyzing the user's conversation text. If context is enough to compose arguments of candidate functions, the caller agent actually calls the target functions, and let decriber agent to explain the function calling results. Otherwise the context is not enough to compose arguments, caller agent requests more information to user.Such LLM (Large Language Model) function calling strategy separating selector, caller, and describer is the key logic of @agentica/core.","validation-feedback#Validation Feedback":"import { FunctionCall } from \"pseudo\";\nimport { ILlmFunction, IValidation } from \"typia\";\nexport const correctFunctionCall = (p: {\n  call: FunctionCall;\n  functions: Array<ILlmFunction<\"chatgpt\">>;\n  retry: (reason: string, errors?: IValidation.IError[]) => Promise<unknown>;\n}): Promise<unknown> => {\n  // FIND FUNCTION\n  const func: ILlmFunction<\"chatgpt\"> | undefined =\n    p.functions.find((f) => f.name === p.call.name);\n  if (func === undefined) {\n    // never happened in my experience\n    return p.retry(\n      \"Unable to find the matched function name. Try it again.\",\n    );\n  }\n  // VALIDATE\n  const result: IValidation<unknown> = func.validate(p.call.arguments);\n  if (result.success === false) {\n    // 1st trial: 50% (gpt-4o-mini in shopping mall chatbot)\n    // 2nd trial with validation feedback: 99%\n    // 3nd trial with validation feedback again: never have failed\n    return p.retry(\n      \"Type errors are detected. Correct it through validation errors\",\n      {\n        errors: result.errors,\n      },\n    );\n  }\n  return result.data;\n}\nIs LLM function calling perfect?The answer is not, and LLM (Large Language Model) vendors like OpenAI take a lot of type level mistakes when composing the arguments of the target function to call. Even though an LLM function calling schema has defined an Array<string> type, LLM often fills it just by a string typed value.Therefore, when developing an LLM function calling agent, the validation feedback process is essentially required. If LLM takes a type level mistake on arguments composition, the agent must feedback the most detailed validation errors, and let the LLM to retry the function calling referencing the validation errors.About the validation feedback, @agentica/core is utilizing typia.validate<T>() and typia.llm.application<Class, Model>() functions. They construct validation logic by analyzing TypeScript source codes and types in the compilation level, so that detailed and accurate than any other validators like below.Such validation feedback strategy and combination with typia runtime validator, @agentica/core has achieved the most ideal LLM function calling. In my experience, when using OpenAI's gpt-4o-mini model, it tends to construct invalid function calling arguments at the first trial about 50% of the time. By the way, if correct it through validation feedback with typia, success rate soars to 99%. And I've never had a failure when trying validation feedback twice.For reference, the embedded typia.validate<T>() function creates validation logic by analyzing TypeScript source codes and types in the compilation level. Therefore, it is accurate and detailed than any other validator libraries. This is exactly what is needed for function calling, and I can confidentelly say that typia is the best library for LLM function calling.\nAdditionally, this validation feedback strategy is useful for some LLM providers do not supporting restriction properties of JSON schema like OpenAI (IChatGptSchema) and Gemini (IGeminiSchema). For example, OpenAI and Gemini do not support format property of JSON schema, so that cannot understand the UUID like type. Even though typia.llm.application<App, Model>() function is writing the restriction information to the description property of JSON schema, but LLM provider does not reflect it perfectly.Also, some LLM providers which have not specified the JSON schema version like Claude (IClaudeSchema) and Llama (ILlamaSchema), they tend to fail a lot of function calling about the restriction properties. In fact, Llama does not support function calling formally, so you have to detour it by prompt template, and its success rate is lower than others.In that case, if you give validation feedback from ILlmFunction.validate() function to the LLM agent, the LLM agent will be able to understand the restriction information exactly and fill the arguments properly.\nRestriction properties of JSON schema\nstring: minLength, maxLength, pattern, format, contentMediaType\nnumber: minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf\narray: minItems, maxItems, uniqueItems, items","openapi-specification#OpenAPI Specification":"@agentica/core obtains LLM function calling schemas from both Swagger/OpenAPI documents and TypeScript class types. The TypeScript class type can be converted to LLM function calling schema by typia.llm.application<Class, Model>() function. Then how about OpenAPI document? How Swagger document can be LLM function calling schema.The secret is in the above diagram.In the OpenAPI specification, there are three versions with different definitions. And even in the same version, there are too much ambiguous and duplicated expressions. To resolve these problems, @samchon/openapi is transforming every OpenAPI documents to v3.1 emended specification. The @samchon/openapi's emended v3.1 specification has removed every ambiguous and duplicated expressions for clarity.With the v3.1 emended OpenAPI document, @samchon/openapi converts it to a migration schema that is near to the function structure. And as the last step, the migration schema will be transformed to a specific LLM vendor's function calling schema. LLM function calling schemas are composed like this way.\nWhy do not directly convert, but intermediate?If directly convert from each version of OpenAPI specification to specific LLM's function calling schema, I have to make much more converters increased by cartesian product. In current models, number of converters would be 12 = 3 x 4.However, if define intermediate schema, number of converters are shrunk to plus operation. In current models, I just need to develop only (7 = 3 + 4) converters, and this is the reason why I've defined intermediate specification. This way is economic."}},"/docs/protobuf/message":{"title":"Guide Documents > Protobuf > Schema","data":{"message-function#message() function":"export namespace protobuf {\n  export function message<T>(): string;\n}\ntypia.protobuf.message() function returns a Protocol Buffer message (structure) as a string value.With this message() function, you can share *.proto files with other languages. If you want to customize byte order or define specific type (that is not supported in the TypeScript) like uint32, use comment tags by following comment tags section.","type-tags#Type Tags":"By using type tags, you can use special numeric types that are not supported in the TypeScript.Just import Type (or typia.tags.Type) type, and combine it with number or bigint type through intersection symbol number & typia.tagsType<\"float\"> case. If you want to declare an union numeric type, combine | and bracket (()) symbols properly like below.When you take a mistake that choosing different target type, TypeScript compiler would block it with compilation error message. Therefore, have a confidence when using the Type tag. For such type safety reason, I recommend to use Type tag instead of using comment tags as much as possible.\nnumber & (Type<\"uint32\"> | Type<\"double\">)\nnumber type can be both uint32 and double\n(number & Type<\"int32\">) | (bigint & Type<\"uint64\">)\nnumber is int32\nbigint is uint64\n(number & (Type<\"int32\">)| Type<\"float\">) | (bigint & Type<\"uint64\">)\nnumber can be both int32 and float\nbigint is uint64","comment-tags#Comment Tags":"By using @type {target} comment tag, you also can use special numeric types.However, this way is not recommended, because it can't perform union numeric types, and cannot be used in Array and Map types. When you declare @type int32 statement, target number type be fixed as int32 type, and never can have another numeric type by declaring union statements.Also, those comment tags are not type safe. If you take a mistake when writing a comment tag, it will not be detected by the compiler, and will cause an error at runtime. For example, if you write a miss-spelled keyword like @type unit32, the target number type would be double type, and you can identify it just by running the program (or visiting playground website).\nWhy supports comment tags?\nDespite these disadvantages, the reason for maintaining comment tags is as follows.First, it is to support the legacy JSDoc style that had been used in the JS camp for a long time. If you had developed a legacy project and JSDoc being used, you can use it as is.Second, to support Prisma. If a comment is created in the Prisma Schema through the /// statement as shown below and a type is created, it is converted to a TS comment as it is. And since there is no way that union types, numeric Arrays or Maps are used in Prisma (database) schema, these comment tags are surprisingly compatible with Prisma.","restrictions#Restrictions":"You know what? Expression power of Protocol Buffer is extremely narrower than type system of TypeScript. For example, Protocol Buffer can't express complicate union type containing array. Also, Protocol Buffer can't express multi dimensional array type, either.In such reason, when converting TypeScript type to Protocol buffer message schema, lots of restrictions are exist. Let's study which types of TypeScript are not supported in Protocol Buffer. For reference, if you try to call typia.protobuf.message<T>() function with unsupported type, typia will generate compile errors like below example cases.At first, top level type must be a sole and static object.If you try to use number or Array<T> type as a top level type, typia will generate compile error like below. Dynamic object types like Record<string, T>, or Map<string, T> types are not allowed either. For reference, the sole object means that, union of object types is not allowed, either.\nimport typia from \"typia\";\ninterface Cat {\n    type: \"cat\";\n    name: string;\n    ribbon: boolean;\n}\ninterface Dog {\n    type: \"dog\";\n    name: string;\n    hunt: boolean;\n}\ntypia.protobuf.message<bigint>();\ntypia.protobuf.createDecode<Record<string, number>>();\ntypia.protobuf.createDecode<Map<number & typia.tags.Type<\"float\">, Dog>>();\ntypia.protobuf.createEncode<boolean[]>();\ntypia.protobuf.createEncode<Cat | Dog>();\nmain.ts:14:1 - error TS(typia.protobuf.message): unsupported type detected\n- bigint\n  - target type must be a sole and static object type\nmain.ts:15:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n- Record<string, number>\n  - target type must be a sole and static object type\nmain.ts:16:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n- Map<(number & Type<\"float\">), Dog>\n  - target type must be a sole and static object type\n- (number & Type<\"float\">)\n  - target type must be a sole and static object type\nmain.ts:17:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n- Array<boolean>\n  - target type must be a sole and static object type\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n- (Cat | Dog)\n  - target type must be a sole and static object type\nAt next, in Protocol Buffer, those types are categorized as container types.\nArray<T>\nMap<Key, T>\nRecord<string, T> (dynamic object)\nAlso, those container types does not allow over two-dimensional stacking. Therefore, it is not possible to declaring two dimensional array like number[][], or Array type in Map like Map<string, number[]>. Besides, value type of those container also do not support union type either.Additionally, about Map<Key, T> type, key type must be an atomic type. It means that, only boolean, number, bigint and string types are allowed. Also, key type cannot be union type, either.\nimport typia from \"typia\";\ninterface IPointer<T> {\n  value: T;\n}\ninterface Cat {\n  type: \"cat\";\n  name: string;\n  ribbon: boolean;\n}\ninterface Dog {\n  type: \"dog\";\n  name: string;\n  hunt: boolean;\n}\ntypia.protobuf.message<IPointer<number[][]>>();\ntypia.protobuf.createEncode<IPointer<Record<string, string[]>>>();\ntypia.protobuf.createDecode<IPointer<Map<string, Cat | Dog>>>();\ntypia.protobuf.message<IPointer<Map<Cat, string>>>();\ntypia.protobuf.message<IPointer<Map<number | string, Dog>>>();\nmain.ts:17:1 - error TS(typia.protobuf.message): unsupported type detected\n- IPointer<Array<Array<number>>>[key]: Array<Array<number>>\n  - does not support over two dimensional array type\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n- IPointer<Record<string, Array<string>>>[key]: Record<string, Array<string>>\n  - does not support dynamic object with array value type\nmain.ts:19:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n- IPointer<Map<string, Cat | Dog>>[key]: Map<string, (Cat | Dog)>\n  - does not support union type in map value type\nmain.ts:21:1 - error TS(typia.protobuf.message): unsupported type detected\n- IPointer<Map<Cat, string>>[key]: Map<Cat, string>\n  - does not support non-atomic key typed map\nmain.ts:22:1 - error TS(typia.protobuf.message): unsupported type detected\n- IPointer<Map<string | number, Dog>>[key]: Map<(number | string), Dog>\n  - does not support union key typed map\n  - does not support non-atomic key typed map\nAt last, those types are all not allowed.\nany\nfunctional type\nSet<T>, WeakSet<T> and WeakMap<T>\nDate, Boolean, BigInt, Number, String\nBinary classes except Uint8Array\nUint8ClampedArray, Uint16Array, Uint32Array, BigUint64Array\nInt8Array, Int16Array, Int32Array, BigInt64Array\nArrayBuffer, SharedArrayBuffer and DataView\nimport typia from \"typia\";\ninterface Something {\n  any: any;\n  unknown: unknown;\n  closure: () => void;\n  dict: Set<string> | WeakSet<Something> | WeakMap<Something, string>;\n  date: Date;\n  classic: String;\n  buffer: ArrayBuffer;\n}\ntypia.protobuf.message<Something>();\nmain.ts:13:1 - error TS(typia.protobuf.message): unsupported type detected\n- Something.any: any\n  - does not support any type\n- Something.unknown: any\n  - does not support any type\n- Something.closure: unknown\n  - does not support functional type\n- Something.dict: (Set<string> | WeakMap | WeakSet)\n  - does not support Set type\n  - does not support WeakSet type. Use Array type instead.\n  - does not support WeakMap type. Use Map type instead.\n- Something.date: Date\n  - does not support Date type. Use string type instead.\n- Something.classic: String\n  - does not support String type. Use string type instead.\n- Something.buffer: ArrayBuffer\n  - does not support ArrayBuffer type. Use Uint8Array type instead."}},"/docs/pure":{"title":"Guide Documents > Pure TypeScript Type","data":{"outline#Outline":"typia.assert<IBbsArticle>(article);\ntypia needs only one line with pure TypeScript type.You know what? Every other validator libraries need extra schema definition, that is different with pure TypeScript type. For an example, class-validator is the most famous validator due to used in NestJS. However, NestJS and class-validator force you to define triple duplicated DTO schema.\nTypeScript Type\nclass-validator decorators\n@nestjs/swagger decorators\nAnother famous validator library ajv requires JSON schema definition. Move to the #Demonstration, and click the ajv (JSON Schema) tab, then you may understand how it terrible. It requires hundreds of lines of JSON schema definition even just for a simple DTO.Those duplicated schema definitions are not only annoying, but also error-prone. If you take any mistake on the extra schema definition, such mistake can't be detected by TypeScript compiler. It will be detected only at runtime, therefore become a critical runtime error. Another words, it is not type safe.Besides, typia only needs pure TypeScript type. You don't need to define any extra schema like class-validator or ajv. Just define pure TypeScript type only (especially recommend to use interface type), then typia will do all the rest.","demonstration#Demonstration":"If you're confusing how typia is different with others, just see example codes below.At first, look at the first (class-validator) tab, and find the BbsArticle.files property, enhanced by blue colored blocks. Looking at the files property, how do you feel? Just defining an array object type, you've to call 7 decorator functions. If you take any mistake when using the decorator like omitting isArray property, it would be a critical runtime error.Besides, typia needs only one line. Click the third (typia) tab, and find the IAttachmentFile.files property. Only one line being used, and they are even not class, but just interface types. Comparing it to the first and second tabs, how do you feel? Isn't it more simple and readable?This is the power of typia, with pure TypeScript type.\nimport { ApiProperty } from \"@nestjs/swagger\";\nimport {\n  ArrayNotEmpty,\n  IsArray,\n  IsObject,\n  IsOptional,\n  IsString,\n  Match,\n  MaxLength,\n  Type,\n  ValidateNested,\n} from \"class-validator\";\nexport class BbsArticle {\n  @ApiProperty({\n    format: \"uuid\",\n  })\n  @IsString()\n  id!: string;\n  // DUPLICATED SCHEMA DEFINITION\n  // - duplicated function call + property type\n  // - have to specify `isArray` and `nullable` props by yourself\n  @ApiProperty({\n    type: () => AttachmentFile,\n    nullable: true,\n    isArray: true,\n    description: \"List of attached files.\",\n  })\n  @Type(() => AttachmentFile)\n  @IsArray()\n  @IsOptional()\n  @IsObject({ each: true })\n  @ValidateNested({ each: true })\n  files!: AttachmentFile[] | null;\n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    minLength: 5,\n    maxLength: 100,\n    description: \"Title of the article.\",\n  })\n  @IsOptional()\n  @IsString()\n  title!: string | null;\n  @ApiProperty({\n    description: \"Main content body of the article.\",\n  })\n  @IsString()\n  body!: string;\n  @ApiProperty({\n    format: \"date-time\",\n    description: \"Creation time of article\",\n  })\n  @IsString()\n  created_at!: string;\n}\nexport class AttachmentFile {\n  @ApiProperty({\n    type: \"string\",\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File name.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(255)\n  @IsString()\n  name!: string | null;\n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File extension.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(8)\n  @IsOptional()\n  @IsString()\n  extension!: string | null;\n  @ApiProperty({\n    format: \"url\",\n    description: \"URL of the file.\",\n  })\n  @IsString()\n  url!: string;\n}\n{\n  \"schemas\": [\n    {\n      \"$ref\": \"#/components/schemas/IBbsArticle\"\n    }\n  ],\n  \"components\": {\n    \"schemas\": {\n      \"IBbsArticle\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            },\n            \"nullable\": true,\n            \"title\": \"List of attached files\",\n            \"description\": \"List of attached files.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"maxLength\": 100,\n            \"minLength\": 5,\n            \"nullable\": true,\n            \"title\": \"Title of the article\",\n            \"description\": \"Title of the article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Main content body of the article\",\n            \"description\": \"Main content body of the article.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of article\",\n            \"description\": \"Creation time of article.\"\n          }\n        },\n        \"nullable\": false,\n        \"required\": [\n          \"id\",\n          \"files\",\n          \"title\",\n          \"body\",\n          \"created_at\"\n        ]\n      },\n      \"IAttachmentFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"maxLength\": 255,\n            \"pattern\": \"^[a-z0-9]+$\",\n            \"title\": \"File name\",\n            \"description\": \"File name.\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"maxLength\": 8,\n            \"pattern\": \"^[a-z0-9]+$\",\n            \"nullable\": true,\n            \"title\": \"File extension\",\n            \"description\": \"File extension.\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"title\": \"URL of the file\",\n            \"description\": \"URL of the file.\"\n          }\n        },\n        \"nullable\": false,\n        \"required\": [\n          \"name\",\n          \"extension\",\n          \"url\"\n        ]\n      }\n    }\n  },\n  \"purpose\": \"swagger\",\n  \"surplus\": false\n}\nimport typia, { tags } from \"typia\";\nexport interface IBbsArticle {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n  /**\n   * List of attached files.\n   */\n  files: null | IAttachmentFile[];\n  /**\n   * Title of the article.\n   */\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\n  /**\n   * Main content body of the article.\n   */\n  body: string;\n  /**\n   * Creation time of article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n}\nexport interface IAttachmentFile {\n  /**\n   * File name.\n   */\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\n  /**\n   * File extension.\n   */\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\n  /**\n   * URL of the file.\n   */\n  url: string;\n}","aot-compilation#AOT Compilation":"Someone may be suspicious of the phrase \"Pure TypeScript Type\".\n\"As you know, TypeScript types do not have any tangible instance when compiled to JS.However, with only these fictitious TypeScript types, how can typia validates types at runtime? How typia builds much faster JSON serializer only with these types? Are these things really possible without extra schema definition like class-validator or ajv?\"\nMy answer is: \"Yes, it is possible due to typia analyzes your server code, and performs AOT compilation\".Such compile time optimization is called AOT (Ahead of Time) compilation. And this is the secret why typia can do everything with only pure TypeScript type. Read below example codes, and just look how JavaScript file being compiled. Then you may understand why typia is much easier, and furthermore much faster.\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\nimport typia, { tags } from \"typia\";\nexport interface IBbsArticle {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n  /**\n   * List of attached files.\n   */\n  files: null | IAttachmentFile[];\n  /**\n   * Title of the article.\n   */\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\n  /**\n   * Main content body of the article.\n   */\n  body: string;\n  /**\n   * Creation time of article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n}\nexport interface IAttachmentFile {\n  /**\n   * File name.\n   */\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\n  /**\n   * File extension.\n   */\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\n  /**\n   * URL of the file.\n   */\n  url: string;\n}\nimport typia from \"typia\";\nimport { IBbsArticle } from \"./IBbsArticle\";\nexport const assertArticle = typia.createAssert<IBbsArticle>();\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatDateTime from \"typia/lib/internal/_isFormatDateTime.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nexport const assertArticle = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    (null === input.files ||\n      (Array.isArray(input.files) &&\n        input.files.every(\n          (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n        ))) &&\n    (null === input.title ||\n      (\"string\" === typeof input.title &&\n        5 <= input.title.length &&\n        input.title.length <= 100)) &&\n    \"string\" === typeof input.body &&\n    \"string\" === typeof input.created_at &&\n    __typia_transform__isFormatDateTime._isFormatDateTime(input.created_at);\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    RegExp(\"^[a-z0-9]+$\").test(input.name) &&\n    input.name.length <= 255 &&\n    (null === input.extension ||\n      (\"string\" === typeof input.extension &&\n        RegExp(\"^[a-z0-9]+$\").test(input.extension) &&\n        input.extension.length <= 8)) &&\n    \"string\" === typeof input.url;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    (null === input.files ||\n      ((Array.isArray(input.files) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".files\",\n            expected: \"(Array<IAttachmentFile> | null)\",\n            value: input.files,\n          },\n          _errorFactory,\n        )) &&\n        input.files.every(\n          (elem, _index2) =>\n            (((\"object\" === typeof elem && null !== elem) ||\n              __typia_transform__assertGuard._assertGuard(\n                _exceptionable,\n                {\n                  method: \"typia.createAssert\",\n                  path: _path + \".files[\" + _index2 + \"]\",\n                  expected: \"IAttachmentFile\",\n                  value: elem,\n                },\n                _errorFactory,\n              )) &&\n              _ao1(\n                elem,\n                _path + \".files[\" + _index2 + \"]\",\n                true && _exceptionable,\n              )) ||\n            __typia_transform__assertGuard._assertGuard(\n              _exceptionable,\n              {\n                method: \"typia.createAssert\",\n                path: _path + \".files[\" + _index2 + \"]\",\n                expected: \"IAttachmentFile\",\n                value: elem,\n              },\n              _errorFactory,\n            ),\n        )) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".files\",\n          expected: \"(Array<IAttachmentFile> | null)\",\n          value: input.files,\n        },\n        _errorFactory,\n      )) &&\n    (null === input.title ||\n      (\"string\" === typeof input.title &&\n        (5 <= input.title.length ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".title\",\n              expected: \"string & MinLength<5>\",\n              value: input.title,\n            },\n            _errorFactory,\n          )) &&\n        (input.title.length <= 100 ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".title\",\n              expected: \"string & MaxLength<100>\",\n              value: input.title,\n            },\n            _errorFactory,\n          ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".title\",\n          expected: \"((string & MinLength<5> & MaxLength<100>) | null)\",\n          value: input.title,\n        },\n        _errorFactory,\n      )) &&\n    (\"string\" === typeof input.body ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".body\",\n          expected: \"string\",\n          value: input.body,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.created_at &&\n      (__typia_transform__isFormatDateTime._isFormatDateTime(\n        input.created_at,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".created_at\",\n            expected: 'string & Format<\"date-time\">',\n            value: input.created_at,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".created_at\",\n          expected: '(string & Format<\"date-time\">)',\n          value: input.created_at,\n        },\n        _errorFactory,\n      ));\n  const _ao1 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.name &&\n      (RegExp(\"^[a-z0-9]+$\").test(input.name) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".name\",\n            expected: 'string & Pattern<\"^[a-z0-9]+$\">',\n            value: input.name,\n          },\n          _errorFactory,\n        )) &&\n      (input.name.length <= 255 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".name\",\n            expected: \"string & MaxLength<255>\",\n            value: input.name,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".name\",\n          expected: '(string & Pattern<\"^[a-z0-9]+$\"> & MaxLength<255>)',\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    (null === input.extension ||\n      (\"string\" === typeof input.extension &&\n        (RegExp(\"^[a-z0-9]+$\").test(input.extension) ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".extension\",\n              expected: 'string & Pattern<\"^[a-z0-9]+$\">',\n              value: input.extension,\n            },\n            _errorFactory,\n          )) &&\n        (input.extension.length <= 8 ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".extension\",\n              expected: \"string & MaxLength<8>\",\n              value: input.extension,\n            },\n            _errorFactory,\n          ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".extension\",\n          expected: '((string & Pattern<\"^[a-z0-9]+$\"> & MaxLength<8>) | null)',\n          value: input.extension,\n        },\n        _errorFactory,\n      )) &&\n    (\"string\" === typeof input.url ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".url\",\n          expected: \"string\",\n          value: input.url,\n        },\n        _errorFactory,\n      ));\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  return (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \"\",\n              expected: \"IBbsArticle\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \"\",\n            expected: \"IBbsArticle\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n})();\nMeasured on AMD Ryzen 9 7940HS, Rog Flow x13"}},"/docs/setup":{"title":"Guide Documents > Setup","data":{"summary#Summary":"npm install typia\nnpx typia setup\npnpm install typia\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn typia setup --manager yarn\nbun add typia\nbun typia setup --manager bun\nJust run npx typia setup command if you're using tsc. The setup wizard will do everything.By the way, if you use typia with bundlers(vite, rollup, webpack, etc), the third party library unplugin-typia is recommended.Otherwise non-standard compiler case, only the generation mode is available.\nStandard Compiler\nMicrosoft/TypeScript (tsc)\nNon-standard Compilers\nbabel\nesbuild -> covered by unplugin-typia\nSWC","transformation#Transformation":"","concepts#Concepts":"AOT (Ahead of Time) compilation mode.When you write a TypeScript code calling typia.createIs<IMember>() function and compile it through tsc command, typia will replace the typia.createIs<IMember>() statement to optimal validation code in the compiled JavaScript file, for the IMember type.This is the transform mode performing AOT (Ahead of Time) compilation.","setup-wizard#Setup Wizard":"npm install --save typia\nnpx typia setup\npnpm install --save typia\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn typia setup --manager yarn\nbun add typia\nbun typia setup --manager bun\nYou can turn on transformation mode just by running npx typia setup command.Setup wizard would be executed, and it will do everything for the transformation.","manual-setup#Manual Setup":"npm install --save typia\nnpm install --save-dev typescript ts-patch\npnpm install --save typia\npnpm install --save-dev typescript ts-patch\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn add -D typescript ts-patch\nbun add typia\nbun add -d typescript ts-patch\nIf you want to install typia manually, just follow the steps.Firstly install typia as a dependency. And then, install typescript and ts-patch as devDependencies.\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"strictNullChecks\": true, \n    \"skipLibCheck\": true,\n    \"plugins\": [\n      { \"transform\": \"typia/lib/transform\" }\n    ]\n  }\n}\nSecondly open your tsconfig.json file as shown above.As typia generates optimal operation code through transformation, it must be configured as a plugin. Also, never forget to configure strict (or strictNullChecks) to be true within your tsconfig.json compilerOptions. It is essential option for modern TypeScript development.\n{\n  \"scripts\": {\n    \"prepare\": \"ts-patch install\"\n  },\n  \"dependencies\": {\n    \"typia\": \"^6.0.6\"\n  },\n  \"devDependencies\": {\n    \"ts-patch\": \"^3.2.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}\nnpm run prepare\npnpm prepare\n# YARN BERRY IS NOT SUPPORTED\nyarn prepare\nbun prepare\nFinally open package.json file and configure npm run prepare command like above.Be sure to run npm run prepare once you have made these changes.For reference, ts-patch is an helper library of TypeScript compiler that supporting custom transformations by plugins. From now on, whenever you run tsc command, your typia function call statements would be transformed to the optimal operation codes in the compiled JavaScript files.","bundlers#Bundlers":"","unplugin-typia#unplugin-typia":"unplugin-typia is a plugin to integrate typia into your bundlers seamlessly.Currently, unplugin-typia supports the following bundlers:\nBun\nEsbuild\nFarm\nNext.js\nRolldown\nRollup\nRspack\nVite\nWebpack\nnpm install -D @ryoppippi/unplugin-typia\nnpm install --save typia\nnpx typia setup\npnpm install -D @ryoppippi/unplugin-typia\npnpm install typia\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\nyarn add -D @ryoppippi/unplugin-typia\nyarn add typia\nyarn typia setup --manager yarn\nbun add -D @ryoppippi/unplugin-typia\nbun add typia\nbun typia setup\nAt first, install both unplugin-typia and typia, with npx typia setup command.After that, follow the next section steps to integrate unplugin-typia into your bundlers.For reference, there are a couple of ways to integrate unplugin-typia into your bundlers. For the full integration guide, please refer to the unplugin-typia documentation.\nYou can use any plugins with unplugin-typia in Vite (including @vitejs/plugin-react-swc).\nunplugin-typia processes the TypeScript code before transforming it to JavaScript, so it can be used with any plugins.\nimport UnpluginTypia from '@ryoppippi/unplugin-typia/vite'\n \nexport default defineConfig({\n  plugins: [\n    UnpluginTypia({ /* options */ })\n  ],\n})\nimport unTypiaNext from \"@ryoppippi/unplugin-typia/next\";\n \n/** @type {import('next').NextConfig} */\nconst config = {\n  // your next.js config\n};\nexport default unTypiaNext(\n  config,\n  {} // options of unplugin-typia\n);\nimport { build } from 'esbuild'\nimport UnpluginTypia from '@ryoppippi/unplugin-typia/esbuild';\n \nbuild({\n  plugins: [\n    UnpluginTypia({ /* options */ }),\n  ],\n});\nFirst, create a preload.ts file and add the following code.\nimport { plugin } from 'bun';\nimport UnpluginTypia from '@ryoppippi/unplugin-typia/bun'\nplugin(UnpluginTypia({ /* options */ }))\nThen, add the preload option to your bunfig.toml file.\npreload = [\"./preload.ts\"]\n[test]\npreload = [\"./preload.ts\"]\nAnd, run the bun run command.\nbun run index.ts\nFor more details, please refer to the unplugin-typia documentation.\nimport UnpluginTypia from '@ryoppippi/unplugin-typia/bun'\nawait Bun.build({\n\tentrypoints: [\"./index.ts\"],\n\toutdir: \"./out\",\n\tplugins: [UnpluginTypia(/* options */)]\n});\nFor more details, please refer to the unplugin-typia documentation.","webpack#Webpack":"unplugin-typia also supports webpack as well.\n# TYPIA\nnpm install typia\nnpx typia setup\n# WEBPACK + TS-LOADER\nnpm install --save-dev ts-loader\nnpm install --save-dev webpack webpack-cli\n# TYPIA\npnpm install typia\npnpm typia setup --manager pnpm\n# WEBPACK + TS-LOADER\npnpm install --save-dev ts-loader\npnpm install --save-dev webpack webpack-cli\n###########################################\n# YARN BERRY IS NOT SUPPORTED\n###########################################\n# TYPIA\nyarn add typia\nyarn typia setup --manager yarn\n# WEBPACK + TS-LOADER\nyarn add -D ts-loader\nyarn add -D webpack webpack-cli\n# TYPIA\nbun add typia\nbun typia setup\n# WEBPACK + TS-LOADER\nbun add -d ts-loader\nbun add -d webpack webpack-cli\nWhen you're using webpack as a bundler, you can still utilize the transformation mode.Just install ts-loader as well as webpack, and configure webpack.config.js file like below.\nconst path = require(\"path\");\nconst nodeExternals = require(\"webpack-node-externals\");\nmodule.exports = {\n  // CUSTOMIZE HERE\n  entry: [\"./src/index.tsx\"],\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"index.js\",\n  },\n  optimization: {\n    minimize: false,\n  },\n  // JUST KEEP THEM\n  mode: \"development\",\n  target: \"node\",\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        loader: \"ts-loader\",\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".js\"],\n  },\n};\nFrom now on, you can build the single JS file just by running the npx webpack command. By the way, when removing devDependencies for --production install, never forget to add the --ignore-scripts option to prevent the prepare script.\nnpx webpack\nnpm ci --omit=dev --ignore-scripts\npnpm webpack\npnpm install --production --ignore-scripts\nyarn webpack\nrm -rf node_modules\nyarn install --production --ignore-scripts --immutable\nbun webpack\nbun install --production --ignore-scripts\nAdditionally, if you're using typia in the NodeJS project especially for the backend development, Setup Guide Documents of nestia would be helpful. Even though you're not using NestJS, you can still utilize below documents, and \"Single JS file only\" mode would be especially helpful for you.\nNestia > Setup > Webpack\nWith node_modules\nSingle JS file only","nx#NX":"npm install --save typia\nnpx typia setup\npnpm install --save typia\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn typia setup --manager yarn\nbun add typia\nbun typia setup --manager bun\nAfter installing typia like above, and ensuring the prepare script is something similar to ts-patch install you have to modify the tsconfig.lib.json on each @nx/js package to be similar to the below.\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"../../dist/out-tsc\",\n    \"declaration\": true,\n    \"types\": [],\n    \"plugins\": [{ \"transform\": \"typia/lib/transform\" }]\n  },\n  \"include\": [\"**/*.ts\"],\n  \"exclude\": [\"jest.config.ts\", \"**/*.spec.ts\", \"**/*.test.ts\"]\n}\nAfter this, when running nx <package-name>:build it should now output with the Typia transforms applied. But if Typia fails for any reason (for example it considers some type you have to be invalid), this error is not reported back via Nx. Nx will silent swallow these errors from ts-patch/typia, and the resulting transpiled code will not have typia transformations applied. This will result in an error such as the following when running you tests that use typia (nx <package-name>:test), dev versions of your application (nx <package-name>:serve), as well as running your application after building.\nError on typia.createAssert(): no transform has been configured.\nTo debug whether this is an issue with your setup or simply NX just silently swallowing typia errors, you can create a new task in your project.json file similar to the one below.\n \"targets\": {\n    \"build:validate:typia\": {\n      \"executor\": \"nx:run-commands\",\n      \"options\": {\n        \"commands\": [\n          \"tsc --project packages/<package-name>/tsconfig.lib.json --outDir dist/packages/typiaTest\"\n        ],\n      }\n    },\n    ...\n }\nRunning this task will show you the errors from Typia, and allow you to correct them, meaning that using the standard nx <package-name>:build task should now work the way you expect.Note: While Nx has a transformers feature on the @nx/js plugin, that won't work with Typia. The reason is because Nx is expecting a transformer to export a before hook, which Nx then plugs directly into TypeScript via the compiler API. Typia doesn't export that kind of hook, because Typia only works with ts-patch, which abstracts the need for creating a specific before hook in the way Nx wants.","generation#Generation":"# INSTALL TYPIA\nnpm install --save typia\nnpm install --save-dev typescript\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nnpx typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n# INSTALL TYPIA\npnpm install --save typia\npnpm install --save-dev typescript\n# GENERATE TRANSFORMED TYPESCRIPT CODES\npnpm typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n# INSTALL TYPIA\nyarn add typia\nyarn add -D typescript\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nyarn typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n# INSTALL TYPIA\nbun add typia\nbun add -d typescript\nbun typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\nFor frontend projects.If you are using a non-standard TypeScript compiler such as the following, you will need to fall back to generation mode\nNon-standard TypeScript compilers:\nBabel in Create-React-App\nesbuild in Vite -> covered by unplugin-typia\nSWC -> use unplugin-typia with your bundlers ( including next.js, vite, webpack, rollup, etc )\nInstead you should utilize the generation mode.Install typia through npm install command, and run typia generate command. Then, generator of typia reads your TypeScript codes of --input, and writes transformed TypeScript files into the --output directory, like below.For clarification, the input directory should contain one or more TypeScript files which define how you want to verify your associated type assertions. Commonly you will import your TypeScript type, then export a function which validates that type. See below.If you want to specify other TypeScript project file instead of tsconfig.json, you can use --project option.\nimport typia from \"typia\";\nimport { IMember } from \"../structures/IMember\";\nexport const check = typia.createIs<IMember>();\nimport typia from \"typia\";\nimport { IMember } from \"../structures/IMember\";\nexport const check = (input: any): input is IMember => {\n  const $is_uuid = (typia.createIs as any).is_uuid;\n  const $is_email = (typia.createIs as any).is_email;\n  return (\n    \"object\" === typeof input &&\n    null !== input &&\n    \"string\" === typeof input.id &&\n    $is_uuid(input.id) &&\n    \"string\" === typeof input.email &&\n    $is_email(input.email) &&\n    \"number\" === typeof input.age &&\n    19 <= input.age &&\n    100 >= input.age\n  );\n};\nWhy not support non-standard compilers?Non-standard TypeScript compilers are removing every type information, and skipping type checks for rapid compilation. By the way, without those type information, typia can't do anything. This is the reason why typia doesn't support non-standard TypeScript compilers."}},"/docs/utilization/trpc":{"title":"Guide Documents > Utilization Cases > tRPC","data":{"":"import { initTRPC } from \"@trpc/server\";\nimport { v4 } from \"uuid\";\nimport typia from \"typia\";\nimport { IBbsArticle } from \"../structures/IBbsArticle\";\nconst server = initTRPC.create();\nexport const appRouter = server.router({\n  store: server.procedure\n    .input(typia.createAssert<IBbsArticle.IStore>())\n    .output(typia.createAssert<IBbsArticle>())\n    .query(({ input }) => {\n      return {\n        id: v4(),\n        writer: input.writer,\n        title: input.title,\n        body: input.body,\n        created_at: new Date().toString(),\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;"}},"/docs/validators/tags":{"title":"Guide Documents > Runtime Validators > Special Tags","data":{"outline#Outline":"typia can perform additional validation through type tags and comment tags.When you need additional validation logic that is not supported in pure TypeScript type spec, you can use type tags and comment tags for it. For example, if you define a type with intersection symbol like number & typia.tags.Type<\"uint32\"> and validates it, typia will check the target numeric value is unsigned integer or not.Also, in TypeScript (and JavaScript), writing @ character in comment is called Comment Tag and typia utilizes such comment tags for enhancing type validation logic. As you can see from below example code, typia analyzes @tagName value patterned comment tags, and generates optimal validation logic in the compilation level.Therefore, don't be afraid typia uses only pure TypeScript types for type validation schema. Don't be afraid about TypeScript does not support integer type. With those type tags and comment tags, you can express every types in the world.\nQ: How to validate integer type? TypeScript does not support it\nA1: Use type tag number & typia.tags.Type<\"int32\">\nA2: Write a comment tag @type int32 on the target property\nQ: Type Tag vs Comment Tags, which one is better\nA1: Type Tag is recommended because it is much safer and generous\nA2: Comment Tag is designed for legacy JSDoc styled projects","type-tags#Type Tags":"By using type tags, you can utilize additional validation logics.Just import one of type tags from typia, and combine it with target through intersection symbol like number & typia.tags.Type<\"uint32\"> case. If you want to declare an union validation logic, combine | and bracket (()) symbols properly like below:\nnumber & (Type<\"uint32\"> | Type<\"double\">)\nnumber type can be both uint32 and double\n(number & Type<\"int32\">) | (bigint & Type<\"uint64\">)\nnumber is int32\nbigint is uint64\n(number & (Type<\"int32\">)| Type<\"float\">) | (bigint & Type<\"uint64\">)\nnumber can be both int32 and float\nbigint is uint64\nHere is the entire list of type tags that typia basically supports.For reference, when you take a mistake that choosing different target type, TypeScript compiler would block it with compilation error message. Also, if you take a mistake that placing invalid argument on the type, it would also be blocked IDE and compiler. Therefore, have a confidence when using them.\nnumber\nnumber & Type<{keyword}>\nint32\nuint32\nuint64\nint64\nfloat\ndouble\nnumber & Minimum<{number}>\nnumber & Maximum<{number}>\nnumber & ExclusiveMaximum<{number}>\nnumber & ExclusiveMinimum<{number}>\nnumber & MultipleOf<{number}>\nbigint\nbigint & Type<{keyword}>\nint64\nuint64\nbigint & Minimum<{bigint}>\nbigint & Maximum<{bigint}>\nbigint & ExclusiveMaximum<{bigint}>\nbigint & ExclusiveMinimum<{bigint}>\nbigint & MultipleOf<{bigint}>\nstring\nstring & MinLength<{number}>\nstring & MaxLength<{number}>\nstring & Pattern<{regex}>\nstring & Format<{keyword}>\nbyte\npassword\nregex\nuuid\nemail\nhostname\nidn-email\nidn-hostname\niri\niri-reference\nipv4\nipv6\nuri\nuri-reference\nuri-template\nurl\ndate-time\ndate\ntime\nduration\njson-pointer\nrelative-json-pointer\narray\nArray<T> & MinItems<{number}>\nArray<T> & MaxItems<{number}>\nArray<T> & UniqueItems\nAlso, if you need custom validation logic, just make it by yourself referencing Customization section. It is easy to define. For such type safety and generous use case reasons even customization supporting, I recommend you to use type tags instead of comment tags, unless you are maintaining a legacy JSDoc styled project.","comment-tags#Comment Tags":"typia supports those comment tags, too.Here is the entire list of comment tags that typia supports.\nnumber\n@type {string}\nint / int32\nuint / uint32\nint64\nuint64\nfloat\n@minimum {number}\n@maximum {number}\n@exclusiveMinimum {number}\n@exclusiveMaximum {number}\n@multipleOf {number}\nbigint\n@type uint64\n@minimum {bigint}\n@maximum {bigint}\n@exclusiveMinimum {bigint}\n@exclusiveMaximum {bigint}\n@multipleOf {bigint}\nstring\n@minLength {number}\n@maxLength {number}\n@pattern {regex}\n@format {keyword}\nbyte\npassword\nregex\nuuid\nemail\nhostname\nidn-email\nidn-hostname\niri\niri-reference\nipv4\nipv6\nuri\nuri-reference\nuri-template\nurl\ndate-time\ndate\ntime\nduration\njson-pointer\nrelative-json-pointer\narray\n@minItems {number}\n@maxItems {number}\n@uniqueItems\nBy the way, I do not recommend this way, because it can't perform union numeric types, and can be used for only object property type. It can't be used standalone, and cannot be used for element type of Array and Map even when they're declared on object property. Also, When you declare @type int32 statement, target number type be fixed as int32 type, and never can have another numeric type by declaring union statements.Also, those comment tags are not type safe. If you take a mistake when writing a comment tag, it will not be detected by the compiler, and will cause an error at runtime. For example, if you write a miss-spelled keyword like @type unit32, the target number type would be double type, and you can identify it just by running the program (or visiting playground website).\nWhy supports comment tags?\nDespite these disadvantages, the reason for maintaining comment tags is as follows.First, it is to support the legacy JSDoc style that had been used in the JS camp for a long time. If you had developed a legacy project and JSDoc being used, you can use it as is.Second, to support Prisma. If a comment is created in the Prisma Schema through the /// statement as shown below and a type is created, it is converted to a TS comment as it is. And since there is no way that union types, numeric Arrays or Maps are used in Prisma (database) schema, these comment tags are surprisingly compatible with Prisma.","customization#Customization":"Above types are supported by typia basically.If you make a custom type tag extending typia.tags.TagBase<Props> type, and utilize it on your type with intersection symbol like number & Minimum<3>, its validation logic 3 <= $input would be inserted into the compiled JavaScript file.Also, as you can see from the typia.tags.TagBase<Props> type, you have to specify which target type is the tag for, and need to define the tag can be compatible with others or not through exclusive options. If your custom tag has multiple target types, you can support all of those target types by defining validate property as Record<Target, string> type like Type tag case.In the Korean proverb, there's a word that, \"it is much better to do it once than to hear it a hundred times\". Let's see how custom type tag of typia can be defined and utilized through an example code. I'll define three custom tag types, Postfix, Dollar and IsEven.Here is the example code, and I think that it may easy to understand."}},"/":{"title":"Home","data":{"transformer#Transformer":"Guide Documents Â· Playground (Online IDE) Â· Github Repository\ntypia is a transformer library converting TypeScript types to runtime function.If you call one of the typia function, it would be compiled like below. This is the key concept of typia, transforming TypeScript type to a runtime function. The typia.is<T>() function is transformed to a dedicated type checker by analyzing the target type T in the compilation level.This feature enables developers to ensure type safety in their applications, leveraging TypeScript's static typing while also providing runtime validation. Instead of defining additional schemas, you can simply utilize the pure TypeScript type itself.\n//----\n// examples/checkString.ts\n//----\nimport typia, { tags } from \"typia\";\nexport const checkString = typia.createIs<string>();\n//----\n// examples/checkString.js\n//----\nimport typia from \"typia\";\nexport const checkString = (() => {\n  return (input) => \"string\" === typeof input;\n})();","key-features#Key Features":"","sponsors#Sponsors":"Thanks for your support.Your donation encourages typia development.Also, typia is re-distributing half of donations to core contributors of typia.\nnonara/ts-patch\nryoppippi/unplugin-typia"}}}