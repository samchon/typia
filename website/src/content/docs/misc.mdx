---
title: Guide Documents > Miscellaneous
---
import { Tabs } from 'nextra/components'
import Alert from '@mui/material/Alert';
import AlertTitle from '@mui/material/AlertTitle';

import LocalSource from '../../components/LocalSource';
import RemoteSource from "../../components/RemoteSource";

## `misc` module

### `clone()` functions

<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
  <code>IValidation.ts</code>,
  <code>Resolved.ts</code>
]}>
  <Tabs.Tab>
```typescript
export namespace misc {
  export function clone<T>(input: T): T;
  export function assertClone<T>(input: T | unknown): Resolved<T>;
  export function isClone<T>(input: T | unknown): Resolved<T> | null;
  export function validateClone<T>(input: T | unknown): IValidation<Resolved<T>>;

  export function createClone<T>(): (input: T) => Resolved<T>;
  export function createAssertClone<T>(): (input: T | unknown) => Resolved<T>;
  export function createIsClone<T>(): (input: T | unknown) => Resolved<T> | null;
  export function createValidateClone<T>(): (
      input: T | unknown
  ) => IValidation<Resolved<T>>;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/TypeGuardError.ts"
      filename="typia/TypeGuardError.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <RemoteSource 
      url="https://raw.githubusercontent.com/samchon/openapi/refs/heads/master/src/structures/IValidation.ts"
      filename="@samchon/openapi"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/Resolved.ts"
      filename="typia/Resolved.ts"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

Deep copy functions.

When you want to copy an instance, just call `typia.misc.clone()` function. It would perform deep copy including nested objects, so you can get a new instance with same values. Also, if you want type safe deep copy function, you can use `typia.misc.isClone()`, `typia.misc.assertClone()` or `typia.misc.validateClone()` functions instead.

  - `typia.misc.assertClone()`: [`typia.assert<T>()`](./validators/assert) + `typia.misc.clone<T>()`
  - `typia.misc.isClone()`: [`typia.is<T>()`](./validators/is) + `typia.misc.clone<T>()`
  - `typia.misc.validateClone()`: [`typia.validate<T>()`](./validators/validate) + `typia.misc.clone<T>()`

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/src/misc/assertClone.ts"
      filename="examples/src/misc/assertClone.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/bin/misc/assertClone.js"
      filename="examples/bin/misc/assertClone.js"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

### `prune()` functions

<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
  <code>IValidation.ts</code>
]}>
  <Tabs.Tab>
```typescript
export function prune<T>(input: T): void;
export function assertPrune<T>(input: T | unknown): T;
export function isPrune<T>(input: T | unknown): T | null;
export function validatePrune<T>(input: T | unknown): IValidation<T>;

export function createPrune<T>(): (input: T) => void;
export function createAssertPrune<T>(): (input: T | unknown) => T;
export function createIsPrune<T>(): (input: T | unknown) => T | null;
export function createValidatePrune<T>(): (input: T | unknown) => IValidation<T>;
```
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/TypeGuardError.ts"
      filename="typia/TypeGuardError.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <RemoteSource 
      url="https://raw.githubusercontent.com/samchon/openapi/refs/heads/master/src/structures/IValidation.ts"
      filename="@samchon/openapi"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

Deep prune functions.

When you want to remove every extra properties that are not defined in the type including nested objects, you can use `typia.misc.prune<T>()` function. Also, if you want to perform type safe pruning, you can use `typia.misc.isPrune<T>()`, `typia.misc.assertPrune<T>()` or `typia.misc.validatePrune<T>()` functions instead.

  - `typia.misc.isPrune()`: [`typia.is<T>()`](./validators/is) + `typia.misc.prune<T>()`
  - `typia.misc.assertPrune()`: [`typia.assert<T>()`](./validators/assert) + `typia.misc.prune<T>()`
  - `typia.misc.validatePrune()`: [`typia.validate<T>()`](./validators/validate) + `typia.misc.prune<T>()`

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/src/misc/assertPrune.ts"
      filename="examples/src/misc/assertPrune.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/bin/misc/assertPrune.js"
      filename="examples/bin/misc/assertPrune.js"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

### `literals()` function
```typescript
export namespace misc {
  export function literals<
    T extends boolean | number | string | bigint | null,
  >(): T[];
}
```

Union literal type to array.

When you call `typia.misc.literals<T>()` function with union literal type, it returns an array of literal values listed in the generic `T` argument. This `typia.misc.literals<T>` function is useful when you are developing test program, especially handling some discriminated union types.

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/src/misc/literals.ts"
      filename="examples/src/misc/literals.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/bin/misc/literals.js"
      filename="examples/bin/misc/literals.js"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

## `notations` module

### `camel()` functions

<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
  <code>IValidation.ts</code>,
  <code>CamelCase.ts</code>
]}>
  <Tabs.Tab>
```typescript
export namespace notations {
  export function camel<T>(input: T): CamelCase<T>;
  export function assertCamel<T>(input: T | unknown): CamelCase<T>;
  export function isCamel<T>(input: T | unknown): CamelCase<T> | null;
  export function validateCamel<T>(
    input: T | unknown,
  ): IValidation<CamelCase<T>>;

  export function createCamel<T>(): (input: T) => CamelCase<T>;
  export function createAssertCamel<T>(): (input: T | unknown) => CamelCase<T>;
  export function createIsCamel<T>(): (
    input: T | unknown,
  ) => CamelCase<T> | null;
  export function createValidateCamel<T>(): (
    input: T | unknown,
  ) => IValidation<CamelCase<T>>;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/TypeGuardError.ts"
      filename="typia/TypeGuardError.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <RemoteSource 
      url="https://raw.githubusercontent.com/samchon/openapi/refs/heads/master/src/structures/IValidation.ts"
      filename="@samchon/openapi"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/CamelCase.ts"
      filename="typia/CamelCase.ts"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

Camel case converters.

Convert every property names of nested objects to be camel case notation.

When you need type safe functions, you can utilize below them.

  - `typia.notations.assertCamel<T>()`: [`typia.assert<T>()`](./validators/assert) + `typia.notations.camel<T>()`
  - `typia.notations.isCamel<T>`: [`typia.is<T>()`](./validators/is) + `typia.notations.camel<T>()`
  - `typia.notations.validateCamel<T>`: [`typia.validate<T>()`](./validators/validate) + `typia.notations.camel<T>()`

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/src/notations/camel.ts"
      filename="examples/src/notations/camel.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/bin/notations/camel.js"
      filename="examples/bin/notations/camel.js"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

### `pascal()` functions

<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
  <code>IValidation.ts</code>,
  <code>PascalCase.ts</code>
]}>
  <Tabs.Tab>
```typescript
export namespace notations {
  export function pascal<T>(input: T): PascalCase<T>;
  export function assertPascal<T>(input: T | unknown): PascalCase<T>;
  export function isPascal<T>(input: T | unknown): PascalCase<T> | null;
  export function validatePascal<T>(
    input: T | unknown,
  ): IValidation<PascalCase<T>>;

  export function createPascal<T>(): (input: T) => PascalCase<T>;
  export function createAssertPascal<T>(): (
    input: T | unknown,
  ) => PascalCase<T>;
  export function createIsPascal<T>(): (
    input: T | unknown,
  ) => PascalCase<T> | null;
  export function createValidatePascal<T>(): (
    input: T | unknown,
  ) => IValidation<PascalCase<T>>;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/TypeGuardError.ts"
      filename="typia/TypeGuardError.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <RemoteSource 
      url="https://raw.githubusercontent.com/samchon/openapi/refs/heads/master/src/structures/IValidation.ts"
      filename="@samchon/openapi"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/PascalCase.ts"
      filename="typia/PascalCase.ts"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

Pascal case converters.

Convert every property names of nested objects to be pascal case notation.

When you need type safe functions, you can utilize below them.

  - `typia.notations.assertPascal<T>()`: [`typia.assert<T>()`](./validators/assert) + `typia.notations.pascal<T>()`
  - `typia.notations.isPascal<T>`: [`typia.is<T>()`](./validators/is) + `typia.notations.pascal<T>()`
  - `typia.notations.validatePascal<T>`: [`typia.validate<T>()`](./validators/validate) + `typia.notations.pascal<T>()`

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/src/notations/pascal.ts"
      filename="examples/src/notations/pascal.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/bin/notations/pascal.js"
      filename="examples/bin/notations/pascal.js"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

### `snake()` functions

<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
  <code>IValidation.ts</code>,
  <code>SnakeCase.ts</code>
]}>
  <Tabs.Tab>
```typescript
export namespace notations {
  export function snake<T>(input: T): SnakeCase<T>;
  export function assertSnake<T>(input: T | unknown): SnakeCase<T>;
  export function isSnake<T>(input: T | unknown): SnakeCase<T> | null;
  export function validateSnake<T>(
    input: T | unknown,
  ): IValidation<SnakeCase<T>>;

  export function createSnake<T>(): (input: T) => SnakeCase<T>;
  export function createAssertSnake<T>(): (input: T | unknown) => SnakeCase<T>;
  export function createIsSnake<T>(): (
    input: T | unknown,
  ) => SnakeCase<T> | null;
  export function createValidateSnake<T>(): (
    input: T | unknown,
  ) => IValidation<SnakeCase<T>>;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/TypeGuardError.ts"
      filename="typia/TypeGuardError.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <RemoteSource 
      url="https://raw.githubusercontent.com/samchon/openapi/refs/heads/master/src/structures/IValidation.ts"
      filename="@samchon/openapi"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/SnakeCase.ts"
      filename="typia/SnakeCase.ts"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

Snake case converters.

Convert every property names of nested objects to be snake case notation.

When you need type safe functions, you can utilize below them.

  - `typia.notations.assertSnake<T>()`: [`typia.assert<T>()`](./validators/assert) + `typia.notations.snake<T>()`
  - `typia.notations.isSnake<T>`: [`typia.is<T>()`](./validators/is) + `typia.notations.snake<T>()`
  - `typia.notations.validateSnake<T>`: [`typia.validate<T>()`](./validators/validate) + `typia.notations.snake<T>()`

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/src/notations/snake.ts"
      filename="examples/src/notations/snake.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/bin/notations/snake.js"
      filename="examples/bin/notations/snake.js"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

## `http` module

<br/>
<Alert severity="success">
  <AlertTitle> 
    **Nestia Supporting** 
  </AlertTitle>

`http` module has been designed to support the [nestia](https://github.com/samchon/nestia) project.

  - `query()` functions -> [`@TypedQuery()`](https://nestia.io/docs/core/TypedQuery/)
  - `headers()` functions -> [`@TypedHeaders()`](https://nestia.io/docs/core/TypedHeaders/)
  - `parameter()` function -> [`@TypedParam()`](https://nestia.io/docs/core/TypedParam/)

</Alert>

### `query()` functions

<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
  <code>IValidation.ts</code>,
  <code>Resolved.ts</code>
]}>
  <Tabs.Tab>
```typescript
export namespace http {
  export function query<T extends object>(input: Query): Resolved<T>;
  export function assertQuery<T extends object>(input: Query): Resolved<T>;
  export function isQuery<T extends object>(input: Query): Resolved<T> | null;
  export function validateQuery<T extends object>(
    input: Query,
  ): IValidation<Resolved<T>>;

  export function createQuery<T extends object>(): (
    input: Query,
  ) => Resolved<T>;
  export function createAssertQuery<T extends object>(): (
    input: Query,
  ) => Resolved<T>;
  export function createIsQuery<T extends object>(): (
    input: Query,
  ) => Resolved<T> | null;
  export function createValidateQuery<T extends object>(): (
    input: Query,
  ) => IValidation<Resolved<T>>;
}
type Query = string | URLSearchParams;
```
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/TypeGuardError.ts"
      filename="typia/TypeGuardError.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <RemoteSource 
      url="https://raw.githubusercontent.com/samchon/openapi/refs/heads/master/src/structures/IValidation.ts"
      filename="@samchon/openapi"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/Resolved.ts"
      filename="typia/Resolved.ts"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

URL query decoder functions.

`typia.http.query<T>()` is a function decoding a query string or an `URLSearchParams` instance, with automatic type casting to the expected type. When property type be defined as boolean or number type, `typia.http.query<T>()` will cast the value to the expected type when decoding.

By the way, as URL query is not enough to express complex data structures, `typia.http.query<T>()` function has some limitations. If target type `T` is not following those restrictions, compilation errors would be occurred.

  1. Type T must be an object type
  2. Do not allow dynamic property
  3. Only boolean, bigint, number, string or their array types are allowed
  4. By the way, union type never be not allowed

Also, `typia.http.query<T>()` function does not perform validation about the decoded value. Therefore, if you can't sure that input data is following the `T` type, it would better to call one of below functions instead.

  - `typia.http.assertQuery<T>()`: [`typia.assert<T>()`](./validators/assert) + `typia.http.query<T>()`
  - `typia.http.isQuery<T>()`: [`typia.is<T>()`](./validators/is) + `typia.http.query<T>()`
  - `typia.http.validateQuery<T>()`: [`typia.validate<T>()`](./validators/validate) + `typia.http.query<T>()`

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/src/http/query.ts"
      filename="examples/src/http/query.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/bin/http/query.js"
      filename="examples/bin/query.js"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

### `headers()` functions

<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
  <code>IValidation.ts</code>,
  <code>Resolved.ts</code>
]}>
  <Tabs.Tab>
```typescript
export namespace http {
  export function headers<T extends object>(input: Headers): Resolved<T>;
  export function assertHeaders<T extends object>(input: Headers): Resolved<T>;
  export function isHeaders<T extends object>(
    input: Headers,
  ): Resolved<T> | null;
  export function validateHeaders<T extends object>(
    input: Headers,
  ): IValidation<Resolved<T>>;

  export function createHeaders<T extends object>(): (
    input: Headers,
  ) => Resolved<T>;
  export function createAssertHeaders<T extends object>(): (
    input: Headers,
  ) => Resolved<T>;
  export function createIsHeaders<T extends object>(): (
    input: Headers,
  ) => Resolved<T> | null;
  export function createValidateHeaders<T extends object>(): (
    input: Headers,
  ) => IValidation<Resolved<T>>;
}
type Headers = Record<string, string | string[] | undefined>;
```
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/TypeGuardError.ts"
      filename="typia/TypeGuardError.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <RemoteSource 
      url="https://raw.githubusercontent.com/samchon/openapi/refs/heads/master/src/structures/IValidation.ts"
      filename="@samchon/openapi"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/Resolved.ts"
      filename="typia/Resolved.ts"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

Headers decoder (for express and fastify).

`typia.http.headers<t>()` is a function decoding an header instance, with automatic type casting to the expected type. When property type be defined as boolean or number type, `typia.http.headers<t>()` will cast the value to the expected type.

By the way, as HTTP headers are not enough to express complex data structures, `typia.http.headers<t>()` function has some limitations. If target type `T` is not following those restrictions, compilation errors would be occurred.

  1. Type T must be an object type
  2. Do not allow dynamic property
  3. Property key must be lower case
  4. Property value cannot be null, but undefined is possible
  5. Only boolean, bigint, number, string or their array types are allowed
  6. By the way, union type never be not allowed
  7. Property set-cookie must be array type
  8. Those properties cannot be array type
     - age
     - authorization
     - content-length
     - content-type
     - etag
     - expires
     - from
     - host
     - if-modified-since
     - if-unmodified-since
     - last-modified
     - location
     - max-forwards
     - proxy-authorization
     - referer
     - retry-after
     - server
     - user-agent

Also, `typia.http.headers<t>()` function does not perform validation about the decoded value. Therefore, if you can't sure that input data is following the `T` type, it would better to call one of below functions instead.

  - `typia.http.assertHeaders<T>()`: [`typia.assert<T>()`](./validators/assert) + `typia.http.headers<T>()`
  - `typia.http.isHeaders<T>()`: [`typia.is<T>()`](./validators/is) + `typia.http.headers<T>()`
  - `typia.http.validateHeaders<T>()`: [`typia.validate<T>()`](./validators/validate) + `typia.http.headers<T>()`

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/src/http/headers.ts"
      filename="examples/src/http/headers.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/bin/http/headers.js"
      filename="examples/bin/http/headers.js"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

### `parameter()` functions

<Tabs items={[
  <code>typia</code>, 
  <code>TypeGuardError.ts</code>, 
]}>
  <Tabs.Tab>
```typescript
export namespace http {
  export function parameter<T extends Atomic.Type | null>(input: string): T;
  export function createParameter<T extends Atomic.Type | null>(): (
    input: string,
  ) => T;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="src/TypeGuardError.ts"
      filename="typia/TypeGuardError.ts"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>

URL path parameter decoder.

`typia.http.parameter<T>()` is a function decoding a path parameter, with automatic type casting to the expected type. When type T has been defined as boolean or number `type, typia.http.parameter<T>()` will cast the value to the expected type.

Also, `typia.http.parameter<T>()` performs type assertion to the decoded value by combining with assert function. Therefore, when the decoded value is not following the `T` type, `TypeGuardError` would be thrown.

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/src/http/parameter.ts"
      filename="examples/src/http/parameter.ts"
      showLineNumbers />
  </Tabs.Tab>
  <Tabs.Tab>
    <LocalSource 
      path="website/examples/bin/http/parameter.js"
      filename="examples/bin/http/parameter.js"
      showLineNumbers />
  </Tabs.Tab>
</Tabs>
