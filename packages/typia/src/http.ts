import {
  Atomic,
  IReadableURLSearchParams,
  IValidation,
  Resolved,
} from "@typia/interface";

import { TypeGuardError } from "./TypeGuardError";
import { NoTransformConfigurationError } from "./transformers/NoTransformConfigurationError";

/* ===========================================================
    HTTP
      - FORM-DATA
      - QUERY
      - HEADERS
      - PARAMETER
      - FACTORY FUNCTIONS
==============================================================
    FORM-DATA
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * Form data decoder.
 *
 * `typia.http.formData()` is a function decoding `FormData` instance, with
 * automatic type casting to the expected type. When property type is defined as
 * `boolean` or `Blob` type, `typia.http.formData()` will cast the value to the
 * expected type when decoding.
 *
 * By the way, as `FormData` is not enough to express complex data structures,
 * `typia.http.formData()` function has some limitations. If target type `T` is
 * not following those restrictions, compilation errors would be occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array
 *    types are allowed
 * 4. Union types are never allowed
 *
 * Also, `typia.http.formData()` function does not perform validation about the
 * decoded value. Therefore, if you can't sure that input data is following the
 * `T` type, it would better to call one of below functions instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input FormData instance
 * @returns Decoded form FormData
=======
 * Decodes `FormData` into type `T`.
 *
 * Parses a `FormData` instance with automatic type casting. Properties typed as
 * `boolean` or `Blob` are cast to expected types during decoding.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array
 *    types allowed
 * 4. No union types allowed
 *
 * Does not validate the decoded value. For validation, use:
 *
 * - {@link assertFormData} — Throws on type mismatch
 * - {@link isFormData} — Returns `null` on type mismatch
 * - {@link validateFormData} — Returns detailed validation errors
 *
 * @template T Target object type
 * @param input FormData instance to decode
 * @returns Decoded object of type `T`
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function formData<T extends object>(input: FormData): Resolved<T>;

/** @internal */
export function formData(): never {
  NoTransformConfigurationError("http.formData");
}

/**
<<<<<<< HEAD
 * Form data decoder with type assertion.
 *
 * `typia.http.assertFormData()` is a function decoding `FormData` instance,
 * with automatic type casting to the expected type. When property type is
 * defined as `boolean` or `Blob` type, `typia.http.assertFormData()` will cast
 * the value to the expected type when decoding.
 *
 * Also, after decoding, `typia.http.assertFormData()` performs type assertion
 * to the decoded value by combining with {@link assert} function. Therefore,
 * when the decoded value is not following the `T` type, {@link TypeGuardError}
 * or custom error generated by _errorFactory_ would be thrown.
 *
 * By the way, as `FormData` is not enough to express complex data structures,
 * `typia.http.assertFormData()` function has some limitations. If target type
 * `T` is not following those restrictions, compilation errors would be
 * occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array
 *    types are allowed
 * 4. Union types are never allowed
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input FormData instance
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns Decoded form FormData
=======
 * Decodes `FormData` into type `T` with assertion.
 *
 * Parses a `FormData` instance with automatic type casting, then validates the
 * result via {@link assert}. Throws {@link TypeGuardError} on mismatch.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array
 *    types allowed
 * 4. No union types allowed
 *
 * Related functions:
 *
 * - {@link formData} — No validation
 * - {@link isFormData} — Returns `null` instead of throwing
 * - {@link validateFormData} — Returns detailed validation errors
 *
 * @template T Target object type
 * @param input FormData instance to decode
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Decoded object of type `T`
 * @throws {TypeGuardError} When decoded value doesn't conform to type `T`
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertFormData<T extends object>(
  input: FormData,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): Resolved<T>;

/** @internal */
export function assertFormData(): never {
  NoTransformConfigurationError("http.assertFormData");
}

/**
<<<<<<< HEAD
 * Form data decoder with type checking.
 *
 * `typia.http.isFormData()` is a function decoding `FormData` instance, with
 * automatic type casting to the expected type. When property type is defined as
 * `boolean` or `Blob` type, `typia.http.isFormData()` will cast the value to
 * the expected type when decoding.
 *
 * Also, after decoding, `typia.http.isFormData()` performs type checking to the
 * decoded value by combining with {@link is} function. Therefore, when the
 * decoded value is not following the `T` type, `null` value would be returned.
 *
 * By the way, as `FormData` is not enough to express complex data structures,
 * `typia.http.isFormData()` function has some limitations. If target type `T`
 * is not following those restrictions, compilation errors would be occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array
 *    types are allowed
 * 4. Union types are never allowed
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input FormData instance
 * @returns Decoded form FormData or `null` value
=======
 * Decodes `FormData` into type `T` with type checking.
 *
 * Parses a `FormData` instance with automatic type casting, then validates the
 * result via {@link is}. Returns `null` on type mismatch.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array
 *    types allowed
 * 4. No union types allowed
 *
 * Related functions:
 *
 * - {@link formData} — No validation
 * - {@link assertFormData} — Throws instead of returning `null`
 * - {@link validateFormData} — Returns detailed validation errors
 *
 * @template T Target object type
 * @param input FormData instance to decode
 * @returns Decoded object of type `T`, or `null` if invalid
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function isFormData<T extends object>(
  input: FormData,
): Resolved<T> | null;

/** @internal */
export function isFormData(): never {
  NoTransformConfigurationError("http.isFormData");
}

/**
<<<<<<< HEAD
 * Form data decoder with type validation.
 *
 * `typia.http.validateFormData()` is a function decoding `FormData` instance,
 * with automatic type casting to the expected type. When property type is
 * defined as `boolean` or `Blob` type, `typia.http.validateFormData()` will
 * cast the value to the expected type when decoding.
 *
 * Also, after decoding, `typia.http.validateFormData()` performs type
 * validation to the decoded value by combining with {@link validate} function.
 * Therefore, when the decoded value is not following the `T` type,
 * {@link IValidation.IFailure} would be returned. Otherwise, x@xxxx
 * IValidation.ISuccess} would be returned.
 *
 * By the way, as `FormData` is not enough to express complex data structures,
 * `typia.http.validateFormData()` function has some limitations. If target type
 * `T` is not following those restrictions, compilation errors would be
 * occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array
 *    types are allowed
 * 4. Union types are never allowed
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input FormData instance
 * @returns Validation result with decoded form FormData
=======
 * Decodes `FormData` into type `T` with validation.
 *
 * Parses a `FormData` instance with automatic type casting, then validates the
 * result via {@link validate}. Returns {@link IValidation.IFailure} with all
 * errors on mismatch, or {@link IValidation.ISuccess} with decoded value.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array
 *    types allowed
 * 4. No union types allowed
 *
 * Related functions:
 *
 * - {@link formData} — No validation
 * - {@link assertFormData} — Throws on first error
 * - {@link isFormData} — Returns `null` instead of error details
 *
 * @template T Target object type
 * @param input FormData instance to decode
 * @returns Validation result containing decoded value or errors
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function validateFormData<T extends object>(
  input: FormData,
): IValidation<Resolved<T>>;

/** @internal */
export function validateFormData(): never {
  NoTransformConfigurationError("http.validateFormData");
}

/* -----------------------------------------------------------
    QUERY
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * URL query decoder.
 *
 * `typia.http.query()` is a function decoding a query string or an
 * `URLSearchParams` instance, with automatic type casting to the expected type.
 * When property type be defined as `boolean` or `number` type,
 * `typia.http.query()` will cast the value to the expected type when decoding.
 *
 * By the way, as URL query is not enough to express complex data structures,
 * `typia.http.query()` function has some limitations. If target type `T` is not
 * following those restrictions, compilation errors would be occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed
 * 4. Union types are never allowed
 *
 * Also, `typia.http.query()` function does not perform validation about the
 * decoded value. Therefore, if you can't sure that input data is following the
 * `T` type, it would better to call one of below functions instead.
 *
 * - {@link assertQuery}
 * - {@link isQuery}
 * - {@link validateQuery}
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input Query string or URLSearchParams instance
 * @returns Decoded query object
=======
 * Decodes URL query string into type `T`.
 *
 * Parses a query string or `URLSearchParams` instance with automatic type
 * casting. Properties typed as `boolean` or `number` are cast to expected types
 * during decoding.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Only `boolean`, `bigint`, `number`, `string` or their array types allowed
 * 4. No union types allowed
 *
 * Does not validate the decoded value. For validation, use:
 *
 * - {@link assertQuery} — Throws on type mismatch
 * - {@link isQuery} — Returns `null` on type mismatch
 * - {@link validateQuery} — Returns detailed validation errors
 *
 * @template T Target object type
 * @param input Query string or URLSearchParams instance
 * @returns Decoded object of type `T`
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function query<T extends object>(
  input: string | IReadableURLSearchParams,
): Resolved<T>;

/** @internal */
export function query(): never {
  NoTransformConfigurationError("http.query");
}

/**
<<<<<<< HEAD
 * URL query decoder with type assertion.
 *
 * `typia.http.assertQuery()` is a function decoding a query string or an
 * `URLSearchParams` instance, with automatic type casting to the expected type.
 * When property type is defined as `boolean` or `number` type,
 * `typia.http.assertQuery()` will cast the value to the expected type when
 * decoding.
 *
 * Also, after decoding, `typia.http.assertQuery()` performs type assertion to
 * the decoded value by combining with {@link assert} function. Therefore, when
 * the decoded value is not following the `T` type, {@link TypeGuardError} or
 * custom error generated by _errorFactory_ would be thrown.
 *
 * By the way, as URL query is not enough to express complex data structures,
 * `typia.http.assertQuery()` function has some limitations. If target type `T`
 * is notfollowing those restrictions, compilation errors would be occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed
 * 4. Union types are never allowed
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input Query string or URLSearchParams instance
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns Decoded query object
=======
 * Decodes URL query string into type `T` with assertion.
 *
 * Parses a query string or `URLSearchParams` instance with automatic type
 * casting, then validates the result via {@link assert}. Throws
 * {@link TypeGuardError} on mismatch.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Only `boolean`, `bigint`, `number`, `string` or their array types allowed
 * 4. No union types allowed
 *
 * Related functions:
 *
 * - {@link query} — No validation
 * - {@link isQuery} — Returns `null` instead of throwing
 * - {@link validateQuery} — Returns detailed validation errors
 *
 * @template T Target object type
 * @param input Query string or URLSearchParams instance
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Decoded object of type `T`
 * @throws {TypeGuardError} When decoded value doesn't conform to type `T`
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertQuery<T extends object>(
  input: string | IReadableURLSearchParams,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): Resolved<T>;

/** @internal */
export function assertQuery(): never {
  NoTransformConfigurationError("http.assertQuery");
}

/**
<<<<<<< HEAD
 * URL query decoder with type checking.
 *
 * `typia.http.isQuery()` is a function decoding a query string or an
 * `URLSearchParams` instance, with automatic type casting to the expected type.
 * When property type is defined as `boolean` or `number` type,
 * `typia.http.isQuery()` will cast the value to the expected type when
 * decoding.
 *
 * Also, after decoding, `typia.http.isQuery()` performs type checking to the
 * decoded value by combining with {@link is} function. Therefore, when the
 * decoded value is not following the `T` type, `null` value would be returned.
 *
 * By the way, as URL query is not enough to express complex data structures,
 * `typia.http.isQuery()` function has some limitations. If target type `T` is
 * notfollowing those restrictions, compilation errors would be occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed
 * 4. Union types are never allowed
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input Query string or URLSearchParams instance
 * @returns Decoded query object or `null` value
=======
 * Decodes URL query string into type `T` with type checking.
 *
 * Parses a query string or `URLSearchParams` instance with automatic type
 * casting, then validates the result via {@link is}. Returns `null` on type
 * mismatch.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Only `boolean`, `bigint`, `number`, `string` or their array types allowed
 * 4. No union types allowed
 *
 * Related functions:
 *
 * - {@link query} — No validation
 * - {@link assertQuery} — Throws instead of returning `null`
 * - {@link validateQuery} — Returns detailed validation errors
 *
 * @template T Target object type
 * @param input Query string or URLSearchParams instance
 * @returns Decoded object of type `T`, or `null` if invalid
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function isQuery<T extends object>(
  input: string | IReadableURLSearchParams,
): Resolved<T> | null;

/** @internal */
export function isQuery(): never {
  NoTransformConfigurationError("http.isQuery");
}

/**
<<<<<<< HEAD
 * URL query decoder with type validation.
 *
 * `typia.http.validateQuery()` is a function decoding a query string or an
 * `URLSearchParams` instance, with automatic type casting to the expected type.
 * When property type is defined as `boolean` or `number` type,
 * `typia.http.validateQuery()` will cast the value to the expected type when
 * decoding.
 *
 * Also, after decoding, `typia.http.validateQuery()` performs type validation
 * to the decoded value by combining with {@link validate} function. Therefore,
 * when the decoded value is not following the `T` type,
 * {@link IValidation.IFailure} would be returned. Otherwise,
 * {@link IValidation.ISuccess} would be returned.
 *
 * By the way, as URL query is not enough to express complex data structures,
 * `typia.http.validateQuery()` function has some limitations. If target type
 * `T` is notfollowing those restrictions, compilation errors would be
 * occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed
 * 4. Union types are never allowed
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input Query string or URLSearchParams instance
 * @returns Validation result with decoded query object
=======
 * Decodes URL query string into type `T` with validation.
 *
 * Parses a query string or `URLSearchParams` instance with automatic type
 * casting, then validates the result via {@link validate}. Returns
 * {@link IValidation.IFailure} with all errors on mismatch, or
 * {@link IValidation.ISuccess} with decoded value.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Only `boolean`, `bigint`, `number`, `string` or their array types allowed
 * 4. No union types allowed
 *
 * Related functions:
 *
 * - {@link query} — No validation
 * - {@link assertQuery} — Throws on first error
 * - {@link isQuery} — Returns `null` instead of error details
 *
 * @template T Target object type
 * @param input Query string or URLSearchParams instance
 * @returns Validation result containing decoded value or errors
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function validateQuery<T extends object>(
  input: string | IReadableURLSearchParams,
): IValidation<Resolved<T>>;

/** @internal */
export function validateQuery(): never {
  NoTransformConfigurationError("http.validateQuery");
}

/* -----------------------------------------------------------
    HEADERS
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * Headers decoder (for express and fastify).
 *
 * `typia.http.headers()` is a function decoding an header instance, with
 * automatic type casting to the expected type. When property type is defined as
 * `boolean` or `number` type, `typia.http.headers()` will cast the value to the
 * expected type.
 *
 * By the way, as HTTP headers are not enough to express complex data
 * structures, `typia.http.headers()` function has some limitations. If target
 * type `T` is not following those restrictions, compilation errors would be
 * occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Property key must be lower case
 * 4. Property value cannot be `null`, but `undefined` is possible
 * 5. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed
 * 6. Union types are never allowed
 * 7. Property `set-cookie` must be array type
 * 8. Those properties cannot be array type
 *
 * - Age
 * - Authorization
 * - Content-length
 * - Content-type
 * - Etag
 * - Expires
 * - From
 * - Host
 * - If-modified-since
 * - If-unmodified-since
 * - Last-modified
 * - Location
 * - Max-forwards
 * - Proxy-authorization
 * - Referer
 * - Retry-after
 * - Server
 * - User-agent
 *
 * Also, `typia.http.headers()` function does not perform validation about the
 * decoded value. Therefore, if you can't sure that input data is following the
 * `T` type, it would better to call one of below functions instead.
 *
 * - {@link assertHeaders}
 * - {@link isHeaders}
 * - {@link validateHeaders}
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input Query string or URLSearchParams instance
 * @returns Decoded headers object
=======
 * Decodes HTTP headers into type `T`.
 *
 * Parses HTTP headers object with automatic type casting. Properties typed as
 * `boolean` or `number` are cast to expected types during decoding. Compatible
 * with Express and Fastify request headers.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Property keys must be lowercase
 * 4. Property values cannot be `null` (but `undefined` is allowed)
 * 5. Only `boolean`, `bigint`, `number`, `string` or their array types allowed
 * 6. No union types allowed
 * 7. Property `set-cookie` must be array type
 * 8. These properties cannot be array type: `age`, `authorization`,
 *    `content-length`, `content-type`, `etag`, `expires`, `from`, `host`,
 *    `if-modified-since`, `if-unmodified-since`, `last-modified`, `location`,
 *    `max-forwards`, `proxy-authorization`, `referer`, `retry-after`, `server`,
 *    `user-agent`
 *
 * Does not validate the decoded value. For validation, use:
 *
 * - {@link assertHeaders} — Throws on type mismatch
 * - {@link isHeaders} — Returns `null` on type mismatch
 * - {@link validateHeaders} — Returns detailed validation errors
 *
 * @template T Target object type
 * @param input Headers object from HTTP request
 * @returns Decoded object of type `T`
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function headers<T extends object>(
  input: Record<string, string | string[] | undefined>,
): Resolved<T>;

/** @internal */
export function headers(): never {
  NoTransformConfigurationError("http.headers");
}

/**
<<<<<<< HEAD
 * Headers decoder with type assertion (for express and fastify).
 *
 * `typia.http.assertHeaders()` is a function decoding an header instance, with
 * automatic type casting to the expected type. When property type is defined as
 * `boolean` or `number` type, `typia.http.headers()` will cast the value to the
 * expected type.
 *
 * Also, after decoding, `typia.http.assertHeaders()` performs type assertion to
 * the decoded value by combining with {@link assert} function. Therefore, when
 * the decoded value is not following the `T` type, {@link TypeGuardError} or
 * custom error generated by _errorFactory_ would be thrown.
 *
 * By the way, as HTTP headers are not enough to express complex data
 * structures, `typia.http.headers()` function has some limitations. If target
 * type `T` is not following those restrictions, compilation errors would be
 * occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Property key must be lower case
 * 4. Property value cannot be `null`, but `undefined` is possible
 * 5. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed
 * 6. Union types are never allowed
 * 7. Property `set-cookie` must be array type
 * 8. Those properties cannot be array type
 *
 * - Age
 * - Authorization
 * - Content-length
 * - Content-type
 * - Etag
 * - Expires
 * - From
 * - Host
 * - If-modified-since
 * - If-unmodified-since
 * - Last-modified
 * - Location
 * - Max-forwards
 * - Proxy-authorization
 * - Referer
 * - Retry-after
 * - Server
 * - User-agent
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input Query string or URLSearchParams instance
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns Decoded headers object
=======
 * Decodes HTTP headers into type `T` with assertion.
 *
 * Parses HTTP headers object with automatic type casting, then validates the
 * result via {@link assert}. Throws {@link TypeGuardError} on mismatch.
 * Compatible with Express and Fastify request headers.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Property keys must be lowercase
 * 4. Property values cannot be `null` (but `undefined` is allowed)
 * 5. Only `boolean`, `bigint`, `number`, `string` or their array types allowed
 * 6. No union types allowed
 * 7. Property `set-cookie` must be array type
 * 8. These properties cannot be array type: `age`, `authorization`,
 *    `content-length`, `content-type`, `etag`, `expires`, `from`, `host`,
 *    `if-modified-since`, `if-unmodified-since`, `last-modified`, `location`,
 *    `max-forwards`, `proxy-authorization`, `referer`, `retry-after`, `server`,
 *    `user-agent`
 *
 * Related functions:
 *
 * - {@link headers} — No validation
 * - {@link isHeaders} — Returns `null` instead of throwing
 * - {@link validateHeaders} — Returns detailed validation errors
 *
 * @template T Target object type
 * @param input Headers object from HTTP request
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Decoded object of type `T`
 * @throws {TypeGuardError} When decoded value doesn't conform to type `T`
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertHeaders<T extends object>(
  input: Record<string, string | string[] | undefined>,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): Resolved<T>;

/** @internal */
export function assertHeaders(): never {
  NoTransformConfigurationError("http.assertHeaders");
}

/**
<<<<<<< HEAD
 * > You must configure the generic argument `T`.
 *
 * Headers decoder with type checking (for express and fastify).
 *
 * `typia.http.isHeaders()` is a function decoding an header instance, with
 * automatic type casting to the expected type. When property type is defined as
 * `boolean` or `number` type, `typia.http.headers()` will cast the value to the
 * expected type.
 *
 * Also, after decoding, `typia.http.isHeaders()` performs type checking to the
 * decoded value by combining with {@link is} function. Therefore, when the
 * decoded value is not following the `T` type, `null` value would be returned.
 *
 * By the way, as HTTP headers are not enough to express complex data
 * structures, `typia.http.headers()` function has some limitations. If target
 * type `T` is not following those restrictions, compilation errors would be
 * occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Property key must be lower case
 * 4. Property value cannot be `null`, but `undefined` is possible
 * 5. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed
 * 6. Union types are never allowed
 * 7. Property `set-cookie` must be array type
 * 8. Those properties cannot be array type
 *
 * - Age
 * - Authorization
 * - Content-length
 * - Content-type
 * - Etag
 * - Expires
 * - From
 * - Host
 * - If-modified-since
 * - If-unmodified-since
 * - Last-modified
 * - Location
 * - Max-forwards
 * - Proxy-authorization
 * - Referer
 * - Retry-after
 * - Server
 * - User-agent
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input Query string or URLSearchParams instance
 * @returns Decoded headers object or `null` value
=======
 * Decodes HTTP headers into type `T` with type checking.
 *
 * Parses HTTP headers object with automatic type casting, then validates the
 * result via {@link is}. Returns `null` on type mismatch. Compatible with
 * Express and Fastify request headers.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Property keys must be lowercase
 * 4. Property values cannot be `null` (but `undefined` is allowed)
 * 5. Only `boolean`, `bigint`, `number`, `string` or their array types allowed
 * 6. No union types allowed
 * 7. Property `set-cookie` must be array type
 * 8. These properties cannot be array type: `age`, `authorization`,
 *    `content-length`, `content-type`, `etag`, `expires`, `from`, `host`,
 *    `if-modified-since`, `if-unmodified-since`, `last-modified`, `location`,
 *    `max-forwards`, `proxy-authorization`, `referer`, `retry-after`, `server`,
 *    `user-agent`
 *
 * Related functions:
 *
 * - {@link headers} — No validation
 * - {@link assertHeaders} — Throws instead of returning `null`
 * - {@link validateHeaders} — Returns detailed validation errors
 *
 * @template T Target object type
 * @param input Headers object from HTTP request
 * @returns Decoded object of type `T`, or `null` if invalid
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function isHeaders<T extends object>(
  input: Record<string, string | string[] | undefined>,
): Resolved<T> | null;

/** @internal */
export function isHeaders(): never {
  NoTransformConfigurationError("http.isHeaders");
}

/**
<<<<<<< HEAD
 * Headers decoder with type validation (for express and fastify).
 *
 * `typia.http.validateHeaders()` is a function decoding an header instance,
 * with automatic type casting to the expected type. When property type is
 * defined as `boolean` or `number` type, `typia.http.headers()` will cast the
 * value to the expected type.
 *
 * Also, after decoding, `typia.http.validateHeaders()` performs type assertion
 * to the decoded value by combining with {@link validate} function. Therefore,
 * when the decoded value is not following the `T` type,
 * {@link IValidation.IError} would be returned. Otherwise,
 * {@link IValidation.ISuccess} be returned.
 *
 * By the way, as HTTP headers are not enough to express complex data
 * structures, `typia.http.headers()` function has some limitations. If target
 * type `T` is not following those restrictions, compilation errors would be
 * occurred.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Property key must be lower case
 * 4. Property value cannot be `null`, but `undefined` is possible
 * 5. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed
 * 6. Union types are never allowed
 * 7. Property `set-cookie` must be array type
 * 8. Those properties cannot be array type
 *
 * - Age
 * - Authorization
 * - Content-length
 * - Content-type
 * - Etag
 * - Expires
 * - From
 * - Host
 * - If-modified-since
 * - If-unmodified-since
 * - Last-modified
 * - Location
 * - Max-forwards
 * - Proxy-authorization
 * - Referer
 * - Retry-after
 * - Server
 * - User-agent
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Expected type of decoded value
 * @param input Query string or URLSearchParams instance
 * @returns Decoded headers object
=======
 * Decodes HTTP headers into type `T` with validation.
 *
 * Parses HTTP headers object with automatic type casting, then validates the
 * result via {@link validate}. Returns {@link IValidation.IFailure} with all
 * errors on mismatch, or {@link IValidation.ISuccess} with decoded value.
 * Compatible with Express and Fastify request headers.
 *
 * Type `T` constraints:
 *
 * 1. Must be an object type
 * 2. No dynamic properties allowed
 * 3. Property keys must be lowercase
 * 4. Property values cannot be `null` (but `undefined` is allowed)
 * 5. Only `boolean`, `bigint`, `number`, `string` or their array types allowed
 * 6. No union types allowed
 * 7. Property `set-cookie` must be array type
 * 8. These properties cannot be array type: `age`, `authorization`,
 *    `content-length`, `content-type`, `etag`, `expires`, `from`, `host`,
 *    `if-modified-since`, `if-unmodified-since`, `last-modified`, `location`,
 *    `max-forwards`, `proxy-authorization`, `referer`, `retry-after`, `server`,
 *    `user-agent`
 *
 * Related functions:
 *
 * - {@link headers} — No validation
 * - {@link assertHeaders} — Throws on first error
 * - {@link isHeaders} — Returns `null` instead of error details
 *
 * @template T Target object type
 * @param input Headers object from HTTP request
 * @returns Validation result containing decoded value or errors
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function validateHeaders<T extends object>(
  input: Record<string, string | string[] | undefined>,
): IValidation<Resolved<T>>;

/** @internal */
export function validateHeaders(): never {
  NoTransformConfigurationError("http.validateHeaders");
}

/* -----------------------------------------------------------
    PARAMETER
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * URL path parameter decoder.
 *
 * `typia.http.parameter()` is a function decoding a path parameter, with
 * automatic type casting to the expected type. When type `T` has been defined
 * as `boolean` or `number` type, `typia.http.parameter()` will cast the value
 * to the expected type.
 *
 * Also, `typia.http.parameter()` performs type assertion to the decoded value
 * by combining with {@link assert} function. Therefore, when the decoded value
 * is not following the `T` type, {@link TypeGuardError} would be thrown.
 *
 * @template T Expected type of decoded value
 * @param input Path parameter string
 * @returns Decoded path parameter value
=======
 * Decodes URL path parameter into type `T`.
 *
 * Parses a path parameter string with automatic type casting. When type `T` is
 * `boolean` or `number`, casts the string value to the expected type. Also
 * performs type assertion via {@link assert}, throwing {@link TypeGuardError} on
 * mismatch.
 *
 * @template T Target atomic type (`boolean`, `bigint`, `number`, `string`, or
 *   `null`)
 * @param input Path parameter string
 * @returns Decoded value of type `T`
 * @throws {TypeGuardError} When decoded value doesn't conform to type `T`
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function parameter<T extends Atomic.Type | null>(
  input: string,
): Resolved<T>;

/** @internal */
export function parameter(): never {
  NoTransformConfigurationError("http.parameter");
}

/* -----------------------------------------------------------
    FACTORY FUNCTIONS
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * Creates a reusable {@link formdata} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the formdata object
 * @throws Compile error
=======
 * Creates reusable {@link formData} function.
 *
 * @template T Target object type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createFormData(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link formdata} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the formdata object
 * @returns A reusable `formdata` function
=======
 * Creates reusable {@link formData} function.
 *
 * @template T Target object type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createFormData<T extends object>(): (input: FormData) => T;

/** @internal */
export function createFormData<T>(): (input: FormData) => T {
  NoTransformConfigurationError("http.createFormData");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertFormData} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the formdata object
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @throws Compile error
=======
 * Creates reusable {@link assertFormData} function.
 *
 * @template T Target object type
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createAssertFormData(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertFormData} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the formdata object
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns A reusable `assertFormData` function
=======
 * Creates reusable {@link assertFormData} function.
 *
 * @template T Target object type
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createAssertFormData<T extends object>(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): (input: FormData) => T;

/** @internal */
export function createAssertFormData<T>(): (input: FormData) => T {
  NoTransformConfigurationError("http.createAssertFormData");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link isFormData} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the formdata object
 * @throws Compile error
=======
 * Creates reusable {@link isFormData} function.
 *
 * @template T Target object type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createIsFormData(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link isFormData} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the formdata object
 * @returns A reusable `isFormData` function
=======
 * Creates reusable {@link isFormData} function.
 *
 * @template T Target object type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createIsFormData<T extends object>(): (
  input: FormData,
) => T | null;

/** @internal */
export function createIsFormData<T>(): (input: FormData) => T | null {
  NoTransformConfigurationError("http.createIsFormData");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link validateFormData} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the formdata object
 * @throws Compile error
=======
 * Creates reusable {@link validateFormData} function.
 *
 * @template T Target object type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createValidateFormData(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link validateFormData} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the formdata object
 * @returns A reusable `validateFormData` function
=======
 * Creates reusable {@link validateFormData} function.
 *
 * @template T Target object type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createValidateFormData<T extends object>(): (
  input: FormData,
) => IValidation<Resolved<T>>;

/** @internal */
export function createValidateFormData<T>(): (
  input: FormData,
) => IValidation<Resolved<T>> {
  NoTransformConfigurationError("http.createValidateFormData");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link query} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the query object
 * @throws Compile error
=======
 * Creates reusable {@link query} function.
 *
 * @template T Target object type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createQuery(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link query} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the query object
 * @returns A reusable `query` function
=======
 * Creates reusable {@link query} function.
 *
 * @template T Target object type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createQuery<T extends object>(): (
  input: string | IReadableURLSearchParams,
) => T;

/** @internal */
export function createQuery<T>(): (
  input: string | IReadableURLSearchParams,
) => T {
  NoTransformConfigurationError("http.createQuery");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertQuery} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the query object
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @throws Compile error
=======
 * Creates reusable {@link assertQuery} function.
 *
 * @template T Target object type
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createAssertQuery(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertQuery} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the query object
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns A reusable `assertQuery` function
=======
 * Creates reusable {@link assertQuery} function.
 *
 * @template T Target object type
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createAssertQuery<T extends object>(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): (input: string | IReadableURLSearchParams) => T;

/** @internal */
export function createAssertQuery<T>(): (
  input: string | IReadableURLSearchParams,
) => T {
  NoTransformConfigurationError("http.createAssertQuery");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link isQuery} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the query object
 * @throws Compile error
=======
 * Creates reusable {@link isQuery} function.
 *
 * @template T Target object type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createIsQuery(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link isQuery} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the query object
 * @returns A reusable `isQuery` function
=======
 * Creates reusable {@link isQuery} function.
 *
 * @template T Target object type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createIsQuery<T extends object>(): (
  input: string | IReadableURLSearchParams,
) => T | null;

/** @internal */
export function createIsQuery<T>(): (
  input: string | IReadableURLSearchParams,
) => T | null {
  NoTransformConfigurationError("http.createIsQuery");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link validateQuery} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the query object
 * @throws Compile error
=======
 * Creates reusable {@link validateQuery} function.
 *
 * @template T Target object type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createValidateQuery(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link validateQuery} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the query object
 * @returns A reusable `validateQuery` function
=======
 * Creates reusable {@link validateQuery} function.
 *
 * @template T Target object type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createValidateQuery<T extends object>(): (
  input: string | IReadableURLSearchParams,
) => IValidation<Resolved<T>>;

/** @internal */
export function createValidateQuery<T>(): (
  input: string | IReadableURLSearchParams,
) => IValidation<Resolved<T>> {
  NoTransformConfigurationError("http.createValidateQuery");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link headers} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the headers object
 * @throws Compile error
=======
 * Creates reusable {@link headers} function.
 *
 * @template T Target object type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createHeaders(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link headers} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the headers object
 * @returns A reusable `headers` function
=======
 * Creates reusable {@link headers} function.
 *
 * @template T Target object type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createHeaders<T extends object>(): (
  input: Record<string, string | string[] | undefined>,
) => T;

/** @internal */
export function createHeaders<T>(): (
  input: Record<string, string | string[] | undefined>,
) => T {
  NoTransformConfigurationError("http.createHeaders");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertHeaders} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the headers object
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @throws Compile error
=======
 * Creates reusable {@link assertHeaders} function.
 *
 * @template T Target object type
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createAssertHeaders(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertHeaders} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the headers object
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns A reusable `assertHeaders` function
=======
 * Creates reusable {@link assertHeaders} function.
 *
 * @template T Target object type
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createAssertHeaders<T extends object>(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): (input: Record<string, string | string[] | undefined>) => T;

/** @internal */
export function createAssertHeaders<T>(): (
  input: Record<string, string | string[] | undefined>,
) => T {
  NoTransformConfigurationError("http.createAssertHeaders");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link isHeaders} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the headers object
 * @throws Compile error
=======
 * Creates reusable {@link isHeaders} function.
 *
 * @template T Target object type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createIsHeaders(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link isHeaders} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the headers object
 * @returns A reusable `isHeaders` function
=======
 * Creates reusable {@link isHeaders} function.
 *
 * @template T Target object type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createIsHeaders<T extends object>(): (
  input: Record<string, string | string[] | undefined>,
) => T | null;

/** @internal */
export function createIsHeaders<T>(): (
  input: Record<string, string | string[] | undefined>,
) => T | null {
  NoTransformConfigurationError("http.createIsHeaders");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link validateHeaders} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the headers object
 * @throws Compile error
=======
 * Creates reusable {@link validateHeaders} function.
 *
 * @template T Target object type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createValidateHeaders(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link validateHeaders} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the headers object
 * @returns A reusable `validateHeaders` function
=======
 * Creates reusable {@link validateHeaders} function.
 *
 * @template T Target object type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createValidateHeaders<T extends object>(): (
  input: Record<string, string | string[] | undefined>,
) => IValidation<Resolved<T>>;

/** @internal */
export function createValidateHeaders<T>(): (
  input: Record<string, string | string[] | undefined>,
) => IValidation<Resolved<T>> {
  NoTransformConfigurationError("http.createValidateHeaders");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link parameter} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the parameter value
 * @throws Compile error
=======
 * Creates reusable {@link parameter} function.
 *
 * @template T Target atomic type
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createParameter(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link parameter} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T The type of the parameter value
 * @returns A reusable `parameter` function
=======
 * Creates reusable {@link parameter} function.
 *
 * @template T Target atomic type
 * @returns Reusable decoder function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createParameter<T extends Atomic.Type | null>(): (
  input: string,
) => T;

/** @internal */
export function createParameter<T extends Atomic.Type | null>(): (
  input: string,
) => T {
  NoTransformConfigurationError("http.createParameter");
}
