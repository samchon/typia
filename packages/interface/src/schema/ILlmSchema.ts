<<<<<<< HEAD
import { IJsonSchemaAttribute } from "./IJsonSchemaAttribute";

/**
 * Type schema info for LLM (Large Language Model) function calling.
 *
 * ## Overview
 *
 * `ILlmSchema` is a type schema info for LLM function calling, designed to be
 * compatible with multiple LLM providers while following the JSON schema
 * specification.
 *
 * ## Specification
 *
 * `ILlmSchema` basically follows the JSON schema definition of the OpenAPI v3.1
 * specification; {@link OpenApiV3_1.IJsonSchema}.
 *
 * However, it deviates from the standard JSON schema specification and omits
 * many features to ensure compatibility across different LLM providers and
 * their function calling requirements.
 *
 * ## Differences from OpenAPI v3.1
 *
 * Here is the list of how `ILlmSchema` is different with the OpenAPI v3.1 JSON
 * schema:
 *
 * - Decompose mixed type: {@link OpenApiV3_1.IJsonSchema.IMixed}
 * - Resolve nullable property:
 *   {@link OpenApiV3_1.IJsonSchema.__ISignificant.nullable}
 * - Tuple type is banned: {@link OpenApiV3_1.IJsonSchema.ITuple.prefixItems}
 * - Constant type is banned: {@link OpenApiV3_1.IJsonSchema.IConstant}
 * - Merge {@link OpenApiV3_1.IJsonSchema.IOneOf} to {@link ILlmSchema.IAnyOf}
 * - Merge {@link OpenApiV3_1.IJsonSchema.IAllOf} to {@link ILlmSchema.IObject}
 * - Merge {@link OpenApiV3_1.IJsonSchema.IRecursiveReference} to
 *   {@link ILlmSchema.IReference}
 *
 * ## Differences from OpenApi.IJsonSchema
 *
 * Compared to {@link OpenApi.IJsonSchema}, the emended JSON schema
 * specification:
 *
 * - {@link ILlmSchema.IAnyOf} instead of {@link OpenApi.IJsonSchema.IOneOf}
 * - {@link ILlmSchema.IParameters.$defs} instead of
 *   {@link OpenApi.IJsonSchema.IComponents.schemas}
 * - Do not support {@link OpenApi.IJsonSchema.ITuple} type
 * - {@link ILlmSchema.properties} and {@link ILlmSchema.required} are always
 *   defined
 *
 * ## Strict Mode
 *
 * When {@link ILlmSchema.IConfig.strict} mode is enabled, the schema
 * transformation follows OpenAI's structured output requirements:
 *
 * - Every {@link ILlmSchema.IObject.additionalProperties} is forced to `false`
 * - Every property in {@link ILlmSchema.IObject.properties} becomes
 *   {@link ILlmSchema.IObject.required}
 * - All constraint properties are removed from the schema and moved to
 *   {@link IJsonSchemaAttribute.description} in a JSDoc-like format:
 *
 *   - Numeric constraints: `minimum`, `maximum`, `exclusiveMinimum`,
 *       `exclusiveMaximum`, `multipleOf`
 *   - String constraints: `minLength`, `maxLength`, `pattern`, `format`,
 *       `contentMediaType`
 *   - Array constraints: `minItems`, `maxItems`, `uniqueItems`
 *   - Example: `@minimum 0`, `@maximum 100`, `@format uuid`
=======
import { tags } from "../index";
import { IJsonSchemaAttribute } from "./IJsonSchemaAttribute";

/**
 * Type schema for LLM function calling.
 *
 * `ILlmSchema` is a JSON Schema subset designed for LLM function calling
 * compatibility. Most LLMs (OpenAI GPT, Anthropic Claude, Google Gemini, etc.)
 * do not fully support JSON Schema, so this simplified schema omits unsupported
 * features like tuples, `const`, and mixed union types.
 *
 * Generated by `typia.llm.schema<T>()` for single types or included in
 * {@link ILlmApplication} via `typia.llm.application<Class>()`. Shared type
 * definitions use `$defs` with `$ref` references to reduce duplication and
 * handle recursive structures.
 *
 * Set {@link ILlmSchema.IConfig.strict} to `true` for OpenAI's structured output
 * mode, which requires all properties to be `required` and
 * `additionalProperties: false`.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 *
 * @author Jeongho Nam - https://github.com/samchon
 */
export type ILlmSchema =
  | ILlmSchema.IBoolean
  | ILlmSchema.IInteger
  | ILlmSchema.INumber
  | ILlmSchema.IString
  | ILlmSchema.IArray
  | ILlmSchema.IObject
  | ILlmSchema.IReference
  | ILlmSchema.IAnyOf
  | ILlmSchema.INull
  | ILlmSchema.IUnknown;
export namespace ILlmSchema {
<<<<<<< HEAD
  /** Configuration for the LLM schema composition. */
  export interface IConfig {
    /**
     * Whether to allow reference type in everywhere.
     *
     * If you configure this property to `false`, most of reference types
     * represented by {@link ILlmSchema.IReference} would be escaped to a plain
     * type unless recursive type comes.
     *
     * This is because some LLM models do not understand the reference type
     * well, and even the modern version of LLM sometimes occur the
     * hallucination.
     *
     * However, the reference type makes the schema size smaller, so that
     * reduces the LLM token cost. Therefore, if you're using the modern version
     * of LLM, and want to reduce the LLM token cost, you can configure this
     * property to `true`.
=======
  /**
   * Configuration options for LLM schema generation.
   *
   * Controls how TypeScript types are converted to LLM-compatible JSON schemas.
   * These settings affect reference handling and OpenAI structured output
   * compatibility.
   */
  export interface IConfig {
    /**
     * Whether to allow `$ref` references everywhere.
     *
     * When `false`, references are inlined except for recursive types.
     * References reduce token cost but may cause hallucination.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     *
     * @default true
     */
    reference: boolean;

    /**
<<<<<<< HEAD
     * Whether to apply the strict mode.
     *
     * If you configure this property to `true`, the LLM function calling does
     * not allow optional properties and dynamic key typed properties in the
     * {@link ILlmSchema.IObject} type. In other words, when strict mode is
     * enabled, {@link ILlmSchema.IObject.additionalProperties} is fixed to
     * `false`, and every property must be {@link ILlmSchema.IObject.required}.
     *
     * However, the strict mode actually shows lower performance in practice. If
     * you utilize the {@link typia.validate} function and give its validation
     * feedback to the LLM, the performance is much better than the strict
     * mode.
     *
     * Therefore, I recommend you to just turn off the strict mode and utilize
     * the {@link typia.validate} function instead.
=======
     * Whether to enable strict mode (OpenAI structured output).
     *
     * When `true`, all properties become required and `additionalProperties` is
     * forced to `false`.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     *
     * @default false
     */
    strict: boolean;
  }

  /**
<<<<<<< HEAD
   * Type for function parameters.
   *
   * `ILlmSchema.IParameters` defines a function's parameters as a keyword
   * object type, where each property represents a named parameter.
   *
   * It can also be used for structured output metadata to define the expected
   * format of LLM responses.
   */
  export interface IParameters extends Omit<IObject, "additionalProperties"> {
    /**
     * Collection of the named types.
     *
     * This record would be filled when {@link IConfig.reference} is `true`, or
     * recursive type comes.
=======
   * Function parameters schema with shared type definitions.
   *
   * Extends the object schema to include a `$defs` map for named type
   * definitions that can be referenced via `$ref`. This structure allows
   * recursive types and reduces schema duplication.
   *
   * The `additionalProperties` is always `false` for parameters to ensure
   * strict argument validation and prevent unexpected properties.
   */
  export interface IParameters extends Omit<IObject, "additionalProperties"> {
    /**
     * Named schema definitions for reference.
     *
     * Contains type definitions that can be referenced throughout the schema
     * using `$ref: "#/$defs/TypeName"`. Essential for recursive types and
     * shared structures.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     */
    $defs: Record<string, ILlmSchema>;

    /**
<<<<<<< HEAD
     * Additional properties information.
     *
     * The `additionalProperties` defines the type schema for additional
     * properties that are not listed in the {@link properties}.
     *
     * By the way, it is not allowed at the parameters level.
=======
     * Whether additional properties are allowed.
     *
     * Always `false` for function parameters to ensure strict type checking.
     * This prevents LLMs from hallucinating extra properties.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     */
    additionalProperties: false;
  }

<<<<<<< HEAD
  /** Boolean type info. */
  export interface IBoolean extends IJsonSchemaAttribute.IBoolean {
    /** Enumeration values. */
    enum?: Array<boolean>;

    /** Default value. */
    default?: boolean;
  }

  /** Integer type info. */
  export interface IInteger extends IJsonSchemaAttribute.IInteger {
    /** Enumeration values. */
    enum?: Array<number>;

    /**
     * Default value.
     *
     * @type int64
     */
    default?: number;

    /**
     * Minimum value restriction.
     *
     * @type int64
     */
    minimum?: number;

    /**
     * Maximum value restriction.
     *
     * @type int64
     */
    maximum?: number;

    /**
     * Exclusive minimum value restriction.
     *
     * @type int64
     */
    exclusiveMinimum?: number;

    /**
     * Exclusive maximum value restriction.
     *
     * @type int64
     */
    exclusiveMaximum?: number;

    /**
     * Multiple of value restriction.
     *
     * @type uint64
     * @exclusiveMinimum 0
     */
    multipleOf?: number;
  }

  /** Number (double) type info. */
  export interface INumber extends IJsonSchemaAttribute.INumber {
    /** Enumeration values. */
    enum?: Array<number>;

    /** Default value. */
    default?: number;

    /** Minimum value restriction. */
    minimum?: number;

    /** Maximum value restriction. */
    maximum?: number;

    /** Exclusive minimum value restriction. */
    exclusiveMinimum?: number;

    /** Exclusive maximum value restriction. */
    exclusiveMaximum?: number;

    /**
     * Multiple of value restriction.
     *
     * @exclusiveMinimum 0
     */
    multipleOf?: number;
  }

  /** String type info. */
  export interface IString extends IJsonSchemaAttribute.IString {
    /** Enumeration values. */
    enum?: Array<string>;

    /** Default value. */
    default?: string;

    /** Format restriction. */
=======
  /**
   * Boolean type schema.
   *
   * Represents a JSON Schema boolean type with optional enum constraints and
   * default value. Used for true/false parameters and flags.
   */
  export interface IBoolean extends IJsonSchemaAttribute.IBoolean {
    /**
     * Allowed boolean values.
     *
     * Restricts the value to specific boolean literals. Typically unused since
     * booleans only have two possible values, but supported for consistency
     * with other types.
     */
    enum?: Array<boolean>;

    /**
     * Default value when not provided.
     *
     * The boolean value to use when the LLM omits this parameter.
     */
    default?: boolean;
  }

  /**
   * Integer type schema.
   *
   * Represents a JSON Schema integer type with numeric constraints. Maps to
   * TypeScript `number` with integer validation. Supports range constraints,
   * enum restrictions, and divisibility checks.
   */
  export interface IInteger extends IJsonSchemaAttribute.IInteger {
    /**
     * Allowed integer values.
     *
     * Restricts the value to specific integer literals. Useful for representing
     * enum-like integer codes or limited value sets.
     */
    enum?: Array<number & tags.Type<"int64">>;

    /**
     * Default value when not provided.
     *
     * The integer value to use when the LLM omits this parameter.
     */
    default?: number & tags.Type<"int64">;

    /**
     * Minimum value (inclusive).
     *
     * The value must be greater than or equal to this number.
     */
    minimum?: number & tags.Type<"int64">;

    /**
     * Maximum value (inclusive).
     *
     * The value must be less than or equal to this number.
     */
    maximum?: number & tags.Type<"int64">;

    /**
     * Exclusive minimum value.
     *
     * The value must be strictly greater than this number.
     */
    exclusiveMinimum?: number & tags.Type<"int64">;

    /**
     * Exclusive maximum value.
     *
     * The value must be strictly less than this number.
     */
    exclusiveMaximum?: number & tags.Type<"int64">;

    /**
     * Value must be divisible by this number.
     *
     * Used for constraints like "must be even" (multipleOf: 2) or "must be a
     * multiple of 100" (multipleOf: 100).
     */
    multipleOf?: number & tags.Type<"uint64"> & tags.ExclusiveMinimum<0>;
  }

  /**
   * Number (floating-point) type schema.
   *
   * Represents a JSON Schema number type for floating-point values. Maps to
   * TypeScript `number` type. Supports range constraints, enum restrictions,
   * and precision checks via multipleOf.
   */
  export interface INumber extends IJsonSchemaAttribute.INumber {
    /**
     * Allowed numeric values.
     *
     * Restricts the value to specific number literals. Useful for representing
     * specific valid values like percentages or rates.
     */
    enum?: Array<number>;

    /**
     * Default value when not provided.
     *
     * The number to use when the LLM omits this parameter.
     */
    default?: number;

    /**
     * Minimum value (inclusive).
     *
     * The value must be greater than or equal to this number.
     */
    minimum?: number;

    /**
     * Maximum value (inclusive).
     *
     * The value must be less than or equal to this number.
     */
    maximum?: number;

    /**
     * Exclusive minimum value.
     *
     * The value must be strictly greater than this number.
     */
    exclusiveMinimum?: number;

    /**
     * Exclusive maximum value.
     *
     * The value must be strictly less than this number.
     */
    exclusiveMaximum?: number;

    /**
     * Value must be divisible by this number.
     *
     * Useful for decimal precision constraints like "two decimal places"
     * (multipleOf: 0.01) or currency amounts (multipleOf: 0.01).
     */
    multipleOf?: number & tags.ExclusiveMinimum<0>;
  }

  /**
   * String type schema.
   *
   * Represents a JSON Schema string type with format validation, pattern
   * matching, and length constraints. Maps to TypeScript `string` type with
   * optional semantic format annotations.
   */
  export interface IString extends IJsonSchemaAttribute.IString {
    /**
     * Allowed string values.
     *
     * Restricts the value to specific string literals. Maps directly to
     * TypeScript string literal union types.
     */
    enum?: Array<string>;

    /**
     * Default value when not provided.
     *
     * The string to use when the LLM omits this parameter.
     */
    default?: string;

    /**
     * Semantic format specifier.
     *
     * Indicates the string represents a specific format like email, UUID, or
     * date-time. LLMs may use this to generate appropriate values. Common
     * formats include "email", "uri", "uuid", "date-time".
     */
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
    format?:
      | "binary"
      | "byte"
      | "password"
      | "regex"
      | "uuid"
      | "email"
      | "hostname"
      | "idn-email"
      | "idn-hostname"
      | "iri"
      | "iri-reference"
      | "ipv4"
      | "ipv6"
      | "uri"
      | "uri-reference"
      | "uri-template"
      | "url"
      | "date-time"
      | "date"
      | "time"
      | "duration"
      | "json-pointer"
      | "relative-json-pointer"
      | (string & {});

<<<<<<< HEAD
    /** Pattern restriction. */
    pattern?: string;

    /** Content media type restriction. */
    contentMediaType?: string;

    /**
     * Minimum length restriction.
     *
     * @type uint64
     */
    minLength?: number;

    /**
     * Maximum length restriction.
     *
     * @type uint64
     */
    maxLength?: number;
  }

  /** Array type info. */
  export interface IArray extends IJsonSchemaAttribute.IArray {
    /**
     * Items type info.
     *
     * The `items` means the type of the array elements. In other words, it is
     * the type schema info of the `T` in the TypeScript array type `Array<T>`.
=======
    /**
     * Regular expression pattern for validation.
     *
     * The string must match this regex pattern. Note that LLMs may struggle
     * with complex regex patterns; simple patterns work best.
     */
    pattern?: string;

    /**
     * MIME type of the string content.
     *
     * Indicates the content type when the string contains encoded binary data,
     * such as "application/json" or "image/png".
     */
    contentMediaType?: string;

    /**
     * Minimum string length.
     *
     * The string must have at least this many characters.
     */
    minLength?: number & tags.Type<"uint64">;

    /**
     * Maximum string length.
     *
     * The string must have at most this many characters.
     */
    maxLength?: number & tags.Type<"uint64">;
  }

  /**
   * Array type schema.
   *
   * Represents a JSON Schema array type with item type validation and size
   * constraints. Maps to TypeScript `T[]` or `Array<T>` types. Note: Tuple
   * types are not supported by LLM schemas.
   */
  export interface IArray extends IJsonSchemaAttribute.IArray {
    /**
     * Schema for array elements.
     *
     * All elements in the array must conform to this schema. For heterogeneous
     * arrays, use an `anyOf` schema.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     */
    items: ILlmSchema;

    /**
<<<<<<< HEAD
     * Unique items restriction.
     *
     * If this property value is `true`, target array must have unique items.
=======
     * Whether elements must be unique.
     *
     * When `true`, no two elements may be equal. Maps to TypeScript `Set<T>`
     * semantics but represented as an array.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     */
    uniqueItems?: boolean;

    /**
<<<<<<< HEAD
     * Minimum items restriction.
     *
     * Restriction of minimum number of items in the array.
     *
     * @type uint64
     */
    minItems?: number;

    /**
     * Maximum items restriction.
     *
     * Restriction of maximum number of items in the array.
     *
     * @type uint64
     */
    maxItems?: number;
  }

  /** Object type info. */
  export interface IObject extends IJsonSchemaAttribute.IObject {
    /**
     * Properties of the object.
     *
     * The `properties` means a list of key-value pairs of the object's regular
     * properties. The key is the name of the regular property, and the value is
     * the type schema info.
=======
     * Minimum number of elements.
     *
     * The array must contain at least this many items.
     */
    minItems?: number & tags.Type<"uint64">;

    /**
     * Maximum number of elements.
     *
     * The array must contain at most this many items.
     */
    maxItems?: number & tags.Type<"uint64">;
  }

  /**
   * Object type schema.
   *
   * Represents a JSON Schema object type with named properties. Maps to
   * TypeScript interface or object type. Supports required property
   * declarations and dynamic additional properties.
   */
  export interface IObject extends IJsonSchemaAttribute.IObject {
    /**
     * Property name to schema mapping.
     *
     * Defines the type of each named property on the object. All properties are
     * defined here regardless of whether they are required or optional.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     */
    properties: Record<string, ILlmSchema>;

    /**
<<<<<<< HEAD
     * Additional properties' info.
     *
     * The `additionalProperties` means the type schema info of the additional
     * properties that are not listed in the {@link properties}.
     *
     * If the value is `true`, it means that the additional properties are not
     * restricted. They can be any type. Otherwise, if the value is
     * {@link ILlmSchema} type, it means that the additional properties must
     * follow the type schema info.
     *
     * - `true`: `Record<string, any>`
     * - `ILlmSchema`: `Record<string, T>`
     *
     * Note: When {@link IConfig.strict} mode is enabled, this property is always
     * fixed to `false`, meaning no additional properties are allowed.
=======
     * Schema for dynamic/additional properties.
     *
     * - `false` (default): No additional properties allowed
     * - `true`: Any additional properties allowed
     * - Schema: Additional properties must match this schema
     *
     * Note: ChatGPT and Gemini do not support `additionalProperties`. Use
     * {@link ILlmSchema.IConfig.strict} mode for OpenAI compatibility.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     */
    additionalProperties?: ILlmSchema | boolean;

    /**
<<<<<<< HEAD
     * List of required property keys.
     *
     * The `required` contains a list of property keys from {@link properties}
     * that must be provided. Properties not listed in `required` are optional,
     * while those listed must be filled.
     *
     * Below is an example of {@link properties} and `required`:
     *
     * ```typescript
     * interface SomeObject {
     *   id: string;
     *   email: string;
     *   name?: string;
     * }
     * ```
     *
     * As you can see, `id` and `email` {@link properties} are {@link required},
     * so they are listed in the `required` array.
     *
     * ```json
     * {
     *   "type": "object",
     *   "properties": {
     *     "id": { "type": "string" },
     *     "email": { "type": "string" },
     *     "name": { "type": "string" }
     *   },
     *   "required": ["id", "email"]
     * }
     * ```
=======
     * List of required property names.
     *
     * Properties in this array must be present in the object. In strict mode,
     * all properties become required automatically.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     */
    required: string[];
  }

  /**
<<<<<<< HEAD
   * Reference type directing to named schema.
   *
   * If {@link IConfig.strict} mode is enabled, its other properties like
   * {@link description} would be disabled. Instead, the description would be
   * placed in the parent type. For example, if this reference type is used as a
   * property of an object, the description would be placed in the object
   * place.
   */
  export interface IReference extends IJsonSchemaAttribute {
    /**
     * Reference to the named schema.
     *
     * The `$ref` is a reference to a named schema. The format follows the JSON
     * Pointer specification. In OpenAPI, the `$ref` starts with `#/$defs/`
     * which indicates the type is stored in the
     * {@link ILlmSchema.IParameters.$defs} object.
     *
     * - `#/$defs/SomeObject`
     * - `#/$defs/AnotherObject`
=======
   * Reference to a named schema definition.
   *
   * Points to a schema defined in the `$defs` map using a JSON pointer. Used to
   * avoid schema duplication and enable recursive type definitions. The
   * reference path format is `#/$defs/TypeName`.
   */
  export interface IReference extends IJsonSchemaAttribute {
    /**
     * JSON pointer to the referenced schema.
     *
     * Must be in the format `#/$defs/TypeName` where TypeName is a key in the
     * parent schema's `$defs` map.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     */
    $ref: string;
  }

  /**
<<<<<<< HEAD
   * Union type.
   *
   * `IAnyOf` represents a union type in TypeScript (`A | B | C`).
   *
   * For reference, even if your Swagger (or OpenAPI) document defines `oneOf`
   * instead of `anyOf`, {@link ILlmSchema} forcibly converts it to the
   * `anyOf`-based {@link ILlmSchema.IAnyOf} type.
   */
  export interface IAnyOf extends IJsonSchemaAttribute {
    /** List of the union types. */
    anyOf: Exclude<ILlmSchema, ILlmSchema.IAnyOf>[];

    /**
     * Discriminator info of the union type.
     *
     * This discriminator is used to determine which type in the union should be
     * used based on the value of a specific property.
=======
   * Union type schema (A | B | C).
   *
   * Represents a TypeScript union type where the value can match any one of the
   * member schemas. Note: Gemini does not support `anyOf`/`oneOf` schemas. Use
   * discriminated unions with `x-discriminator` when possible for better LLM
   * comprehension.
   */
  export interface IAnyOf extends IJsonSchemaAttribute {
    /**
     * Array of possible schemas.
     *
     * The value must match at least one of these schemas. Nested `anyOf`
     * schemas are flattened to avoid deep nesting.
     */
    anyOf: Exclude<ILlmSchema, ILlmSchema.IAnyOf>[];

    /**
     * Discriminator for tagged/discriminated unions.
     *
     * Helps LLMs understand which variant to select based on a discriminating
     * property value. Improves type inference accuracy.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
     */
    "x-discriminator"?: IAnyOf.IDiscriminator;
  }
  export namespace IAnyOf {
<<<<<<< HEAD
    /** Discriminator info of the union type. */
    export interface IDiscriminator {
      /** Property name for the discriminator. */
      propertyName: string;

      /**
       * Mapping of discriminator values to schema names.
       *
       * This property is valid only for {@link IReference} typed
       * {@link IAnyOf.anyOf} elements. Therefore, the `key` of `mapping` is the
       * discriminator value, and the `value` of `mapping` is the schema name
       * like `#/components/schemas/SomeObject`.
=======
    /**
     * Discriminator configuration for tagged unions.
     *
     * Specifies which property distinguishes between union variants and maps
     * discriminator values to their corresponding schemas.
     */
    export interface IDiscriminator {
      /**
       * Name of the discriminating property.
       *
       * This property must exist on all union member object schemas and contain
       * unique literal values that identify each variant.
       */
      propertyName: string;

      /**
       * Mapping from discriminator values to schema references.
       *
       * Keys are the literal values of the discriminator property, values are
       * `$ref` paths to the corresponding schemas.
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
       */
      mapping?: Record<string, string>;
    }
  }

<<<<<<< HEAD
  /** Null type. */
  export interface INull extends IJsonSchemaAttribute.INull {}

  /** Unknown, the `any` type. */
=======
  /**
   * Null type schema.
   *
   * Represents the JSON null value. In TypeScript union types like `T | null`,
   * this schema appears in an `anyOf` alongside the T schema.
   */
  export interface INull extends IJsonSchemaAttribute.INull {}

  /**
   * Unknown/any type schema.
   *
   * Represents TypeScript `any` or `unknown` types where no specific type
   * constraint is defined. Use sparingly as LLMs may generate unexpected values
   * for unconstrained types.
   */
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
  export interface IUnknown extends IJsonSchemaAttribute.IUnknown {}
}
