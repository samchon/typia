/* ===========================================================
    MISCELLANEOUS
      - LITERALS
      - CLONE
      - PRUNE
      - FACTORY FUNCTIONS
==============================================================
    LITERALS
----------------------------------------------------------- */
import { Atomic, IValidation, Resolved } from "@typia/interface";

import { TypeGuardError } from "./TypeGuardError";
import { NoTransformConfigurationError } from "./transformers/NoTransformConfigurationError";

/**
<<<<<<< HEAD
 * > You must configure the generic argument `T`.
 *
 * Union literal type to array.
 *
 * Converts a union literal type to an array of its members.
 *
 * ```typescript
 * literals<"A" | "B" | 1>; // ["A", "B", 1]
 * ```
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Union literal type
 * @returns Array of union literal type's members
=======
 * Converts union literal type to array.
 *
 * @danger You must configure the generic argument `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function literals(): never;

/**
<<<<<<< HEAD
 * Union literal type to array.
 *
 * Converts a union literal type to an array of its members.
 *
 * ```typescript
 * literals<"A" | "B" | 1>; // ["A", "B", 1]
 * ```
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Union literal type
 * @returns Array of union literal type's members
=======
 * Converts union literal type to array.
 *
 * Extracts all members of a union literal type `T` into an array at runtime.
 *
 * @template T Union literal type (e.g., `"A" | "B" | 1`)
 * @returns Array containing all union members
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function literals<T extends Atomic.Type | null>(): T[];

/** @internal */
export function literals(): never {
  NoTransformConfigurationError("misc.literals");
}

/* -----------------------------------------------------------
    CLONE
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * Clone data.
 *
 * Clones an instance following type `T`. If the target _input_ value or its
 * member variable contains a class instance having methods, those methods would
 * not be cloned.
 *
 * For reference, this `typia.misc.clone()` function does not validate the input
 * value type. It just believes that the input value is following the type `T`.
 * Therefore, if you can't ensure the input value type, it would be better to
 * call {@link assertClone} function instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input A value to be cloned
 * @returns Cloned data
=======
 * Deep clones value of type `T`.
 *
 * Creates a deep copy of the input value. Class instances with methods are
 * cloned as plain objects (methods are not copied).
 *
 * Does not validate the input. For validation, use:
 *
 * - {@link assertClone} — Throws on type mismatch
 * - {@link isClone} — Returns `null` on type mismatch
 * - {@link validateClone} — Returns detailed validation errors
 *
 * @template T Type of input value
 * @param input Value to clone
 * @returns Deep cloned value
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function clone<T>(input: T): Resolved<T>;

/** @internal */
export function clone(): never {
  NoTransformConfigurationError("misc.clone");
}

/**
<<<<<<< HEAD
 * Clone data with type assertion.
 *
 * Clones an instance following type `T`, with type assertion. If the target
 * `input` value or its member variable contains a class instance having
 * methods, those methods would not be cloned.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * throws an {@link TypeGuardError} or custom error generated by _errorFactory_.
 * Otherwise, there's no problem on the `input` value, cloned data would be
 * returned.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input A value to be cloned
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns Cloned data
=======
 * Deep clones value with assertion.
 *
 * Creates a deep copy with {@link assert} validation. Throws
 * {@link TypeGuardError} on type mismatch. Class instances with methods are
 * cloned as plain objects.
 *
 * Related functions:
 *
 * - {@link clone} — No validation
 * - {@link isClone} — Returns `null` instead of throwing
 * - {@link validateClone} — Returns detailed validation errors
 *
 * @template T Type of input value
 * @param input Value to clone
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Deep cloned value
 * @throws {TypeGuardError} When input doesn't conform to type `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertClone<T>(
  input: T,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): Resolved<T>;

<<<<<<< HEAD
/**
 * Clone data with type assertion.
 *
 * Clones an instance following type `T`, with type assertion. If the target
 * `input` value or its member variable contains a class instance having
 * methods, those methods would not be cloned.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * throws an {@link TypeGuardError} or custom error generated by _errorFactory_.
 * Otherwise, there's no problem on the `input` value, cloned data would be
 * returned.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input A value to be cloned
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns Cloned data
 */
=======
/** @internal */
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
export function assertClone<T>(
  input: unknown,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): Resolved<T>;

/** @internal */
export function assertClone(): never {
  NoTransformConfigurationError("misc.assertClone");
}

/**
<<<<<<< HEAD
 * Clone data with type checking.
 *
 * Clones an instance following type `T`, with type checking. If the target
 * `input` value or its member variable contains a class instance having
 * methods, those methods would not be cloned.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * returns `null` value instead. Otherwise, there's no problem on the `input`
 * value, cloned data would be returned.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input A value to be cloned
 * @returns Cloned data when exact type, otherwise null
 */
export function isClone<T>(input: T): Resolved<T> | null;

/**
 * Clone data with type checking.
 *
 * Clones an instance following type `T`, with type checking. If the target
 * `input` value or its member variable contains a class instance having
 * methods, those methods would not be cloned.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * returns `null` value instead. Otherwise, there's no problem on the `input`
 * value, cloned data would be returned.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input A value to be cloned
 * @returns Cloned data when exact type, otherwise null
 */
=======
 * Deep clones value with type checking.
 *
 * Creates a deep copy with {@link is} validation. Returns `null` on type
 * mismatch. Class instances with methods are cloned as plain objects.
 *
 * Related functions:
 *
 * - {@link clone} — No validation
 * - {@link assertClone} — Throws instead of returning `null`
 * - {@link validateClone} — Returns detailed validation errors
 *
 * @template T Type of input value
 * @param input Value to clone
 * @returns Deep cloned value, or `null` if invalid
 */
export function isClone<T>(input: T): Resolved<T> | null;

/** @internal */
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
export function isClone<T>(input: unknown): Resolved<T> | null;

/** @internal */
export function isClone(): never {
  NoTransformConfigurationError("misc.isClone");
}

/**
<<<<<<< HEAD
 * Clone data with detailed type validation.
 *
 * Clones an instance following type `T`, with detailed type validation. If the
 * target `input` value or its member variable contains a class instance having
 * methods, those methods would not be cloned.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * returns {@link IValidation.Failure} value. Otherwise, there's no problem on
 * the `input` value, cloned data would be stored in `data` property of the
 * output {@link IValidation.Success} instance.
 *
 * @template T Type of the input value
 * @param input A value to be cloned
 * @returns Validation result with cloned value
 */
export function validateClone<T>(input: T): IValidation<Resolved<T>>;

/**
 * Clone data with detailed type validation.
 *
 * Clones an instance following type `T`, with detailed type validation. If the
 * target `input` value or its member variable contains a class instance having
 * methods, those methods would not be cloned.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * returns {@link IValidation.Failure} value. Otherwise, there's no problem on
 * the `input` value, cloned data would be stored in `data` property of the
 * output {@link IValidation.Success} instance.
 *
 * @template T Type of the input value
 * @param input A value to be cloned
 * @returns Validation result with cloned value
 */
=======
 * Deep clones value with validation.
 *
 * Creates a deep copy with {@link validate} validation. Returns
 * {@link IValidation.IFailure} with all errors on mismatch, or
 * {@link IValidation.ISuccess} with cloned value. Class instances with methods
 * are cloned as plain objects.
 *
 * Related functions:
 *
 * - {@link clone} — No validation
 * - {@link assertClone} — Throws on first error
 * - {@link isClone} — Returns `null` instead of error details
 *
 * @template T Type of input value
 * @param input Value to clone
 * @returns Validation result containing cloned value or errors
 */
export function validateClone<T>(input: T): IValidation<Resolved<T>>;

/** @internal */
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
export function validateClone<T>(input: unknown): IValidation<Resolved<T>>;

/** @internal */
export function validateClone(): never {
  NoTransformConfigurationError("misc.validateClone");
}

/* -----------------------------------------------------------
    PRUNE
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * Prune, erase superfluous properties.
 *
 * Remove all superfluous properties from the `input` object, even including
 * nested objects. Note that, as all superfluous properties would be deleted,
 * you never can read those superfluous properties after calling this `prune()`
 * function.
 *
 * For reference, this `typia.misc.prune()` function does not validate the input
 * value type. It just believes that the input value is following the type `T`.
 * Therefore, if you can't ensure the input value type, it would better to call
 * one of below functions instead.
 *
 * - {@link assertPrune}
 * - {@link isPrune}
 * - {@link validatePrune}
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input Target instance to prune
=======
 * Removes superfluous properties from object.
 *
 * Deletes all properties not defined in type `T`, including in nested objects.
 * Mutates the input directly—removed properties cannot be recovered.
 *
 * Does not validate the input. For validation, use:
 *
 * - {@link assertPrune} — Throws on type mismatch
 * - {@link isPrune} — Returns `false` on type mismatch
 * - {@link validatePrune} — Returns detailed validation errors
 *
 * @template T Type of input value
 * @param input Object to prune
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function prune<T extends object>(input: T): void;

/** @internal */
export function prune(): never {
  NoTransformConfigurationError("misc.prune");
}

/**
<<<<<<< HEAD
 * Prune, erase superfluous properties, with type assertion.
 *
 * `typia.misc.assertPrune()` is a combination function of {@link assert} and
 * {@link prune}. Therefore, it removes all superfluous properties from the
 * `input` object including nested objects, with type assertion.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * throws an {@link TypeGuardError} or custom error generated by _errorFactory_.
 * Otherwise, there's no problem on the `input` value, its all superfluous
 * properties would be removed, including nested objects.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input Target instance to assert and prune
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
=======
 * Removes superfluous properties with assertion.
 *
 * Combines {@link assert} with {@link prune}. Throws {@link TypeGuardError} on
 * type mismatch. Mutates the input directly—removed properties cannot be
 * recovered.
 *
 * Related functions:
 *
 * - {@link prune} — No validation
 * - {@link isPrune} — Returns `false` instead of throwing
 * - {@link validatePrune} — Returns detailed validation errors
 *
 * @template T Type of input value
 * @param input Object to assert and prune
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns The pruned input
 * @throws {TypeGuardError} When input doesn't conform to type `T`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertPrune<T>(
  input: T,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): T;

<<<<<<< HEAD
/**
 * Prune, erase superfluous properties, with type assertion.
 *
 * `typia.misc.assertPrune()` is a combination function of {@link assert} and
 * {@link prune}. Therefore, it removes all superfluous properties from the
 * `input` object including nested objects, with type assertion.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * throws an {@link TypeGuardError} or custom error generated by _errorFactory_.
 * Otherwise, there's no problem on the `input` value, its all superfluous
 * properties would be removed, including nested objects.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input Target instance to assert and prune
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 */
=======
/** @internal */
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
export function assertPrune<T>(
  input: unknown,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): T;

/** @internal */
export function assertPrune(): unknown {
  NoTransformConfigurationError("misc.assertPrune");
}

/**
<<<<<<< HEAD
 * Prune, erase superfluous properties, with type checking.
 *
 * `typia.misc.isPrune()` is a combination function of {@link is} and
 * {@link prune}. Therefore, it removes all superfluous properties from the
 * `input` object including nested objects, with type checking.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * returns `false` value. Otherwise, there's no problem on the `input` value, it
 * returns `true` after removing all superfluous properties, including nested
 * objects.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input Target instance to check and prune
 * @returns Whether the parametric value is following the type `T` or not
 */
export function isPrune<T>(input: T): input is T;

/**
 * Prune, erase superfluous properties, with type checking.
 *
 * `typia.misc.isPrune()` is a combination function of {@link is} and
 * {@link prune}. Therefore, it removes all superfluous properties from the
 * `input` object including nested objects, with type checking.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * returns `false` value. Otherwise, there's no problem on the `input` value, it
 * returns `true` after removing all superfluous properties, including nested
 * objects.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input Target instance to check and prune
 * @returns Whether the parametric value is following the type `T` or not
 */
=======
 * Removes superfluous properties with type checking.
 *
 * Combines {@link is} with {@link prune}. Returns `false` on type mismatch (no
 * pruning occurs). Returns `true` after successful pruning. Mutates the input
 * directly.
 *
 * Related functions:
 *
 * - {@link prune} — No validation
 * - {@link assertPrune} — Throws instead of returning `false`
 * - {@link validatePrune} — Returns detailed validation errors
 *
 * @template T Type of input value
 * @param input Object to check and prune
 * @returns `true` if valid and pruned, `false` if type mismatch
 */
export function isPrune<T>(input: T): input is T;

/** @internal */
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
export function isPrune<T>(input: unknown): input is T;

/** @internal */
export function isPrune(): never {
  NoTransformConfigurationError("misc.isPrune");
}

/**
<<<<<<< HEAD
 * Prune, erase superfluous properties, with type validation.
 *
 * `typia.misc.validatePrune()` is a combination function of {@link validate} and
 * {@link prune}. Therefore, it removes all superfluous properties from the
 * `input` object including nested objects, with type validation.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * returns {@link IValidation.IFailure} value with detailed error reasons.
 * Otherwise, there's no problem on the `input` value, it returns
 * {@link IValidation.ISuccess} value after removing all superfluous properties,
 * including nested objects.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input Target instance to validate and prune
=======
 * Removes superfluous properties with validation.
 *
 * Combines {@link validate} with {@link prune}. Returns
 * {@link IValidation.IFailure} with all errors on mismatch (no pruning occurs),
 * or {@link IValidation.ISuccess} after successful pruning. Mutates the input
 * directly.
 *
 * Related functions:
 *
 * - {@link prune} — No validation
 * - {@link assertPrune} — Throws on first error
 * - {@link isPrune} — Returns `false` instead of error details
 *
 * @template T Type of input value
 * @param input Object to validate and prune
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @returns Validation result
 */
export function validatePrune<T>(input: T): IValidation<T>;

<<<<<<< HEAD
/**
 * Prune, erase superfluous properties, with type validation.
 *
 * `typia.misc.validatePrune()` is a combination function of {@link validate} and
 * {@link prune}. Therefore, it removes all superfluous properties from the
 * `input` object including nested objects, with type validation.
 *
 * In such reason, when `input` value is not matched with the type `T`, it
 * returns {@link IValidation.IFailure} value with detailed error reasons.
 * Otherwise, there's no problem on the `input` value, it returns
 * {@link IValidation.ISuccess} value after removing all superfluous properties,
 * including nested objects.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param input Target instance to validate and prune
 * @returns Validation result
 */
=======
/** @internal */
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
export function validatePrune<T>(input: unknown): IValidation<T>;

/** @internal */
export function validatePrune<T>(): IValidation<T> {
  NoTransformConfigurationError("misc.validatePrune");
}

/* -----------------------------------------------------------
    FACTORY FUNCTIONS
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * Creates a reusable {@link clone} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @returns Nothing until you configure the generic argument `T`
 * @throws Compile error
=======
 * Creates reusable {@link clone} function.
 *
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createClone(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link clone} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @returns A reusable `clone` function
=======
 * Creates reusable {@link clone} function.
 *
 * @template T Type of input value
 * @returns Reusable clone function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createClone<T>(): (input: T) => Resolved<T>;

/** @internal */
export function createClone(): never {
  NoTransformConfigurationError("misc.createClone");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertClone} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns Nothing until you configure the generic argument `T`
 * @throws Compile error
=======
 * Creates reusable {@link assertClone} function.
 *
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createAssertClone(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertClone} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns A reusable `clone` function
=======
 * Creates reusable {@link assertClone} function.
 *
 * @template T Type of input value
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Reusable clone function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createAssertClone<T>(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): (input: unknown) => Resolved<T>;

/** @internal */
export function createAssertClone(): never {
  NoTransformConfigurationError("misc.createAssertClone");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link isClone} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @returns Nothing until you configure the generic argument `T`
 * @throws Compile error
=======
 * Creates reusable {@link isClone} function.
 *
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createIsClone(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link isClone} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @returns A reusable `clone` function
=======
 * Creates reusable {@link isClone} function.
 *
 * @template T Type of input value
 * @returns Reusable clone function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createIsClone<T>(): (input: unknown) => Resolved<T> | null;

/** @internal */
export function createIsClone(): never {
  NoTransformConfigurationError("misc.createIsClone");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link validateClone} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @returns Nothing until you configure the generic argument `T`
 * @throws Compile error
=======
 * Creates reusable {@link validateClone} function.
 *
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createValidateClone(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link validateClone} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @returns A reusable `clone` function
=======
 * Creates reusable {@link validateClone} function.
 *
 * @template T Type of input value
 * @returns Reusable clone function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createValidateClone<T>(): (
  input: unknown,
) => IValidation<Resolved<T>>;

/** @internal */
export function createValidateClone(): never {
  NoTransformConfigurationError("misc.createValidateClone");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link prune} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @returns Nothing until you configure the generic argument `T`
 * @throws Compile error
=======
 * Creates reusable {@link prune} function.
 *
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createPrune(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link prune} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @returns A reusable `prune` function
=======
 * Creates reusable {@link prune} function.
 *
 * @template T Type of input value
 * @returns Reusable prune function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createPrune<T extends object>(): (input: T) => void;

/** @internal */
export function createPrune(): never {
  NoTransformConfigurationError("misc.createPrune");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertPrune} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns Nothing until you configure the generic argument `T`
 * @throws Compile error
=======
 * Creates reusable {@link assertPrune} function.
 *
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createAssertPrune(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link assertPrune} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns A reusable `isPrune` function
=======
 * Creates reusable {@link assertPrune} function.
 *
 * @template T Type of input value
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Reusable prune function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createAssertPrune<T extends object>(
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): (input: unknown) => T;

/** @internal */
export function createAssertPrune(): never {
  NoTransformConfigurationError("misc.createAssertPrune");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link isPrune} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @returns Nothing until you configure the generic argument `T`
 * @throws Compile error
=======
 * Creates reusable {@link isPrune} function.
 *
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createIsPrune(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link isPrune} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @returns A reusable `isPrune` function
=======
 * Creates reusable {@link isPrune} function.
 *
 * @template T Type of input value
 * @returns Reusable prune function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createIsPrune<T extends object>(): (
  input: unknown,
) => input is T;

/** @internal */
export function createIsPrune(): never {
  NoTransformConfigurationError("misc.createIsPrune");
}

/**
<<<<<<< HEAD
 * Creates a reusable {@link validatePrune} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @returns Nothing until you configure the generic argument `T`
 * @throws Compile error
=======
 * Creates reusable {@link validatePrune} function.
 *
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 * @danger You must configure the generic argument `T`
 */
export function createValidatePrune(): never;

/**
<<<<<<< HEAD
 * Creates a reusable {@link validatePrune} function.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Type of the input value
 * @returns A reusable `validatePrune` function
=======
 * Creates reusable {@link validatePrune} function.
 *
 * @template T Type of input value
 * @returns Reusable prune function
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function createValidatePrune<T extends object>(): (
  input: unknown,
) => IValidation<T>;

/** @internal */
export function createValidatePrune(): never {
  NoTransformConfigurationError("misc.createValidatePrune");
}
