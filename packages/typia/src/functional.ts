import { IValidation } from "@typia/interface";

import { TypeGuardError } from "./TypeGuardError";
import { NoTransformConfigurationError } from "./transformers/NoTransformConfigurationError";

/* ===========================================================
  FUNCTIONAL
    - ASSERT
    - IS
    - VALIDATE
==============================================================
  ASSERT
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * Asserts a function.
 *
 * Asserts a function, by wrapping the function and checking its parameters and
 * return value through {@link assert} function. If some parameter or return
 * value does not match the expected type, it throws an {@link TypeGuardError} or
 * a custom error generated by the _errorFactory_ parameter.
 *
 * For reference, {@link TypeGuardError.path} would be a little bit different
 * with individual {@link assert} function. If the {@link TypeGuardError} occurs
 * from some parameter, the path would start from `$input.parameters[number]`.
 * Otherwise the path would start from `$input.return`.
 *
 * - `$input.parameters[0].~`
 * - `$input.return.~`
 *
 * By the way, if what you want is not just finding the 1st type error through
 * assertion, but also finding every type errors, then use
 * {@link validateFunction} instead. Otherwise, what you want is just asserting
 * parameters or return value only, you can use {@link assertParameters} or
 * {@link assertReturn} instead.
 *
 * On the other hand, if don't want to allow any superfluous properties, utilize
 * {@link assertEqualsFunction} or {@link validateEqualsFunction} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to assert
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns The wrapper function with type assertions
 * @throws A {@link TypeGuardError} or a custom error generated by _errorFactory_
=======
 * Wraps function to assert both parameters and return value.
 *
 * Wraps the target function and validates all parameters before calling and
 * return value after calling through {@link assert}. Throws on first mismatch.
 *
 * Error path format:
 *
 * - Parameter errors: `$input.parameters[0].property`
 * - Return errors: `$input.return.property`
 *
 * Related functions:
 *
 * - {@link assertParameters} — Validates parameters only
 * - {@link assertReturn} — Validates return value only
 * - {@link validateFunction} — Collects all errors instead of throwing
 * - {@link assertEqualsFunction} — Also rejects extra properties
 *
 * @template T Target function type
 * @param func Function to wrap
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Wrapped function with same signature
 * @throws {TypeGuardError} When parameter or return value type mismatch
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertFunction<T extends (...args: any[]) => any>(
  func: T,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): T;

/** @internal */
export function assertFunction(): never {
  NoTransformConfigurationError("functional.assertFunction");
}

/**
<<<<<<< HEAD
 * Asserts parameters.
 *
 * Asserts a function, by wrapping the function and checking its parameters
 * through {@link assert} function. If some parameter does not match the expected
 * type, it throws an {@link TypeGuardError} or a custom error generated by the
 * _errorFactory_ parameter.
 *
 * For reference, {@link TypeGuardError.path} would be a little bit different
 * with individual {@link assert} function. If the {@link TypeGuardError} occurs
 * from some parameter, the path would start from `$input.parameters[number]`.
 *
 * By the way, if what you want is not just finding the 1st type error through
 * assertion, but also finding every type errors, then use
 * {@link validateParameters} instead. Otherwise, what you want is not only
 * asserting parameters, but also asserting return value, you can use
 * {@link assertFunction} instead.
 *
 * On the other hand, if don't want to allow any superfluous properties, utilize
 * {@link assertEqualsParameters} or {@link validateEqualsParameters} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to assert
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns The wrapper function with type assertions
 * @throws A {@link TypeGuardError} or a custom error generated by _errorFactory_
=======
 * Wraps function to assert parameters only.
 *
 * Wraps the target function and validates all parameters before calling through
 * {@link assert}. Return value is not validated. Throws on first mismatch.
 *
 * Error path format: `$input.parameters[0].property`
 *
 * Related functions:
 *
 * - {@link assertFunction} — Also validates return value
 * - {@link assertReturn} — Validates return value only
 * - {@link validateParameters} — Collects all errors instead of throwing
 * - {@link assertEqualsParameters} — Also rejects extra properties
 *
 * @template T Target function type
 * @param func Function to wrap
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Wrapped function with same signature
 * @throws {TypeGuardError} When parameter type mismatch
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertParameters<T extends (...args: any[]) => any>(
  func: T,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): T;

/** @internal */
export function assertParameters(): never {
  NoTransformConfigurationError("functional.assertParameters");
}

/**
<<<<<<< HEAD
 * Asserts return value.
 *
 * Asserts a function, by wrapping the function and checking its return value
 * through {@link assert} function. If the return value does not match the
 * expected type, it throws an {@link TypeGuardError} or a custom error generated
 * by the _errorFactory_ parameter.
 *
 * For reference, {@link TypeGuardError.path} would be a little bit different
 * with individual {@link assert} function. If the {@link TypeGuardError} occurs
 * from the return value, the path would start from `$input.return`.
 *
 * By the way, if what you want is not just finding the 1st type error through
 * assertion, but also finding every type errors, then use {@link validateReturn}
 * instead. Otherwise, what you want is not only asserting return value, but
 * also asserting parameters, you can use {@link assertFunction} instead.
 *
 * On the other hand, if don't want to allow any superfluous properties, utilize
 * {@link assertEqualsReturn} or {@link validateEqualsReturn} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to assert
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns The wrapper function with type assertions
 * @throws A {@link TypeGuardError} or a custom error generated by _errorFactory_
=======
 * Wraps function to assert return value only.
 *
 * Wraps the target function and validates return value after calling through
 * {@link assert}. Parameters are not validated. Throws on mismatch.
 *
 * Error path format: `$input.return.property`
 *
 * Related functions:
 *
 * - {@link assertFunction} — Also validates parameters
 * - {@link assertParameters} — Validates parameters only
 * - {@link validateReturn} — Collects all errors instead of throwing
 * - {@link assertEqualsReturn} — Also rejects extra properties
 *
 * @template T Target function type
 * @param func Function to wrap
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Wrapped function with same signature
 * @throws {TypeGuardError} When return value type mismatch
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertReturn<T extends (...args: any[]) => any>(
  func: T,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): T;

/** @internal */
export function assertReturn(): never {
  NoTransformConfigurationError("functional.assertReturn");
}

/**
<<<<<<< HEAD
 * Asserts a function with strict equality.
 *
 * Asserts a function with strict equality, by wrapping the function and
 * checking its parameters and return value through {@link assertEquals}
 * function. If some parameter or return value does not match the expected type,
 * it throws an {@link TypeGuardError} or a custom error generated by the
 * _errorFactory_ parameter.
 *
 * For reference, {@link TypeGuardError.path} would be a little bit different
 * with individual {@link assertEquals} function. If the {@link TypeGuardError}
 * occurs from some parameter, the path would start from
 * `$input.parameters[number]`. Otherwise the path would start from
 * `$input.return`.
 *
 * - `$input.parameters[0].~`
 * - `$input.return.~`
 *
 * By the way, if what you want is not just finding the 1st type error through
 * assertion, but also finding every type errors, then use
 * {@link validateEqualsFunction} instead. Otherwise, what you want is just
 * asserting parameters or return value only, you can use
 * {@link assertEqualsParameters} or {@link assertEqualsReturn} instead.
 *
 * On the other hand, if you want to allow any superfluous properties, utilize
 * {@link assertFunction} or {@link validateFunction} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to assert
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns The wrapper function with type assertions
 * @throws A {@link TypeGuardError} or a custom error generated by _errorFactory_
=======
 * Wraps function to assert parameters and return value with strict equality.
 *
 * Wraps the target function and validates through {@link assertEquals}. Also
 * rejects extra properties not defined in type. Throws on first mismatch.
 *
 * Error path format:
 *
 * - Parameter errors: `$input.parameters[0].property`
 * - Return errors: `$input.return.property`
 *
 * Related functions:
 *
 * - {@link assertFunction} — Allows extra properties
 * - {@link assertEqualsParameters} — Validates parameters only
 * - {@link assertEqualsReturn} — Validates return value only
 * - {@link validateEqualsFunction} — Collects all errors instead of throwing
 *
 * @template T Target function type
 * @param func Function to wrap
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Wrapped function with same signature
 * @throws {TypeGuardError} When type mismatch or extra property detected
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertEqualsFunction<T extends (...args: any[]) => any>(
  func: T,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): T;

/** @internal */
export function assertEqualsFunction(): never {
  NoTransformConfigurationError("functional.assertEqualsFunction");
}

/**
<<<<<<< HEAD
 * Asserts parameters with strict equality.
 *
 * Asserts a function, by wrapping the function and checking its parameters
 * through {@link assertEquals} function. If some parameter does not match the
 * expected type, it throws an {@link TypeGuardError} or a custom error generated
 * by the _errorFactory_ parameter.
 *
 * For reference, {@link TypeGuardError.path} would be a little bit different
 * with individual {@link assertEquals} function. If the {@link TypeGuardError}
 * occurs from some parameter, the path would start from
 * `$input.parameters[number]`.
 *
 * By the way, if what you want is not just finding the 1st type error through
 * assertion, but also finding every type errors, then use
 * {@link validateEqualsParameters} instead. Otherwise, what you want is not only
 * asserting parameters, but also asserting return value, you can use
 * {@link assertEqualsFunction} instead.
 *
 * On the other hand, if you want to allow any superfluous properties, utilize
 * {@link assertParameters} or {@link validateParameters} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to assert
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns The wrapper function with type assertions
 * @throws A {@link TypeGuardError} or a custom error generated by _errorFactory_
=======
 * Wraps function to assert parameters with strict equality.
 *
 * Wraps the target function and validates parameters through
 * {@link assertEquals}. Also rejects extra properties. Return value is not
 * validated.
 *
 * Error path format: `$input.parameters[0].property`
 *
 * Related functions:
 *
 * - {@link assertParameters} — Allows extra properties
 * - {@link assertEqualsFunction} — Also validates return value
 * - {@link validateEqualsParameters} — Collects all errors instead of throwing
 *
 * @template T Target function type
 * @param func Function to wrap
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Wrapped function with same signature
 * @throws {TypeGuardError} When type mismatch or extra property detected
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertEqualsParameters<T extends (...args: any[]) => any>(
  func: T,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): T;

/** @internal */
export function assertEqualsParameters(): never {
  NoTransformConfigurationError("functional.assertEqualsParameters");
}

/**
<<<<<<< HEAD
 * Asserts return value with strict equality.
 *
 * Asserts a function, by wrapping the function and checking its return value
 * through {@link assertEquals} function. If the return value does not match the
 * expected type, it throws an {@link TypeGuardError} or a custom error generated
 * by the _errorFactory_ parameter.
 *
 * For reference, {@link TypeGuardError.path} would be a little bit different
 * with individual {@link assertEquals} function. If the {@link TypeGuardError}
 * occurs from the return value, the path would start from `$input.return`.
 *
 * By the way, if what you want is not just finding the 1st type error through
 * assertion, but also finding every type errors, then use
 * {@link validateEqualsReturn} instead. Otherwise, what you want is not only
 * asserting return value, but also asserting parameters, you can use
 * {@link assertEqualsFunction} instead.
 *
 * On the other hand, if you want to allow any superfluous properties, utilize
 * {@link assertReturn} or {@link validateReturn} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to assert
 * @param errorFactory Custom error factory. Default is `TypeGuardError`
 * @returns The wrapper function with type assertions
 * @throws A {@link TypeGuardError} or a custom error generated by _errorFactory_
=======
 * Wraps function to assert return value with strict equality.
 *
 * Wraps the target function and validates return value through
 * {@link assertEquals}. Also rejects extra properties. Parameters are not
 * validated.
 *
 * Error path format: `$input.return.property`
 *
 * Related functions:
 *
 * - {@link assertReturn} — Allows extra properties
 * - {@link assertEqualsFunction} — Also validates parameters
 * - {@link validateEqualsReturn} — Collects all errors instead of throwing
 *
 * @template T Target function type
 * @param func Function to wrap
 * @param errorFactory Custom error factory receiving
 *   {@link TypeGuardError.IProps}
 * @returns Wrapped function with same signature
 * @throws {TypeGuardError} When type mismatch or extra property detected
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function assertEqualsReturn<T extends (...args: any[]) => any>(
  func: T,
  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),
): T;

/** @internal */
export function assertEqualsReturn(): never {
  NoTransformConfigurationError("functional.assertEqualsReturn");
}

/* -----------------------------------------------------------
  IS
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * Tests a function.
 *
 * Tests a function, by wrapping the function and checking its parameters and
 * return value through {@link is} function. If some parameter or return value
 * does not match the expected type, it returns `null`. Otherwise there's no
 * type error, it returns the result of the function.
 *
 * By the way, if you want is not just testing type checking, but also finding
 * detailed type error reason(s), then use {@link assertFunction} or
 * {@link validateFunction} instead.
 *
 * On the other hand, if you don't want to allow any superfluous properties,
 * utilize {@link equalsFunction}, {@link assertEqualsFunction} or
 * {@link validateEqualsFunction} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to test
 * @returns The wrapper function with type tests
=======
 * Wraps function to test both parameters and return value.
 *
 * Wraps the target function and checks all parameters before calling and return
 * value after calling through {@link is}. Returns `null` on mismatch.
 *
 * Related functions:
 *
 * - {@link isParameters} — Tests parameters only
 * - {@link isReturn} — Tests return value only
 * - {@link assertFunction} — Throws with error details on mismatch
 * - {@link validateFunction} — Returns all error details
 * - {@link equalsFunction} — Also rejects extra properties
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning `Output | null`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function isFunction<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<R | null>
    : (...args: Arguments) => Output | null
  : never;

/** @internal */
export function isFunction(): never {
  NoTransformConfigurationError("functional.isFunction");
}

/**
<<<<<<< HEAD
 * Tests parameters.
 *
 * Tests a function, by wrapping the function and checking its parameters
 * through {@link is} function. If some parameter does not match the expected
 * type, it returns `null`. Otherwise there's no type error, it returns the
 * result of the function.
 *
 * By the way, if you want is not just testing type checking, but also finding
 * detailed type error reason(s), then use {@link assertParameters} or
 * {@link validateParameters} instead.
 *
 * On the other hand, if you don't want to allow any superfluous properties,
 * utilize {@link equalsParameters}, {@link assertEqualsParameters} or
 * {@link validateEqualsParameters} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to test
 * @returns The wrapper function with type tests
=======
 * Wraps function to test parameters only.
 *
 * Wraps the target function and checks all parameters before calling through
 * {@link is}. Return value is not checked. Returns `null` on mismatch.
 *
 * Related functions:
 *
 * - {@link isFunction} — Also tests return value
 * - {@link isReturn} — Tests return value only
 * - {@link assertParameters} — Throws with error details
 * - {@link validateParameters} — Returns all error details
 * - {@link equalsParameters} — Also rejects extra properties
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning `Output | null`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function isParameters<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<R | null>
    : (...args: Arguments) => Output | null
  : never;

/** @internal */
export function isParameters(): never {
  NoTransformConfigurationError("functional.isParameters");
}

/**
<<<<<<< HEAD
 * Tests return value.
 *
 * Tests a function, by wrapping the function and checking its return value
 * through {@link is} function. If the return value does not match the expected
 * type, it returns `null`. Otherwise there's no type error, it returns the
 * result of the function.
 *
 * By the way, if you want is not just testing type checking, but also finding
 * detailed type error reason(s), then use {@link assertReturn} or
 * {@link validateReturn} instead.
 *
 * On the other hand, if you don't want to allow any superfluous properties,
 * utilize {@link equalsReturn}, {@link assertEqualsReturn} or
 * {@link validateEqualsReturn} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to test
 * @returns The wrapper function with type tests
=======
 * Wraps function to test return value only.
 *
 * Wraps the target function and checks return value after calling through
 * {@link is}. Parameters are not checked. Returns `null` on mismatch.
 *
 * Related functions:
 *
 * - {@link isFunction} — Also tests parameters
 * - {@link isParameters} — Tests parameters only
 * - {@link assertReturn} — Throws with error details
 * - {@link validateReturn} — Returns all error details
 * - {@link equalsReturn} — Also rejects extra properties
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning `Output | null`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function isReturn<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<R | null>
    : (...args: Arguments) => Output | null
  : never;

/** @internal */
export function isReturn(): never {
  NoTransformConfigurationError("functional.isReturn");
}

/**
<<<<<<< HEAD
 * Tests a function with strict equality.
 *
 * Tests a function with strict equality, by wrapping the function and checking
 * its parameters and return value through {@link isEquals} function. If some
 * parameter or return value does not match the expected type, it returns
 * `null`. Otherwise there's no type error, it returns the result of the
 * function.
 *
 * By the way, if you want is not just testing type checking, but also finding
 * detailed type error reason(s), then use {@link assertEqualsFunction} or
 * {@link validateEqualsFunction} instead.
 *
 * On the other hand, if you want to allow any superfluous properties, utilize
 * {@link isFunction}, {@link assertFunction} or {@link validateFunction} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to test
 * @returns The wrapper function with type tests
=======
 * Wraps function to test parameters and return value with strict equality.
 *
 * Wraps the target function and checks through {@link equals}. Also rejects
 * extra properties not defined in type. Returns `null` on mismatch.
 *
 * Related functions:
 *
 * - {@link isFunction} — Allows extra properties
 * - {@link equalsParameters} — Tests parameters only
 * - {@link equalsReturn} — Tests return value only
 * - {@link assertEqualsFunction} — Throws with error details
 * - {@link validateEqualsFunction} — Returns all error details
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning `Output | null`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function equalsFunction<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<R | null>
    : (...args: Arguments) => Output | null
  : never;

/** @internal */
export function equalsFunction(): never {
  NoTransformConfigurationError("functional.equalsFunction");
}

/**
<<<<<<< HEAD
 * Tests parameters with strict equality.
 *
 * Tests a function, by wrapping the function and checking its parameters
 * through {@link isEquals} function. If some parameter does not match the
 * expected type, it returns `null`. Otherwise there's no type error, it returns
 * the result of the function.
 *
 * By the way, if you want is not just testing type checking, but also finding
 * detailed type error reason(s), then use {@link assertEqualsParameters} or
 * {@link validateEqualsParameters} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to test
 * @returns The wrapper function with type tests
=======
 * Wraps function to test parameters with strict equality.
 *
 * Wraps the target function and checks parameters through {@link equals}. Also
 * rejects extra properties. Return value is not checked.
 *
 * Related functions:
 *
 * - {@link isParameters} — Allows extra properties
 * - {@link equalsFunction} — Also tests return value
 * - {@link equalsReturn} — Tests return value only
 * - {@link assertEqualsParameters} — Throws with error details
 * - {@link validateEqualsParameters} — Returns all error details
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning `Output | null`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function equalsParameters<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<R | null>
    : (...args: Arguments) => Output | null
  : never;

/** @internal */
export function equalsParameters(): never {
  NoTransformConfigurationError("functional.equalsParameters");
}

/**
<<<<<<< HEAD
 * Tests return value with strict equality.
 *
 * Tests a function, by wrapping the function and checking its return value
 * through {@link isEquals} function. If the return value does not match the
 * expected type, it returns `null`. Otherwise there's no type error, it returns
 * the result of the function.
 *
 * By the way, if you want is not just testing type checking, but also finding
 * detailed type error reason(s), then use {@link assertEqualsReturn} or
 * {@link validateEqualsReturn} instead.
 *
 * On the other hand, if you want to allow any superfluous properties, utilize
 * {@link isReturn}, {@link assertReturn} or {@link validateReturn} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to test
 * @returns The wrapper function with type tests
=======
 * Wraps function to test return value with strict equality.
 *
 * Wraps the target function and checks return value through {@link equals}. Also
 * rejects extra properties. Parameters are not checked.
 *
 * Related functions:
 *
 * - {@link isReturn} — Allows extra properties
 * - {@link equalsFunction} — Also tests parameters
 * - {@link equalsParameters} — Tests parameters only
 * - {@link assertEqualsReturn} — Throws with error details
 * - {@link validateEqualsReturn} — Returns all error details
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning `Output | null`
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function equalsReturn<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<R | null>
    : (...args: Arguments) => Output | null
  : never;

/** @internal */
export function equalsReturn(): never {
  NoTransformConfigurationError("functional.equalsReturn");
}

/* -----------------------------------------------------------
  VALIDATE
----------------------------------------------------------- */
/**
<<<<<<< HEAD
 * Validates a function.
 *
 * Validates a function, by wrapping the function and checking its parameters
 * and return value through {@link validate} function. If some parameter or
 * return value does not match the expected type, it returns
 * {@link IValidation.IError} typed object. Otherwise there's no type error, it
 * returns {@link IValidation.ISuccess} typed object instead.
 *
 * For reference, {@link IValidation.IError.path} would be a little bit different
 * with individual {@link validate} function. If the {@link IValidation.IError}
 * occurs from some parameter, the path would start from
 * `$input.parameters[number]`. Otherwise the path would start from
 * `$input.return`.
 *
 * - `$input.parameters[0].~`
 * - `$input.return.~`
 *
 * By the way, if what you want is not finding every type errors, but just
 * finding the 1st type error, then use {@link assertFunction} instead.
 * Otherwise, what you want is just validating parameters or return value only,
 * you can use {@link validateParameters} or {@link validateReturn} instead.
 *
 * On the other hand, if you don't want to allow any superfluous properties,
 * utilize {@link validateEqualsFunction} or {@link assertEqualsFunction}
 * instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to validate
 * @returns The wrapper function with type validations
=======
 * Wraps function to validate both parameters and return value.
 *
 * Wraps the target function and validates all parameters before calling and
 * return value after calling through {@link validate}. Collects all errors.
 *
 * Error path format:
 *
 * - Parameter errors: `$input.parameters[0].property`
 * - Return errors: `$input.return.property`
 *
 * Related functions:
 *
 * - {@link validateParameters} — Validates parameters only
 * - {@link validateReturn} — Validates return value only
 * - {@link assertFunction} — Throws on first error
 * - {@link validateEqualsFunction} — Also rejects extra properties
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning {@link IValidation}
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function validateFunction<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<IValidation<R>>
    : (...args: Arguments) => IValidation<Output>
  : never;

/** @internal */
export function validateFunction(): never {
  NoTransformConfigurationError("functional.validateFunction");
}

/**
<<<<<<< HEAD
 * Validates parameters.
 *
 * Validates a function, by wrapping the function and checking its parameters
 * through {@link validate} function. If some parameter does not match the
 * expected type, it returns {@link IValidation.IError} typed object. Otherwise
 * there's no type error, it returns {@link IValidation.ISuccess} typed object
 * instead.
 *
 * For reference, {@link IValidation.IError.path} would be a little bit different
 * with individual {@link validate} function. If the {@link IValidation.IError}
 * occurs from some parameter, the path would start from
 * `$input.parameters[number]`.
 *
 * By the way, if what you want is not finding every type errors, but just
 * finding the 1st type error, then use {@link assertParameters} instead.
 * Otherwise, what you want is not only validating parameters, but also
 * validating return value, you can use {@link validateFunction} instead.
 *
 * On the other hand, if you don't want to allow any superfluous properties,
 * utilize {@link validateEqualsParameters} or {@link assertEqualsParameters}
 * instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to validate
 * @returns The wrapper function with type validations
=======
 * Wraps function to validate parameters only.
 *
 * Wraps the target function and validates all parameters before calling through
 * {@link validate}. Return value is not validated. Collects all errors.
 *
 * Error path format: `$input.parameters[0].property`
 *
 * Related functions:
 *
 * - {@link validateFunction} — Also validates return value
 * - {@link validateReturn} — Validates return value only
 * - {@link assertParameters} — Throws on first error
 * - {@link validateEqualsParameters} — Also rejects extra properties
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning {@link IValidation}
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function validateParameters<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<IValidation<R>>
    : (...args: Arguments) => IValidation<Output>
  : never;

/** @internal */
export function validateParameters(): never {
  NoTransformConfigurationError("functional.validateParameters");
}

/**
<<<<<<< HEAD
 * Validates return value.
 *
 * Validates a function, by wrapping the function and checking its return value
 * through {@link validate} function. If the return value does not match the
 * expected type, it returns {@link IValidation.IError} typed object. Otherwise
 * there's no type error, it returns {@link IValidation.ISuccess} typed object
 * instead.
 *
 * For reference, {@link IValidation.IError.path} would be a little bit different
 * with individual {@link validate} function. If the {@link IValidation.IError}
 * occurs from the return value, the path would start from `$input.return`.
 *
 * By the way, if what you want is not finding every type errors, but just
 * finding the 1st type error, then use {@link assertReturn} instead. Otherwise,
 * what you want is not only validating return value, but also validating
 * parameters, you can use {@link validateFunction} instead.
 *
 * On the other hand, if you don't want to allow any superfluous properties,
 * utilize {@link validateEqualsReturn} or {@link assertEqualsReturn} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to validate
 * @returns The wrapper function with type validations
=======
 * Wraps function to validate return value only.
 *
 * Wraps the target function and validates return value after calling through
 * {@link validate}. Parameters are not validated. Collects all errors.
 *
 * Error path format: `$input.return.property`
 *
 * Related functions:
 *
 * - {@link validateFunction} — Also validates parameters
 * - {@link validateParameters} — Validates parameters only
 * - {@link assertReturn} — Throws on first error
 * - {@link validateEqualsReturn} — Also rejects extra properties
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning {@link IValidation}
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function validateReturn<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<IValidation<R>>
    : (...args: Arguments) => IValidation<Output>
  : never;

/** @internal */
export function validateReturn(): never {
  NoTransformConfigurationError("functional.validateReturn");
}

/**
<<<<<<< HEAD
 * Validates a function with strict equality.
 *
 * Validates a function with strict equality, by wrapping the function and
 * checking its parameters and return value through {@link validateEquals}
 * function. If some parameter or return value does not match the expected type,
 * it returns {@link IValidation.IError} typed object. Otherwise there's no type
 * error, it returns {@link IValidation.ISuccess} typed object instead.
 *
 * For reference, {@link IValidation.IError.path} would be a little bit different
 * with individual {@link validateEquals} function. If the
 * {@link IValidation.IError} occurs from some parameter, the path would start
 * from `$input.parameters[number]`. Otherwise the path would start from
 * `$input.return`.
 *
 * - `$input.parameters[0].~`
 * - `$input.return.~`
 *
 * By the way, if what you want is not finding every type errors, but just
 * finding the 1st type error, then use {@link assertEqualsFunction} instead.
 * Otherwise, what you want is just validating parameters or return value only,
 * you can use {@link validateEqualsParameters} or {@link validateEqualsReturn}
 * instead.
 *
 * On the other hand, if you want to allow any superfluous properties, utilize
 * {@link validateFunction} or {@link assertFunction} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to validate
 * @returns The wrapper function with type validations
=======
 * Wraps function to validate parameters and return value with strict equality.
 *
 * Wraps the target function and validates through {@link validateEquals}. Also
 * rejects extra properties not defined in type. Collects all errors.
 *
 * Error path format:
 *
 * - Parameter errors: `$input.parameters[0].property`
 * - Return errors: `$input.return.property`
 *
 * Related functions:
 *
 * - {@link validateFunction} — Allows extra properties
 * - {@link validateEqualsParameters} — Validates parameters only
 * - {@link validateEqualsReturn} — Validates return value only
 * - {@link assertEqualsFunction} — Throws on first error
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning {@link IValidation}
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function validateEqualsFunction<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<IValidation<R>>
    : (...args: Arguments) => IValidation<Output>
  : never;

/** @internal */
export function validateEqualsFunction(): never {
  NoTransformConfigurationError("functional.validateEqualsFunction");
}

/**
<<<<<<< HEAD
 * Validates parameters with strict equality.
 *
 * Validates a function, by wrapping the function and checking its parameters
 * through {@link validateEquals} function. If some parameter does not match the
 * expected type, it returns {@link IValidation.IError} typed object. Otherwise
 * there's no type error, it returns {@link IValidation.ISuccess} typed object
 * instead.
 *
 * For reference, {@link IValidation.IError.path} would be a little bit different
 * with individual {@link validateEquals} function. If the
 * {@link IValidation.IError} occurs from some parameter, the path would start
 * from `$input.parameters[number]`.
 *
 * By the way, if what you want is not finding every type errors, but just
 * finding the 1st type error, then use {@link assertEqualsParameters} instead.
 * Otherwise, what you want is not only validating parameters, but also
 * validating return value, you can use {@link validateEqualsFunction} instead.
 *
 * On the other hand, if you want to allow any superfluous properties, utilize
 * {@link validateParameters} or {@link assertParameters} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to validate
 * @returns The wrapper function with type validations
=======
 * Wraps function to validate parameters with strict equality.
 *
 * Wraps the target function and validates parameters through
 * {@link validateEquals}. Also rejects extra properties. Return value is not
 * validated.
 *
 * Error path format: `$input.parameters[0].property`
 *
 * Related functions:
 *
 * - {@link validateParameters} — Allows extra properties
 * - {@link validateEqualsFunction} — Also validates return value
 * - {@link assertEqualsParameters} — Throws on first error
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning {@link IValidation}
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function validateEqualsParameters<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<IValidation<R>>
    : (...args: Arguments) => IValidation<Output>
  : never;

/** @internal */
export function validateEqualsParameters(): never {
  NoTransformConfigurationError("functional.validateEqualsParameters");
}

/**
<<<<<<< HEAD
 * Validates return value with strict equality.
 *
 * Validates a function, by wrapping the function and checking its return value
 * through {@link validateEquals} function. If the return value does not match
 * the expected type, it returns {@link IValidation.IError} typed object.
 * Otherwise there's no type error, it returns {@link IValidation.ISuccess} typed
 * object instead.
 *
 * For reference, {@link IValidation.IError.path} would be a little bit different
 * with individual {@link validateEquals} function. If the
 * {@link IValidation.IError} occurs from the return value, the path would start
 * from `$input.return`.
 *
 * By the way, if what you want is not finding every type errors, but just
 * finding the 1st type error, then use {@link assertEqualsReturn} instead.
 * Otherwise, what you want is not only validating return value, but also
 * validating parameters, you can use {@link validateEqualsFunction} instead.
 *
 * On the other hand, if you want to allow any superfluous properties, utilize
 * {@link validateReturn} or {@link assertReturn} instead.
 *
 * @author Jeongho Nam - https://github.com/samchon
 * @template T Target function type
 * @param func Target function to validate
 * @returns The wrapper function with type validations
=======
 * Wraps function to validate return value with strict equality.
 *
 * Wraps the target function and validates return value through
 * {@link validateEquals}. Also rejects extra properties. Parameters are not
 * validated.
 *
 * Error path format: `$input.return.property`
 *
 * Related functions:
 *
 * - {@link validateReturn} — Allows extra properties
 * - {@link validateEqualsFunction} — Also validates parameters
 * - {@link assertEqualsReturn} — Throws on first error
 *
 * @template T Target function type
 * @param func Function to wrap
 * @returns Wrapped function returning {@link IValidation}
>>>>>>> a7cbc4f1aec621fbd409afc8da295570e4fa2713
 */
export function validateEqualsReturn<T extends (...args: any[]) => any>(
  func: T,
): T extends (...args: infer Arguments) => infer Output
  ? Output extends Promise<infer R>
    ? (...args: Arguments) => Promise<IValidation<R>>
    : (...args: Arguments) => IValidation<Output>
  : never;

/** @internal */
export function validateEqualsReturn(): never {
  NoTransformConfigurationError("functional.validateEqualsReturn");
}
