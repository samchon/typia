{"/docs/json/stringify":{"title":"Stringify","data":{"":"","stringify-functions#stringify() functions":"export function stringify<T>(input: T): string;\nexport function isStringify<T>(input: unknown | T): string | null;\nexport function assertStringify<T>(input: unknown | T): string;\nexport function validateStringify<T>(input: unknown | T): IValidation<string>;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nYou can boost up JSON serialization speed just by calling typia.stringify<T>() function. Also, you even can ensure type safety of JSON serialization by calling other functions like typia.isStringify() and typia.assertStringify() functions.As typia.stringify<T>() function writes dedicated JSON serialization code only for the target type T, its performance is much faster than native JSON.stringify() function. However, because of the dedicated optimal JSON serialization code, when wrong typed data comes, unexpected error be occured.Instead, typia supports type safe JSON serialization functions like typia.isStringify(). The typia.isStringify() is a combination function of typia.is<T>() and typia.stringify<T>() function. It checks whether the input value is valid for the target type T or not first, and operate JSON serialization later. If the input value is not matched with the type T, it returns null value.\ntypia.isStringify(): typia.is<T>() + typia.stringify<T>()\ntypia.assertStringify(): typia.assert<T>() + typia.stringify<T>()\ntypia.validateStringify(): typia.validate<T>() + typia.stringify<T>()\n\n\n\n\n\nAOT compliation\ntypia.isStringify() and other similar functions are still much faster than native JSON.stringify() function, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\n\n\n\nimport typia from \"typia\";\n\nconst department: IDepartment = typia.random<IDepartment>();\nconst json: string = typia.isStringify(department);\n\nconsole.log(json); // not null, but string\n\ninterface IDepartment {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @minLength 3\n*/\nname: string;\n\n/**\n* @type int\n*/\nlimit: number;\n\nclerks: IClerk[];\n}\ninterface IClerk {\nname: string;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n\nauthority: number;\n\n/**\n* @format date\n*/\njoined_at: string;\n}\n\n\n\nimport typia from \"typia\";\n\nconst department = ((generator) => {\nconst $generator = typia.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"uuid\",\n},\n]) ?? (generator?.uuid ?? $generator.uuid)(),\nname:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"minLength\",\nvalue: \"3\",\n},\n]) ??\n(generator?.string ?? $generator.string)(\n(generator?.integer ?? $generator.integer)(3, 25),\n),\nlimit:\n(generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"type\",\nvalue: \"uint\",\n},\n]) ?? (generator?.integer ?? $generator.integer)(0, 10),\nclerks: (generator?.array ?? $generator.array)(() =>\n$ro1(_recursive, _recursive ? 1 + _depth : _depth),\n),\n});\nconst $ro1 = (_recursive = false, _depth = 0) => ({\nname:\n(generator?.customs ?? $generator.customs)?.string?.([]) ??\n(generator?.string ?? $generator.string)(),\nage:\n(generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"exclusiveMinimum\",\nvalue: \"19\",\n},\n{\nname: \"maximum\",\nvalue: \"100\",\n},\n]) ?? (generator?.number ?? $generator.number)(19, 100),\nauthority:\n(generator?.customs ?? $generator.customs)?.number?.([]) ??\n(generator?.number ?? $generator.number)(0, 100),\njoined_at:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"date\",\n},\n]) ?? (generator?.date ?? $generator.date)(),\n});\nreturn $ro0();\n})();\n\nconst json = ((input) => {\nconst is = (input) => {\nconst $is_uuid = typia.isStringify.is_uuid;\nconst $is_date = typia.isStringify.is_date;\nconst $io0 = (input) =>\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.name && 3 <= input.name.length &&\n\"number\" === typeof input.limit && !Number.isNaN(input.limit) && parseInt(input.limit) === input.limit && 0 <= input.limit &&\nArray.isArray(input.clerks) && input.clerks.every(\n(elem) =>\n\"object\" === typeof elem && null !== elem && $io1(elem),\n);\nconst $io1 = (input) =>\n\"string\" === typeof input.name &&\n\"number\" === typeof input.age && 19 < input.age && 100 >= input.age &&\n\"number\" === typeof input.authority && !Number.isNaN(input.authority) &&\n\"string\" === typeof input.joined_at && $is_date(input.joined_at);\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nconst stringify = (input) => {\nconst $string = typia.isStringify.string;\n$is_date(input.joined_at);\nconst $so0 = (input) =>\n`{\"id\":${'\"' + input.id + '\"'},\"name\":${$string(\ninput.name,\n)},\"limit\":${input.limit},\"clerks\":${`[${input.clerks\n.map((elem) => $so1(elem))\n.join(\",\")}]`}}`;\nconst $so1 = (input) =>\n`{\"name\":${$string(input.name)},\"age\":${input.age},\"authority\":${\ninput.authority\n},\"joined_at\":${'\"' + input.joined_at + '\"'}}`;\nreturn $so0(input);\n};\nreturn is(input) ? stringify(input) : null;\n})(department);\n\nconsole.log(json); // not null, but string","reusable-functions#Reusable functions":"export function createStringify<T>: (input: T) => string;\nexport function createIsStringify<T>: (input: unknown | T) => string | null;\nexport function createAssertStringify<T>: (input: unknown) => string;\nexport function createValidateStringify<T>: (input: unknown) => IValidation<string>;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nReusable typia.stringify<T>() function generators.If you repeat to call typia.stringify<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createStringify<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia from \"typia\";\n\nexport const assertDepartment = typia.createAssertStringify<IDepartment>();\n\ninterface IDepartment {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @minLength 3\n*/\nname: string;\n\n/**\n* @type int\n*/\nlimit: number;\n\nclerks: IClerk[];\n}\ninterface IClerk {\nname: string;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n\nauthority: number;\n\n/**\n* @format date\n*/\njoined_at: string;\n}\n\n\n\nimport typia from \"typia\";\n\nexport const assertDepartment = (input) => {\nconst assert = (input) => {\nconst $guard = typia.createAssertStringify.guard;\nconst $is_uuid = typia.createAssertStringify.is_uuid;\nconst $is_date = typia.createAssertStringify.is_date;\nconst __is = (input) => {\nconst $is_uuid = typia.createAssertStringify.is_uuid;\nconst $is_date = typia.createAssertStringify.is_date;\nconst $io0 = (input) =>\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.name && 3 <= input.name.length &&\n\"number\" === typeof input.limit && !Number.isNaN(input.limit) && parseInt(input.limit) === input.limit && 0 <= input.limit &&\nArray.isArray(input.clerks) && input.clerks.every(\n(elem) =>\n\"object\" === typeof elem && null !== elem && $io1(elem),\n);\nconst $io1 = (input) =>\n\"string\" === typeof input.name &&\n\"number\" === typeof input.age && 19 < input.age && 100 >= input.age &&\n\"number\" === typeof input.authority && !Number.isNaN(input.authority) &&\n\"string\" === typeof input.joined_at && $is_date(input.joined_at);\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n($is_uuid(input.id) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.name &&\n(3 <= input.name.length ||\n$guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLength 3)\",\nvalue: input.name,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string\",\nvalue: input.name,\n})) &&\n((\"number\" === typeof input.limit &&\n!Number.isNaN(input.limit) &&\n(parseInt(input.limit) === input.limit ||\n$guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number (@type int)\",\nvalue: input.limit,\n})) &&\n(0 <= input.limit ||\n$guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number (@type int)\",\nvalue: input.limit,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number\",\nvalue: input.limit,\n})) &&\n(Array.isArray(input.clerks) ||\n$guard(_exceptionable, {\npath: _path + \".clerks\",\nexpected: \"Array<IClerk>\",\nvalue: input.clerks,\n})) &&\ninput.clerks.every(\n(elem, _index1) =>\n((\"object\" === typeof elem && null !== elem) ||\n$guard(_exceptionable, {\npath: _path + \".clerks[\" + _index1 + \"]\",\nexpected: \"IClerk\",\nvalue: elem,\n})) &&\n$ao1(\nelem,\n_path + \".clerks[\" + _index1 + \"]\",\ntrue && _exceptionable,\n),\n);\nconst $ao1 = (input, _path, _exceptionable = true) =>\n(\"string\" === typeof input.name ||\n$guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string\",\nvalue: input.name,\n})) &&\n((\"number\" === typeof input.age &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age,\n})) &&\n(100 >= input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age,\n})) &&\n((\"number\" === typeof input.authority &&\n!Number.isNaN(input.authority)) ||\n$guard(_exceptionable, {\npath: _path + \".authority\",\nexpected: \"number\",\nvalue: input.authority,\n})) &&\n((\"string\" === typeof input.joined_at &&\n($is_date(input.joined_at) ||\n$guard(_exceptionable, {\npath: _path + \".joined_at\",\nexpected: \"string (@format date)\",\nvalue: input.joined_at,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".joined_at\",\nexpected: \"string\",\nvalue: input.joined_at,\n}));\nreturn (\n((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IDepartment\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)\n);\n})(input, \"$input\", true);\nreturn input;\n};\nconst stringify = (input) => {\nconst $string = typia.createAssertStringify.string;\nconst $so0 = (input) =>\n`{\"id\":${'\"' + input.id + '\"'},\"name\":${$string(\ninput.name,\n)},\"limit\":${input.limit},\"clerks\":${`[${input.clerks\n.map((elem) => $so1(elem))\n.join(\",\")}]`}}`;\nconst $so1 = (input) =>\n`{\"name\":${$string(input.name)},\"age\":${input.age},\"authority\":${\ninput.authority\n},\"joined_at\":${'\"' + input.joined_at + '\"'}}`;\nreturn $so0(input);\n};\nreturn stringify(assert(input));\n};","performance#Performance":"Comparing JSON serialization speed with others, it is maximum 200x faster than class-transformer.For reference, class-transformer is the most famous library used in NestJS with class-validator. Also, fast-json-stringify is another famous one used in fastify. However, whether they are fast or slow, both of them require extra schema definition, that is different with TypeScript type. If you see the code below without experience of them, you may get shocked: how complicate and inefficient they are:\nfast-json-stringify requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\n\n\nMeasured on Intel i5-1135g7, Surface Pro 8","server-performance#Server Performance":"Someone may ask:\nJSON serialization speed affects on the server performance?I think that the JSON serialization is just a tiny thing in the server side, isn't it?\nMy answer is, \"Yes, it affects on the server performance\".Most operations in NodeJS server are asynchronously executed in background thread, what are called \"event based non-blocking I/O model\". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs":{"title":"Index","data":{"":"","outline#Outline":"// RUNTIME VALIDATORS\nexport function is<T>(input: unknown | T): input is T; // returns boolean\nexport function assert<T>(input: unknown | T): T; // throws TypeGuardError\nexport function validate<T>(input: unknown | T): IValidation<T>; // detailed\nexport const customValidators: CustomValidatorMap; // customizable\n\n// ENHANCED JSON\nexport function application<...Args>(): IJsonApplication; // JSON schema\nexport function assertParse<T>(input: string): T; // type safe parser\nexport function assertStringify<T>(input: T): string; // safe and faster\n// +) isParse, validateParse\n// +) stringify, isStringify, validateStringify\n\n// RANDOM DATA GENERATOR\nexport function random<T>(g?: Partial<IRandomGenerator>): Primitive<T>;\nTypia is a transformer library, supporting those features:\nSuper-fast Runtime Validators\nSafe JSON parse and fast stringify\nJSON schema generator\nRandom data generator\n\n\n\n\n\nOnly one line required, with pure TypeScript type\n\nRuntime validator is 20,000x faster than class-validator\n\nJSON serialization is 200x faster than class-transformer","sponsors#Sponsors":"Thanks for your support.Your donation would encourage typia development."}},"/docs/utilization/nestjs":{"title":"Nestjs","data":{"":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: superfast decorators using typia\n@nestia/sdk: evolved SDK and Swagger generators\n@nestia/migrate: Swagger to NestJS\nnestia: just CLI (command line interface) tool\n\n\nimport { Controller } from \"@nestjs/common\";\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\n\nimport type { IBbsArticle } from \"@bbs-api/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n/**\n* Store a new content.\n*\n* @param inupt Content to store\n* @returns Newly archived article\n*/\n@TypedRoute.Post() // 200x faster and safer JSON.stringify()\npublic async store(\n@TypedBody() input: IBbsArticle.IStore // 20,000x faster validator\n): Promise<IBbsArticle>;\n// do not need DTO class definition,\n// just fine with interface\n}\n\nLeft: NestJS server code\nRight: Client code using SDK"}},"/docs/utilization/trpc":{"title":"Trpc","data":{"":"import { initTRPC } from \"@trpc/server\";\nimport { v4 } from \"uuid\";\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"../structures/IBbsArticle\";\n\nconst server = initTRPC.create();\n\nexport const appRouter = server.router({\nstore: server.procedure\n.input(typia.createAssert<IBbsArticle.IStore>())\n.output(typia.createAssert<IBbsArticle>())\n.query(({ input }) => {\nreturn {\nid: v4(),\nwriter: input.writer,\ntitle: input.title,\nbody: input.body,\ncreated_at: new Date().toString(),\n};\n})\n});\nexport type AppRouter = typeof appRouter;"}},"/docs/setup":{"title":"Setup","data":{"":"","transformation#Transformation":"npm install --save typia\nnpx typia setup\nAOT (Ahead of Time) compilation mode.When you write a TypeScript code calling typia.createIs<IMember>() function and compile it through tsc command, typia will write optimal validation code in JavaScript file like below, for the IMember type.This is the transform mode performing AOT (Ahead of Time) compilation.\n\n\nimport typia from \"typia\";\n\nexport const check = typia.createIs<IMember>();\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\nexport const check = input => {\nconst $is_uuid = typia.createIs.is_uuid;\nconst $is_email = typia.createIs.is_email;\nreturn \"object\" === typeof input &&\nnull !== input &&\n(\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n(\"string\" === typeof input.email && $is_email(input.email)) &&\n(\"number\" === typeof input.age && 19 < input.age && 100 >= input.age)\n);\n};","generation#Generation":"# INSTALL TYPIA\nnpm install --save typia\nnpm install --save-dev typescript\n\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nnpx typia generate \\\n--input src/templates \\\n--output src/generated \\\n--project tsconfig.json\nFor frontend projects.If you're using non-standard TypeScript compiler, you can't use transform mode.\nNon-standard TypeScript compilers:\nswc in Next.JS\nesbuild in Vite\nbabel in Create-React-App\n\n\n\nInstead, you should utilize the generation mode.Install typia through npm install command and run typia generate command. Then, generator of typia reads your TypeScript code of --input, and writes transformed TypeScript code into the --output directory, like below.\n\n\nimport typia from \"typia\";\n\nimport { IMember } from \"../structures/IMember\";\n\nexport const check = typia.createIs<IMember>();\n\n\n\nimport typia from \"typia\";\nimport { IMember } from \"../structures/IMember\";\nexport const check = (input: any): input is IMember => {\nconst $is_uuid = (typia.createIs as any).is_uuid;\nconst $is_email = (typia.createIs as any).is_email;\nreturn \"object\" === typeof input &&\nnull !== input &&\n(\n\"string\" === typeof input.id && is_uuid(input.id) &&\n(\"string\" === typeof input.email && $is_email(input.email)) &&\n(\"number\" === typeof input.age && 19 <= input.age && 100 >= input.age)\n);\n};","vite#Vite":"If you've made your frontend project through vite, you can utilize the transformation mode.Just configure vite.config.ts file below, that's all.\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport typescript from \"@rollup/plugin-typescript\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\nplugins: [\nreact(),\ntypescript()\n]\n});"}},"/docs/json/parse":{"title":"Parse","data":{"":"","parse-functions#parse() functions":"export function isParse<T>(input: string): T | null;\nexport function assertParse<T>(input: string): T;\nexport function validateParse<T>(input: string): IValidation<T>;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nType safe JSON parser.Unlink native JSON.parse() function which returns any typed instance without type checking, typia.assertParse<T>() function validates instance type after the parsing. If the parsed value is not following the promised type T, it throws TypeGuardError with the first type error info.If you want to know every type error infos detaily, you can use typia.validateParse<T>() function instead. Otherwise, you just only want to know whether the parsed value is following the type T or not, just call typia.isParse<T>() function.\ntypia.isParse<T>(): JSON.parse() + typia.is<T>()\ntypia.assertParse<T>(): JSON.parse() + typia.assert<T>()\ntypia.validateParse<T>(): JSON.parse() + typia.validate<T>()\n\nLook at the below code, then you may understand how the typia.assertParse<T>() function works.\n\n\nimport typia from \"typia\";\n\nconst json: string = JSON.stringify(typia.random<IMember>());\nconst parsed: IMember = typia.assertParse<IMember>(json);\n\nconsole.log(json === JSON.stringify(parsed)); // true\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nconst json = JSON.stringify(\n((generator) => {\nconst $generator = typia.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"uuid\",\n},\n]) ?? (generator?.uuid ?? $generator.uuid)(),\nemail:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"email\",\n},\n]) ?? (generator?.email ?? $generator.email)(),\nage:\n(generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"exclusiveMinimum\",\nvalue: \"19\",\n},\n{\nname: \"maximum\",\nvalue: \"100\",\n},\n]) ?? (generator?.number ?? $generator.number)(19, 100),\n});\nreturn $ro0();\n})(),\n);\nconst parsed = ((input) => {\nconst assert = (input) => {\nconst $guard = typia.assertParse.guard;\nconst $is_uuid = typia.assertParse.is_uuid;\nconst $is_email = typia.assertParse.is_email;\nconst __is = (input) => {\nreturn (\n\"object\" === typeof input && null !== input &&\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.email && $is_email(input.email) &&\n\"number\" === typeof input.age && 19 < input.age && 100 >= input.age\n);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n($is_uuid(input.id) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.email &&\n($is_email(input.email) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string (@format email)\",\nvalue: input.email,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string\",\nvalue: input.email,\n})) &&\n((\"number\" === typeof input.age &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age,\n})) &&\n(100 >= input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age,\n}));\nreturn (\n((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)\n);\n})(input, \"$input\", true);\nreturn input;\n};\ninput = JSON.parse(input);\nreturn assert(input);\n})(json);\n\nconsole.log(json === JSON.stringify(parsed)); // true","reusable-functions#Reusable functions":"export function createIsParse<T>(): (input: string) => T | null;\nexport function createAssertParse<T>(): (input: string) => T;\nexport function createValidateParse<T>(): (input: string) => IValidation<T>;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nReusable typia.isParse<T>() function generators.If you repeat to call typia.isParse<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIsParse<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia from \"typia\";\n\nexport const parseMember = typia.createIsParse<IMember>();\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nexport const parseMember = (input) => {\nconst is = (input) => {\nconst $is_uuid = typia.createIsParse.is_uuid;\nconst $is_email = typia.createIsParse.is_email;\nreturn (\n\"object\" === typeof input && null !== input &&\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.email && $is_email(input.email) &&\n\"number\" === typeof input.age && 19 < input.age && 100 >= input.age\n);\n};\ninput = JSON.parse(input);\nreturn is(input) ? input : null;\n};"}},"/docs/json/schema":{"title":"Schema","data":{"":"","application-function#application() function":"export function application<\nSchemas extends unknown[],\nPurpose extends \"ajv\" | \"swagger\",\nPrefix extends string = Purpose extends \"ajv\"\n? \"components#/schemas\"\n: \"#/components/schemas\",\n>(): IJsonApplication;\n\n\n\nexport interface IJsonApplication {\nschemas: IJsonSchema[];\ncomponents: IJsonComponents;\npurpose: \"swagger\" | \"ajv\";\nprefix: string;\n}\n\n\n\nexport interface IJsonComponents {\nschemas: Record<string, IJsonComponents.IObject>;\n}\nexport namespace IJsonComponents {\nexport interface IObject {\n$id?: string;\n$recursiveAnchor?: boolean;\n\ntype: \"object\";\nnullable: boolean;\n\nproperties: Record<string, IJsonSchema>;\npatternProperties?: Record<string, IJsonSchema>;\nadditionalProperties?: IJsonSchema;\n\nrequired?: string[];\ndescription?: string;\n\"x-typia-jsDocTags\"?: IJsDocTagInfo[];\n\"x-typia-patternProperties\"?: Record<string, IJsonSchema>;\n\"x-typia-additionalProperties\"?: IJsonSchema;\n}\n}\n\n\n\nexport type IJsonSchema = IJsonSchema.NotUnknown | IJsonSchema.IUnknown;\nexport namespace IJsonSchema {\nexport type NotUnknown =\n| IEnumeration<\"boolean\">\n| IEnumeration<\"number\">\n| IEnumeration<\"string\">\n| IBoolean\n| IInteger\n| INumber\n| IString\n| IArray\n| ITuple\n| IOneOf\n| IReference\n| IRecursiveReference\n| INullOnly;\n\n/* -----------------------------------------------------------\nATOMICS\n----------------------------------------------------------- */\nexport interface IEnumeration<\nLiteral extends Exclude<Atomic.Literal, \"bigint\">,\n> extends IAtomic<Literal> {\nenum: Array<Atomic.Mapper[Literal]>;\n}\nexport interface IAtomic<Literal extends Exclude<Atomic.Literal, \"bigint\">>\nextends ISignificant<Literal> {\ndefault?: Atomic.Mapper[Literal];\n}\nexport interface IString extends IAtomic<\"string\"> {\n/**\n* @type uint\n*/\nminLength?: number;\n/**\n* @type uint\n*/\nmaxLength?: number;\npattern?: string;\nformat?: string;\n}\nexport interface INumber extends IAtomic<\"number\"> {\nminimum?: number;\nmaximum?: number;\nexclusiveMinimum?: boolean;\nexclusiveMaximum?: boolean;\nmultipleOf?: number;\n}\nexport interface IInteger extends IAtomic<\"integer\"> {\n/**\n* @type int\n*/\nminimum?: number;\n/**\n* @type int\n*/\nmaximum?: number;\nexclusiveMinimum?: boolean;\nexclusiveMaximum?: boolean;\n/**\n* @type int\n*/\nmultipleOf?: number;\n}\nexport interface IBoolean extends IAtomic<\"boolean\"> {}\n\n/* -----------------------------------------------------------\nOBJECTS\n----------------------------------------------------------- */\nexport interface IArray extends ISignificant<\"array\"> {\nitems: IJsonSchema;\n/**\n* @type uint\n*/\nminItems?: number;\n/**\n* @type uint\n*/\nmaxItems?: number;\n\"x-typia-tuple\"?: ITuple;\n}\nexport interface ITuple extends ISignificant<\"array\"> {\nitems: IJsonSchema[];\n}\nexport interface IReference extends IAttribute {\n$ref: string;\n}\nexport interface IRecursiveReference extends IAttribute {\n$recursiveRef: string;\n}\nexport interface INullOnly extends IAttribute {\ntype: \"null\";\n}\n\n/* -----------------------------------------------------------\nMISCELLANEOUS\n----------------------------------------------------------- */\nexport interface IOneOf extends IAttribute {\noneOf: IJsonSchema[];\n}\nexport interface IUnknown {}\n\nexport interface ISignificant<Literal extends string> extends IAttribute {\ntype: Literal;\nnullable: boolean;\n}\nexport interface IAttribute {\ndeprecated?: boolean;\ntitle?: string;\ndescription?: string;\n\"x-typia-metaTags\"?: IMetadataTag[];\n\"x-typia-jsDocTags\"?: IJsDocTagInfo[];\n\"x-typia-required\"?: boolean;\n\"x-typia-rest\"?: boolean;\n}\n}\n\n\nJSON schema generator.\nDefinitions:\nIJsonApplication\nIJsonComponents\nIJsonSchema\n\n\n\nWhen you need JSON schema, do not write it by yourself, but just call typia.application() function.If you call the typia.application() with specialization of target Schemas, typia will analyze your Schemas and generate JSON schema definition in the compilation level. However, note that, JSON schema definitions of AJV and Swagger are a little bit different. Therefore, you have to consider which value to assign in the Purpose argument.\nSwagger can't express tuple type\nSwagger can't express pattern property\n\n\n\n\nimport typia from \"typia\";\n\nexport const MemberSchema = typia.application<[IMember], \"ajv\">();\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nexport const MemberSchema = {\nschemas: [\n{\n$ref: \"components#/schemas/IMember\",\n},\n],\ncomponents: {\nschemas: {\nIMember: {\n$id: \"components#/schemas/IMember\",\ntype: \"object\",\nproperties: {\nid: {\ntype: \"string\",\nnullable: false,\nformat: \"uuid\",\n},\nemail: {\ntype: \"string\",\nnullable: false,\nformat: \"email\",\n},\nage: {\ntype: \"number\",\nnullable: false,\nminimum: 19,\nexclusiveMinimum: true,\nmaximum: 100,\n},\n},\nnullable: false,\nrequired: [\"id\", \"email\", \"age\"],\n},\n},\n},\npurpose: \"ajv\",\nprefix: \"components#/schemas\",\n};","comment-tags#Comment Tags":"You can utilize comments and comment tags to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. When you write some comment tags starting with @ symbol, they would be placed into the proper properties of IJsonSchema. Below is the list of supported comment tags in the typia.application() function.Let's see how those comment tags works with example code.\nSupported comment tags\ncommon\n@deprecated\n@title {string}\n@default {value}\n\n\nnumber\n@type {\"int\"|\"uint\"}\n@minimum {number}\n@maximum {number}\n@exclusiveMinimum {number}\n@exclusiveMaximum {number}\n@multipleOf {number}\n\n\nstring\n@minLength {number}\n@maxLength {number}\n@pattern {regex}\n@format {keyword}\nemail\nuuid\nipv4\nipv6\ndate: YYYY-MM-DD\ndate-time: Date.toISOString()\n\n\n\n\narray\n@minItems {number}\n@maxItems {number}\n\n\n\n\n\n\n\n\nimport typia from \"typia\";\n\nexport const CommentTagSchema = typia.application<[CommentTag], \"ajv\">();\n\n/**\n* @title Example schema for comment tags\n* @deprecated\n*/\ninterface CommentTag {\n/**\n* @title Unsigned integer\n* @type uint\n* @deprecated\n*/\ntype: number;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n* @default 30\n*/\nnumber?: number;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\n/**\n* @pattern ^[a-z]+$\n*/\npattern: string;\n\n/**\n* @format date-time\n*/\nformat: string | null;\n\n/**\n* In the Array case, possible to restrict its elements.\n*\n* @minItems 3\n* @maxItems 100\n* @format uuid\n*/\narray: string[];\n}\n\n\n\nimport typia from \"typia\";\n\nexport const CommentTagSchema = {\nschemas: [\n{\n$ref: \"components#/schemas/CommentTag\",\n},\n],\ncomponents: {\nschemas: {\nCommentTag: {\n$id: \"components#/schemas/CommentTag\",\ntype: \"object\",\nproperties: {\ntype: {\ntype: \"integer\",\nnullable: false,\ndeprecated: true,\ntitle: \"Unsigned integer\",\nminimum: 0,\n},\nnumber: {\ntype: \"number\",\nnullable: false,\nminimum: 19,\nexclusiveMinimum: true,\nmaximum: 100,\ndefault: 30,\n},\nstring: {\ntype: \"string\",\nnullable: false,\nminLength: 3,\n},\npattern: {\ntype: \"string\",\nnullable: false,\npattern: \"^[a-z]+$\",\n},\nformat: {\ntype: \"string\",\nnullable: true,\nformat: \"date-time\",\n},\narray: {\ntype: \"array\",\nitems: {\ntype: \"string\",\nnullable: false,\ndescription:\n\"In the Array case, possible to restrict its elements.\",\nformat: \"uuid\",\n},\nnullable: false,\ndescription:\n\"In the Array case, possible to restrict its elements.\",\nminItems: 3,\nmaxItems: 100,\n},\n},\nnullable: false,\nrequired: [\n\"type\",\n\"string\",\n\"pattern\",\n\"format\",\n\"array\",\n]\n},\n},\n},\npurpose: \"ajv\",\nprefix: \"components#/schemas\",\n};"}},"/docs/validators/comment-tags":{"title":"Comment Tags","data":{"":"","outline#Outline":"typia can use comment tags for type validation.In TypeScript (and JavaScript), writing @ character in comment is called \"Comment Tag\", and typia utilizes such comment tags for enhancing type validation logic. As you can see from below example code, typia analyzes @tagName value patterned comment tags, and generates optimal validation logic in the compilation level.Therefore, don't be afraid typia uses only pure TypeScript types for type validation schema. Don't be afraid about TypeScript does not support integer type. With those comment tags, you can express any type that exists in the world.\nQ: How to validate integer type? TypeScript does not support it\nA: Write a comment tag @type int on the target property\n\n\n\n\nimport typia from \"typia\";\n\nexport const checkCommentTag = typia.createIs<CommentTag>();\n\ninterface CommentTag {\n/**\n* @type int\n*/\ntype: number;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nnumber?: number;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\n/**\n* @pattern ^[a-z]+$\n*/\npattern: string;\n\n/**\n* @format date-time\n*/\nformat: string | null;\n\n/**\n* In the Array case, possible to restrict its elements.\n*\n* @minItems 3\n* @maxItems 100\n* @format uuid\n*/\narray: string[];\n}\n\n\n\nimport typia from \"typia\";\n\nexport const checkCommentTag = (input) => {\nconst $is_datetime = typia.createIs.is_datetime;\nconst $is_uuid = typia.createIs.is_uuid;\nconst $io0 = (input) =>\n\"number\" === typeof input.type &&\nparseInt(input.type) === input.type &&\n(undefined === input.number ||\n(\"number\" === typeof input.number &&\n19 < input.number &&\n100 >= input.number)) &&\n\"string\" === typeof input.string &&\n3 <= input.string.length &&\n\"string\" === typeof input.pattern &&\nRegExp(/^[a-z]+$/).test(input.pattern) &&\n(null === input.format ||\n(\"string\" === typeof input.format && $is_datetime(input.format))) &&\nArray.isArray(input.array) &&\n3 <= input.array.length &&\n100 >= input.array.length &&\ninput.array.every((elem) => \"string\" === typeof elem && $is_uuid(elem));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};","supported-tags#Supported Tags":"typia supports those comment tags.I think below list is not hard to understand.\nnumber\n@type {\"int\"|\"uint\"}\n@minimum {number}\n@maximum {number}\n@exclusiveMinimum {number}\n@exclusiveMaximum {number}\n@multipleOf {number}\n\n\nstring\n@minLength {number}\n@maxLength {number}\n@pattern {regex}\n@format {keyword}\nemail\nuuid\nipv4\nipv6\ndate: YYYY-MM-DD\ndate-time: Date.toISOString()\n\n\n\n\narray\n@minItems {number}\n@maxItems {number}","customization#Customization":"export function is<T>(input: unknown): input is T;\nexport function assert<T>(input: unknown): T;\nexport function validate<T>(input: unknown): IValidation<T>;\n\nexport const customValidators: CustomValidatorMap;\n\n\n\nexport interface CustomValidatorMap {\nsize(): number;\nsize(name: string): number;\nhas: (name: string) => (type: keyof Customizable) => boolean;\nget(\nname: string,\n): <Type extends keyof Customizable>(\ntype: Type,\n) => CustomValidatorMap.Closure<Type> | undefined;\nerase(name: string): (type: keyof Customizable) => boolean;\ninsert(\nname: string, // tag name\n): <Type extends keyof Customizable>(\ntype: Type, // instance type -> boolean | number | bigint | string\n) => (closure: CustomValidatorMap.Closure<Type>) => boolean;\n}\nexport namespace CustomValidatorMap {\nexport type Closure<Type extends keyof Customizable> =\n(text: string) => // tag name\n(value: Customizable[Type]) => boolean; // instance value\n}\n\n\n\nexport interface Customizable {\nnumber: number;\nstring: string;\nbigint: bigint;\n}\n\n\nYou can add custom comment tags for type validation.If you need addtional comment tag for type validation, just define it by yourself. Write your custom validation logic as a closure function, and register it through typia.customValidationMap.insert() function, reading above CustomValidatorMap type definition.Note that, 1st parameter of typia.customValidationMap.insert() function means tag name, and 2nd parameter means instance type (boolean|nubmer|bigint|string). Also, when defining closure currying function of validation logic, 1st parameter means tag name and 2nd means input value.If you're not familiar with functional programming, just read below example code:\n\n\nimport typia from \"typia\";\n\nexport const checkTagCustom = typia.createIs<TagCustom>();\n\ntypia.customValidators.insert(\"powerOf\")(\"number\")(\n(text: string) => { // tag name\nconst denominator: number = Math.log(Number(text));\nreturn (value: number) => { // input value\nvalue = Math.log(value) / denominator;\nreturn Math.abs(value - Math.floor(value)) < .000001;\n};\n}\n);\ntypia.customValidators.insert(\"dollar\")(\"string\")(\n() => (value: string) => value.startsWith(\"$\"),\n);\n\ninterface TagCustom {\n/**\n* @powerOf 10\n*/\npowerOf: number;\n\n/**\n* @dollar\n*/\ndollar: string;\n}\n\n\n\nimport typia from \"typia\";\n\nexport const checkTagCustom = (input) => {\nconst $is_custom = typia.createIs.is_custom;\nreturn (\n\"object\" === typeof input && null !== input &&\n\"number\" === typeof input.powerOf &&\n$is_custom(\"powerOf\", \"number\", \"10\", input.powerOf) &&\n\"string\" === typeof input.dollar &&\n$is_custom(\"dollar\", \"string\", \"\", input.dollar)\n);\n};\n\ntypia.customValidators.insert(\"powerOf\")(\"number\")(\n(text) => {\nconst denominator = Math.log(Number(text));\nreturn (value) => {\nvalue = Math.log(value) / denominator;\nreturn Math.abs(value - Math.floor(value)) < 0.000001;\n};\n}\n);\ntypia.customValidators.insert(\"dollar\")(\"string\")(\n() => (value) => value.startsWith(\"$\"),\n);"}},"/":{"title":"Index","data":{"":"","outline#Outline":"// RUNTIME VALIDATORS\nexport function is<T>(input: unknown | T): input is T; // returns boolean\nexport function assert<T>(input: unknown | T): T; // throws TypeGuardError\nexport function validate<T>(input: unknown | T): IValidation<T>; // detailed\nexport const customValidators: CustomValidatorMap; // customizable\n\n// ENHANCED JSON\nexport function application<...Args>(): IJsonApplication; // JSON schema\nexport function assertParse<T>(input: string): T; // type safe parser\nexport function assertStringify<T>(input: T): string; // safe and faster\n// +) isParse, validateParse\n// +) stringify, isStringify, validateStringify\n\n// RANDOM DATA GENERATOR\nexport function random<T>(g?: Partial<IRandomGenerator>): Primitive<T>;\nTypia is a transformer library, supporting those features:\nSuper-fast Runtime Validators\nSafe JSON parse and fast stringify\nJSON schema generator\nRandom data generator\n\n\n\n\n\nOnly one line required, with pure TypeScript type\n\nRuntime validator is 20,000x faster than class-validator\n\nJSON serialization is 200x faster than class-transformer","sponsors#Sponsors":"Thanks for your support.Your donation would encourage typia development."}},"/docs/validators/is":{"title":"Is","data":{"":"","is-function#is() function":"export function is<T>(input: T): input is T;\nexport function is<T>(input: unknown): input is T;\nTests a value type.When you need to test an instance type, just call typia.is<T>() function.If the input value is following type T, true value would be returned. Otherwise, false would be returned.\n\n\n\nAOT compliation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\n\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\n\n\n\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n\nconst matched: boolean = typia.is<IMember>({\nid: v4(),\nemail: \"samchon.github@gmai19l.com\",\nage: 30,\n});\n\nconsole.log(matched); // true\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n\nconst matched = (input => {\nconst $is_uuid = typia_1.default.is.is_uuid;\nconst $is_email = typia_1.default.is.is_email;\nreturn \"object\" === typeof input &&\nnull !== input &&\n(\n\"string\" === typeof input.id && true === $is_uuid(input.id) &&\n(\"string\" === typeof input.email && $is_email(input.email)) &&\n(\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age && 100 >= input.age\n)\n);\n})({\nid: (0, uuid_1.v4)(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\n});\n\nconsole.log(matched); // true","equals-function#equals() function":"export function equals<T>(input: T): input is T;\nexport function equals<T>(input: unknown): input is T;\nMore strict checker prohibiting superfluous properties.typia.is<T>() can test instance type, but it allows superfluous properties.If you want to prohibit those superfluous properties, you can use typia.equals<T>() function instead.\n\n\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n\nconst input: unknown = {\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\nextra: \"superfluous property\", // extra\n};\nconst is: boolean = typia.is<IMember>(input);\nconst equals: boolean = typia.equals<IMember>(input);\n\nconsole.log(is, equals); // true, false\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n\nconst input = {\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\nextra: \"superfluous property\", // extra\n};\n\nconst is = ((input) => {\nconst $is_uuid = typia.is.is_uuid;\nconst $is_email = typia.is.is_email;\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.email && $is_email(input.email) &&\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age && 100 >= input.age\n);\n})(input);\nconst equals = ((input, _exceptionable = true) => {\nconst $is_uuid = typia.equals.is_uuid;\nconst $is_email = typia.equals.is_email;\nconst $io0 = (input, _exceptionable = true) =>\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.email && $is_email(input.email) &&\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age && 100 >= input.age\n(3 === Object.keys(input).length ||\nObject.keys(input).every((key) => {\nif ([\"id\", \"email\", \"age\"].some((prop) => key === prop))\nreturn true;\nconst value = input[key];\nif (undefined === value) return true;\nreturn false;\n}));\nreturn \"object\" === typeof input && null !== input && $io0(input, true);\n})(input);\n\nconsole.log(is, equals); // true, false","reusable-functions#Reusable functions":"export function createIs<T>(): (input: unknown) => input is T;\nexport function createEquals<T>(): (input: unknown) => input is T;\nReusable typia.is<T>() function generators.If you repeat to call typia.is<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIs<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia from \"typia\";\n\nexport const check = typia.createIs<IMember>();\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nexport const check = (input) => {\nconst $is_uuid = typia.createIs.is_uuid;\nconst $is_email = typia.createIs.is_email;\nreturn (\n\"object\" === typeof input && null !== input &&\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.email && $is_email(input.email) &&\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age && 100 >= input.age\n);\n};","auto-type-casting#Auto Type Casting":"export function is<T>(input: unknown): input is T;\nexport function equals<T>(input: unknown): input is T;\nexport function createIs<T>(): (input: unknown) => input is T;\nexport function createEquals<T>(): (input: unknown) => input is T;\ntypia.is<T>() function can be used for type casting.When target input value is following the type T, therefore true value be returned, typia.is<T>() function automatically casts the input value to the type T. Therefore, you can utilize the typia.is<T>() function for safe type casting tool like below:\nconst input: unknown = {\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\n} as any;\nif (typia.is<IMember>(input)) // auto type casting\nconsole.log(input.id, input.email, input.age);","performance#Performance":"Super-fast and super-safe.Comparing typia.is<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on Intel i5-1135g7, Surface Pro 8\n\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\n\nC.V. means class-validator"}},"/docs/random":{"title":"Random","data":{"":"","random-function#random() function":"export function random<T>(g?: IRandomGenerator): T;\n\n\n\nexport interface IRandomGenerator {\nboolean(): boolean;\ninteger(minimum?: number, maximum?: number): number;\nnumber(minimum?: number, maximum?: number): number;\nbigint(minimum?: bigint, maximum?: bigint): bigint;\nstring(length?: number): string;\narray<T>(closure: (index: number) => T, count?: number): T[];\n\nuuid(): string;\nemail(): string;\nurl(): string;\nipv4(): string;\nipv6(): string;\npattern(regex: RegExp): string;\ndate(minimum?: number, maximum?: number): string;\ndatetime(minimum?: number, maximum?: number): string;\n\ncustoms?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\nexport type CustomMap = {\n[Type in keyof Customizable]?:\n(tags: ICommentTag[]) => Customizable[Type] | undefined;\n};\n\nexport interface ICommentTag {\nname: string;\nvalue?: string;\n}\n}\n\n\n\nexport interface Customizable {\nnumber: number;\nstring: string;\nbigint: bigint;\n}\n\n\nYou can make every random data just by calling typia.random<T>() function.When you call the typia.random<T>() function, typia will analyze your type T, and writes optimal random generation code for the type T, in the compilation level. This is called AOT (Ahead of Time) compliation, and you may understand what it is just by reading below example code.\n\n\nimport typia from \"typia\";\n\nconst member: IMember = typia.random<IMember>();\n\nconsole.log(member);\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nconst member = ((generator) => {\nconst $generator = typia.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"uuid\",\n},\n]) ?? (generator?.uuid ?? $generator.uuid)(),\nemail:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"email\",\n},\n]) ?? (generator?.email ?? $generator.email)(),\nage:\n(generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"exclusiveMinimum\",\nvalue: \"19\",\n},\n{\nname: \"maximum\",\nvalue: \"100\",\n},\n]) ?? (generator?.number ?? $generator.number)(19, 100),\n});\nreturn $ro0();\n})();\n\nconsole.log(member);","reusable-function#Reusable function":"export function createRandom<T>(): (g?: IRandomGenerator) => T;\n\n\n\nexport interface IRandomGenerator {\nboolean(): boolean;\ninteger(minimum?: number, maximum?: number): number;\nnumber(minimum?: number, maximum?: number): number;\nbigint(minimum?: bigint, maximum?: bigint): bigint;\nstring(length?: number): string;\narray<T>(closure: (index: number) => T, count?: number): T[];\n\nuuid(): string;\nemail(): string;\nurl(): string;\nipv4(): string;\nipv6(): string;\npattern(regex: RegExp): string;\ndate(minimum?: number, maximum?: number): string;\ndatetime(minimum?: number, maximum?: number): string;\n\ncustoms?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\nexport type CustomMap = {\n[Type in keyof Customizable]?:\n(tags: ICommentTag[]) => Customizable[Type] | undefined;\n};\n\nexport interface ICommentTag {\nname: string;\nvalue?: string;\n}\n}\n\n\n\nexport interface Customizable {\nnumber: number;\nstring: string;\nbigint: bigint;\n}\n\n\nReusable typia.random<T>() function generators.If you repeat to call typia.random<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createRandom<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia from \"typia\";\n\nexport const createRandomMember = typia.createRandom<IMember>();\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nexport const createRandomMember = generator => {\nconst $generator = typia.createRandom.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"uuid\"\n}\n]) ?? (generator?.uuid ?? $generator.uuid)(),\nemail: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"email\"\n}\n]) ?? (generator?.email ?? $generator.email)(),\nage: (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"type\",\nvalue: \"int\"\n},\n{\nname: \"exclusiveMinimum\",\nvalue: \"19\"\n},\n{\nname: \"maximum\",\nvalue: \"100\"\n}\n]) ?? (generator?.integer ?? $generator.integer)(20, 100)\n});\nreturn $ro0();\n};","comment-tags#Comment Tags":"You can specialize the behavior of typia.random<T>() function by using comment tags.Below list shows which comment tags are supported in the typia.random<T>() function.Let's see how those comment tags work with example code.\nSupported comment tags\nnumber\n@type {\"int\"|\"uint\"}\n@minimum {number}\n@maximum {number}\n@exclusiveMinimum {number}\n@exclusiveMaximum {number}\n@multipleOf {number}\n\n\nstring\n@minLength {number}\n@maxLength {number}\n@pattern {regex}\n@format {keyword}\nemail\nuuid\nipv4\nipv6\ndate: YYYY-MM-DD\ndate-time: Date.toISOString()\n\n\n\n\narray\n@minItems {number}\n@maxItems {number}\n\n\n\n\n\n\n\n\nimport typia from \"typia\";\n\nconst data: CommentTag = typia.random<CommentTag>();\n\nconsole.log(data);\n\ninterface CommentTag {\n/**\n* @type int\n*/\ntype: number;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nnumber?: number;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\n/**\n* @pattern ^[a-z]+$\n*/\npattern: string;\n\n/**\n* @format date-time\n*/\nformat: string | null;\n\n/**\n* In the Array case, possible to restrict its elements.\n*\n* @minItems 3\n* @maxItems 100\n* @format uuid\n*/\narray: string[];\n}\n\n\n\nimport typia from \"typia\";\n\nconst data = (generator => {\nconst $generator = typia.random.generator;\nconst $pick = typia.random.pick;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\ntype: (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"type\",\nvalue: \"uint\"\n}\n]) ?? (generator?.integer ?? $generator.integer)(0, 10),\nnumber: $pick([\n() => undefined,\n() => (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"exclusiveMinimum\",\nvalue: \"19\"\n},\n{\nname: \"maximum\",\nvalue: \"100\"\n}\n]) ?? (generator?.number ?? $generator.number)(19, 100)\n])(),\nstring: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"minLength\",\nvalue: \"3\"\n}\n]) ?? (generator?.string ?? $generator.string)((generator?.integer ?? $generator.integer)(3, 25)),\npattern: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"pattern\",\nvalue: \"^[a-z]+$\"\n}\n]) ?? (generator?.pattern ?? $generator.pattern)(/^[a-z]+$/),\nformat: $pick([\n() => null,\n() => (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"date-time\"\n}\n]) ?? (generator?.datetime ?? $generator.datetime)()\n])(),\narray: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"minItems\",\nvalue: \"3\"\n},\n{\nname: \"maxItems\",\nvalue: \"100\"\n},\n{\nname: \"format\",\nvalue: \"uuid\"\n}\n]) ?? (generator?.uuid ?? $generator.uuid)(), (generator?.integer ?? $generator.integer)(3, 100))\n});\nreturn $ro0();\n})();\n\nconsole.log(data);","customization#Customization":"export function random<T>(g?: IRandomGenerator): T;\nexport function createRandom<T>: (g?: IRandomGenerator) => T;\n\n\n\nexport interface IRandomGenerator {\nboolean(): boolean;\ninteger(minimum?: number, maximum?: number): number;\nnumber(minimum?: number, maximum?: number): number;\nbigint(minimum?: bigint, maximum?: bigint): bigint;\nstring(length?: number): string;\narray<T>(closure: (index: number) => T, count?: number): T[];\n\nuuid(): string;\nemail(): string;\nurl(): string;\nipv4(): string;\nipv6(): string;\npattern(regex: RegExp): string;\ndate(minimum?: number, maximum?: number): string;\ndatetime(minimum?: number, maximum?: number): string;\n\ncustoms?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\nexport type CustomMap = {\n[Type in keyof Customizable]?:\n(tags: ICommentTag[]) => Customizable[Type] | undefined;\n};\n\nexport interface ICommentTag {\nname: string;\nvalue?: string;\n}\n}\n\n\n\nexport interface Customizable {\nnumber: number;\nstring: string;\nbigint: bigint;\n}\n\n\nYou can add custom comment tags for random data generation.As above IRandomGenerator.CustomMap has complicate currying function type, it may hard to understand for newcomers. However, such newcomers may easily understand, how to customize the random generation, after reading the following example.Just define custom comment tags like below, then everything would be done.\n\n\nimport typia from \"typia\";\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\n\nconst data: TagCustom = typia.random<TagCustom>({\ncustoms: {\nstring: (tags: typia.IRandomGenerator.ICommentTag[]) => {\nif (tags.find((t) => t.name === \"dollar\") !== undefined)\nreturn \"$\" + RandomGenerator.integer();\n\nconst postfix = tags.find((t) => t.name === \"postfix\");\nif (postfix !== undefined)\nreturn RandomGenerator.string() + postfix.value;\n},\nnumber: (tags: typia.IRandomGenerator.ICommentTag[]) => {\nconst powerOf = tags.find((t) => t.name === \"powerOf\");\nif (powerOf !== undefined)\nreturn Math.pow(\nNumber(powerOf.value),\nRandomGenerator.integer(1, 4),\n);\n},\n}\n});\n\nconsole.log(data);\n\ninterface TagCustom {\n/**\n* Regular feature supported by typia\n*\n* @format uuid\n*/\nid: string;\n\n/**\n* Custom feature composed with \"$\" + number\n*\n* @dollar\n*/\ndollar: string;\n\n/**\n* Custom feature composed with string + \"abcd\"\n*\n* @postfix abcd\n*/\npostfix: string;\n\n/**\n* Custom feature meaning x^y\n*\n* @powerOf 10\n*/\npower: number;\n}\n\n\n\nimport typia from \"typia\";\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\n\nconst data = (generator => {\nconst $generator = typia.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"uuid\"\n}\n]) ?? (generator?.uuid ?? $generator.uuid)(),\ndollar: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"dollar\"\n}\n]) ?? (generator?.string ?? $generator.string)(),\npostfix: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"postfix\",\nvalue: \"abcd\"\n}\n]) ?? (generator?.string ?? $generator.string)(),\npower: (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"powerOf\",\nvalue: \"10\"\n}\n]) ?? (generator?.number ?? $generator.number)(0, 100)\n});\nreturn $ro0();\n})({\ncustoms: {\nstring: (tags) => {\nif (tags.find((t) => t.name === \"dollar\") !== undefined)\nreturn \"$\" + RandomGenerator.integer();\nconst postfix = tags.find((t) => t.name === \"postfix\");\nif (postfix !== undefined)\nreturn RandomGenerator.string() + postfix.value;\n},\nnumber: (tags) => {\nconst powerOf = tags.find((t) => t.name === \"powerOf\");\nif (powerOf !== undefined)\nreturn Math.pow(Number(powerOf.value), RandomGenerator.integer(1, 4));\n},\n},\n});\n\nconsole.log(data);"}},"/docs/validators/assert":{"title":"Assert","data":{"":"","assert-function#assert() function":"export function assert<T>(input: T): T;\nexport function assert<T>(input: unknown): T;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\nAsserts a value type.typia.assert<T>() function throws a TypeGuardError when wrong type comes.The TypeGuardError instance has only the first type error info, with access path and expected type. In the below example case, as the age property is wrong with its definition (@exclusiveMinimum), such TypeGuardError would be thrown:\nmethod: typia.assert()\npath: input.age\nvalue: 18,\nexpected: number (@exclusiveMinimum 19)\n\n\n\n\n\nAOT compliation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\n\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\n\n\n\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n\ntypia.assert<IMember>({\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 18, // wrong, must be greater than 19\n});\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n\n((input) => {\nconst $guard = typia.assert.guard;\nconst $is_uuid = typia.assert.is_uuid;\nconst $is_email = typia.assert.is_email;\nconst __is = (input) => {\nconst $is_uuid = typia.assert.is_uuid;\nconst $is_email = typia.assert.is_email;\nreturn (\n\"object\" === typeof input && null !== input &&\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.email && $is_email(input.email) &&\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age && 100 >= input.age\n);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n($is_uuid(input.id) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.email &&\n($is_email(input.email) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string (@format email)\",\nvalue: input.email,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string\",\nvalue: input.email,\n})) &&\n((\"number\" === typeof input.age &&\n(parseInt(input.age) === input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@type int)\",\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age,\n})) &&\n(100 >= input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age,\n}));\nreturn (\n((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)\n);\n})(input, \"$input\", true);\nreturn input;\n})({\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\n});","assertequals-function#assertEquals() function":"export function assertEquals<T>(input: T): T;\nexport function assertEquals<T>(input: unknown): T;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\nMore strict assert function prohibiting superfluous properties.typia.assert<T>() function inspects input value type and throws TypeGuardError when mismatched, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, therefore throws an TypeGuardError when superfluous property exists, use typia.assertEquals<T()> function instead.In the below example case, as sex property is not defined in the IMember type, such TypeGuardError would be thrown:\nmethod: typia.assertEquals()`\npath: input.sex\nvalue: 1,\nexpected: undefined\n\n\n\n\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n\ntypia.assert<IMember>({\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\nsex: 1, // extra\n});\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n\n((input) => {\nconst $guard = typia.assert.guard;\nconst $is_uuid = typia.assert.is_uuid;\nconst $is_email = typia.assert.is_email;\nconst __is = (input) => {\nreturn (\n\"object\" === typeof input && null !== input &&\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.email && $is_email(input.email) &&\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age && 100 >= input.age\n);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n($is_uuid(input.id) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.email &&\n($is_email(input.email) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string (@format email)\",\nvalue: input.email,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string\",\nvalue: input.email,\n})) &&\n((\"number\" === typeof input.age &&\n(parseInt(input.age) === input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@type int)\",\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age,\n})) &&\n(100 >= input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age,\n}));\nreturn (\n((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)\n);\n})(input, \"$input\", true);\nreturn input;\n})({\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\nsex: 1, // extra\n});","reusable-functions#Reusable functions":"export function createAssert<T>(): (input: unknown) => T;\nexport function createAssertEquals<T>(): (input: unknown) => T;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\nReusable typia.assert<T>() function generators.If you repeat to call typia.assert<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createAssert<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia from \"typia\";\n\nexport const assertMember = typia.createAssert<IMember>();\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nexport const assertMember = (input) => {\nconst $guard = typia.createAssert.guard;\nconst $is_uuid = typia.createAssert.is_uuid;\nconst $is_email = typia.createAssert.is_email;\nconst __is = (input) => {\nconst $is_uuid = typia.createAssert.is_uuid;\nconst $is_email = typia.createAssert.is_email;\nreturn (\n\"object\" === typeof input && null !== input &&\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.email && $is_email(input.email) &&\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age &&\n100 >= input.age\n);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n($is_uuid(input.id) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.email &&\n($is_email(input.email) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string (@format email)\",\nvalue: input.email,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string\",\nvalue: input.email,\n})) &&\n((\"number\" === typeof input.age &&\n(parseInt(input.age) === input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@type int)\",\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age,\n})) &&\n(100 >= input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age,\n}));\nreturn (\n((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)\n);\n})(input, \"$input\", true);\nreturn input;\n};","performance#Performance":"Super-fast and super-safe.Comparing typia.assert<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on Intel i5-1135g7, Surface Pro 8\n\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\n\nC.V. means class-validator"}},"/docs/validators/validate":{"title":"Validate","data":{"":"","validate-function#validate() function":"export function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nValidates a value type.typia.validate<T>() function validates input value type, and archives every type errors detaily into IValidation.IFailure.errors array, when the input value is not following the promised type T. Of course, if the parametric input value is following the type T, IValidation.ISuccess instance would be returned.In the below example case, as id and age values are different with its definition of IMember, such errors would be archived into the IValidation.IFailure.errors array.\nerrors[0]\npath: input.id\nexpected: string\nvalue: 5\n\n\nerrors[1]\npath: input.age\nexpected: number (@type int)\nvalue: 20.75\n\n\n\n\n\n\n\nAOT compliation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\n\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\n\n\n\nimport typia from \"typia\";\n\nconst res: typia.IValidation<IMember> = typia.validate<IMember>({\nid: 5, // wrong, must be string (uuid)\nage: 20.75, // wrong, not integer\nemail: \"samchon.github@gmail.com\",\n});\n\nif (!res.success) console.log(res.errors);\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nconst res = ((input) => {\nconst __is = (input) => {\nconst $is_uuid = typia.validate.is_uuid;\nconst $is_email = typia.validate.is_email;\nreturn (\n\"object\" === typeof input && null !== input &&\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n\"string\" === typeof input.email && $is_email(input.email) &&\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age && 100 >= input.age\n);\n};\nconst errors = [];\nconst $report = typia.validate.report(errors);\nconst $is_uuid = typia.validate.is_uuid;\nconst $is_email = typia.validate.is_email;\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $vo0 = (input, _path, _exceptionable = true) =>\n[\n(\"string\" === typeof input.id &&\n($is_uuid(input.id) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id,\n}),\n(\"string\" === typeof input.email &&\n($is_email(input.email) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string (@format email)\",\nvalue: input.email,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string\",\nvalue: input.email,\n}),\n(\"number\" === typeof input.age &&\n(parseInt(input.age) === input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@type int)\",\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age,\n})) &&\n(100 >= input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age,\n}),\n].every((flag) => flag);\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$vo0(input, _path + \"\", true)) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\nconst success = 0 === errors.length;\nreturn {\nsuccess,\nerrors,\ndata: success ? input : undefined,\n};\n})({\nid: 5, // wrong, must be string (uuid)\nage: 20.75, // wrong, not integer\nemail: \"samchon.github@gmail.com\",\n});\nif (!res.success) console.log(res.errors);","validateequals-function#validateEquals() function":"export function validateEquals<T>(input: T): IValidation<T>;\nexport function validateEquals<T>(input: unknown): IValidation<T>;\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nMore strict validatae function prohibiting superfluous properties.typia.validate<T> function detects every type errors of input value, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, so that archive them into IValidation.IFailure.errors array, use typia.validateEquals<T>() function instead.In the below example case, as id property is different with its type definition and sex property is not defined in the IMember type, such errors would be archived into the IValidation.IFailure.errors array:\nerrors[0]\npath: input.id\nexpected: string (@format uuid)\nvalue: something\n\n\nerrors[1]\npath: input.sex\nexpected: undefined\nvalue: 1\n\n\n\n\n\n\nimport typia from \"typia\";\n\nconst res: typia.IValidation<IMember> = typia.validateEquals<IMember>({\nage: 30,\nemail: \"samchon.github@gmail.com\",\nid: \"something\", // wrong, must be string (uuid)\nsex: 1, // extra property\n});\n\nif (!res.success) console.log(res.errors);\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nconst res = ((input) => {\nconst __is = (input, _exceptionable = true) => {\nconst $is_uuid = typia.validateEquals.is_uuid;\nconst $is_email = typia.validateEquals.is_email;\nconst $io0 = (input, _exceptionable = true) =>\n\"string\" === typeof input.id &&\n$is_uuid(input.id) &&\n\"string\" === typeof input.email &&\n$is_email(input.email) &&\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age && 100 >= input.age &&\n(3 === Object.keys(input).length ||\nObject.keys(input).every((key) => {\nif ([\"id\", \"email\", \"age\"].some((prop) => key === prop))\nreturn true;\nconst value = input[key];\nif (undefined === value) return true;\nreturn false;\n}));\nreturn \"object\" === typeof input && null !== input && $io0(input, true);\n};\nconst errors = [];\nconst $report = typia.validateEquals.report(errors);\nconst $is_uuid = typia.validateEquals.is_uuid;\nconst $is_email = typia.validateEquals.is_email;\nconst $join = typia.validateEquals.join;\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $vo0 = (input, _path, _exceptionable = true) =>\n[\n(\"string\" === typeof input.id &&\n($is_uuid(input.id) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id,\n}),\n(\"string\" === typeof input.email &&\n($is_email(input.email) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string (@format email)\",\nvalue: input.email,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string\",\nvalue: input.email,\n}),\n(\"number\" === typeof input.age &&\n(parseInt(input.age) === input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@type int)\",\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age,\n})) &&\n(100 >= input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age,\n}),\n3 === Object.keys(input).length ||\nfalse === _exceptionable ||\nObject.keys(input)\n.map((key) => {\nif (\n[\"id\", \"email\", \"age\"].some(\n(prop) => key === prop,\n)\n)\nreturn true;\nconst value = input[key];\nif (undefined === value) return true;\nreturn $report(_exceptionable, {\npath: _path + $join(key),\nexpected: \"undefined\",\nvalue: value,\n});\n})\n.every((flag) => flag),\n].every((flag) => flag);\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$vo0(input, _path + \"\", true)) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\nconst success = 0 === errors.length;\nreturn {\nsuccess,\nerrors,\ndata: success ? input : undefined,\n};\n})({\nage: 30,\nemail: \"samchon.github@gmail.com\",\nid: \"something\", // wrong, must be string (uuid)\nsex: 1, // extra property\n});\n\nif (!res.success) console.log(res.errors);","reusable-functions#Reusable functions":"export function createValidate<T> = (input: unknown) => IValidation<T>;\nexport function createValidateEquals<T> = (input: unknown) => IValidation<T>;\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nReusable typia.validate<T>() function generators.If you repeat to call typia.validate<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createValidate<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia from \"typia\";\n\nexport const validateMember = typia.createValidate<IMember>();\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @type int\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\n\nexport const validateMember = (input) => {\nconst __is = (input) => {\nconst $is_uuid = typia.createValidate.is_uuid;\nconst $is_email = typia.createValidate.is_email;\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n$is_uuid(input.id) &&\n\"string\" === typeof input.email &&\n$is_email(input.email) &&\n\"number\" === typeof input.age &&\nparseInt(input.age) === input.age &&\n19 < input.age && 100 >= input.age\n);\n};\nconst errors = [];\nconst $report = typia.createValidate.report(errors);\nconst $is_uuid = typia.createValidate.is_uuid;\nconst $is_email = typia.createValidate.is_email;\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $vo0 = (input, _path, _exceptionable = true) =>\n[\n(\"string\" === typeof input.id &&\n($is_uuid(input.id) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id,\n}),\n(\"string\" === typeof input.email &&\n($is_email(input.email) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string (@format email)\",\nvalue: input.email,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: \"string\",\nvalue: input.email,\n}),\n(\"number\" === typeof input.age &&\n(parseInt(input.age) === input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@type int)\",\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age,\n})) &&\n(100 >= input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age,\n}),\n].every((flag) => flag);\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$vo0(input, _path + \"\", true)) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\nconst success = 0 === errors.length;\nreturn {\nsuccess,\nerrors,\ndata: success ? input : undefined,\n};\n};","discriminated-union#Discriminated Union":"export function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\nexport function createValidate<T>(): (input: unknown) => IValidation<T>;\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nSpecify type through if condition.typia.IValidation<T> is an union type of typia.IValidation.ISuccess<T> and typia.IValidation.IFailure. Also, they have a common property success of boolean type, but different literal values. In that case, if you write a if condition about the success property, you can specify the union type like below.In TypeScript, such union type specification through common property (of different literal value() is called \"Discriminated Union\". Therefore, when using typia.validate<T>() function, let's utilize such discriminated union specification for convenience.\nimport typia from \"typia\";\n\nconst something: unknown = ...;\nconst result: typia.IValidation<string> = typia.validate<string>(something);\n\nif (results.success) {\n// become typia.IValidation.Success<string> type\nresult.data; // accessible\n}\nelse {\n// become typia.IValidation.Failure type\nresult.errors; //accessible\n}","performance#Performance":"Super-fast and super-safe.Comparing typia.validate<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on Intel i5-1135g7, Surface Pro 8\n\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\n\nC.V. means class-validator"}}}