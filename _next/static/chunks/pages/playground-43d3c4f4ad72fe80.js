(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[311],{3746:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/playground",function(){return n(2778)}])},2778:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return v}});var a,r,o,i=n(5893),s=n(6961),p=n(7294),l=n(5884),c=n(5423),m=n.n(c),d=n(8781),u=n.n(d);let f=[["file:///node_modules/typia/package.json",'{\n  "name": "typia",\n  "version": "4.1.1",\n  "description": "Superfast runtime validators with only one line",\n  "main": "lib/index.js",\n  "typings": "lib/index.d.ts",\n  "bin": {\n    "typia": "./lib/executable/typia.js"\n  },\n  "scripts": {\n    "benchmark": "npm run build:benchmark && node measure/benchmark",\n    "benchmark:generate": "ts-node benchmark/generate && npm run build:benchmark",\n    "test:generate": "npx ts-node src/executable/typia generate --input test/features --output test/generated/output --project test/tsconfig.json",\n    "test:template": "npx tsc && ts-node -P build/tsconfig.json build/test.ts",\n    "----------------------------------------------": "",\n    "build": "rimraf lib && tsc --removeComments --declaration false && tsc --emitDeclarationOnly",\n    "build:test": "rimraf bin && tsc -p test/tsconfig.json",\n    "build:benchmark": "rimraf measure && tsc -p benchmark/tsconfig.json",\n    "build:test:prettier": "npm run build:test && prettier --write ./bin/**/*.js",\n    "dev": "rimraf lib && tsc --watch",\n    "dev:test": "rimraf bin && tsc -p test/tsconfig.json --watch",\n    "eslint": "eslint ./**/*.ts",\n    "eslint:fix": "eslint ./**/*.ts --fix",\n    "prettier": "prettier  --write ./**/*.ts",\n    "-----------------------------------------------": "",\n    "issue": "node test/issue",\n    "issue:generate": "ts-node src/executable/typia generate --input test/issues/generate/input --output test/issues/generate --project test/tsconfig.json",\n    "test": "node bin/test",\n    "test:manual": "node test/manual",\n    "------------------------------------------------": "",\n    "package:latest": "ts-node build/publish.ts latest",\n    "package:next": "ts-node build/publish.ts next",\n    "package:patch": "ts-node build/publish.ts patch",\n    "package:deprecate": "npm deprecate typescript-json "Renamed to typia"",\n    "prepare": "ts-patch install"\n  },\n  "repository": {\n    "type": "git",\n    "url": "https://github.com/samchon/typia"\n  },\n  "keywords": [\n    "fast",\n    "json",\n    "stringify",\n    "typescript",\n    "transform",\n    "ajv",\n    "io-ts",\n    "schema",\n    "jsonschema",\n    "generator",\n    "assert",\n    "clone",\n    "is",\n    "validate",\n    "equal",\n    "runtime",\n    "type",\n    "typebox",\n    "checker",\n    "validator",\n    "safe",\n    "parse",\n    "prune",\n    "random"\n  ],\n  "author": "Jeongho Nam",\n  "license": "MIT",\n  "bugs": {\n    "url": "https://github.com/samchon/typia/issues"\n  },\n  "homepage": "https://typia.io",\n  "dependencies": {\n    "commander": "^10.0.0",\n    "comment-json": "^4.2.3",\n    "inquirer": "^8.2.5",\n    "randexp": "^0.5.3",\n    "raw-loader": "^4.0.2"\n  },\n  "peerDependencies": {\n    "typescript": ">= 4.7.4"\n  },\n  "devDependencies": {\n    "@fastify/type-provider-typebox": "^3.0.0",\n    "@trivago/prettier-plugin-sort-imports": "^3.3.0",\n    "@typegoose/typegoose": "^10.1.1",\n    "@types/autocannon": "^7.9.0",\n    "@types/benchmark": "^2.1.2",\n    "@types/cli": "^0.11.20",\n    "@types/commander": "^2.12.2",\n    "@types/d3": "^7.4.0",\n    "@types/express": "^4.17.14",\n    "@types/inquirer": "^8.2.5",\n    "@types/nested-error-stacks": "^2.1.0",\n    "@types/node": "^18.15.12",\n    "@types/physical-cpu-count": "^2.0.0",\n    "@types/uuid": "^8.3.4",\n    "@typescript-eslint/eslint-plugin": "^5.59.11",\n    "@typescript-eslint/parser": "^5.59.11",\n    "ajv": "^8.12.0",\n    "autocannon": "^7.10.0",\n    "benchmark": "^2.1.4",\n    "chalk": "^4.1.0",\n    "class-transformer": "^0.5.1",\n    "class-validator": "^0.14.0",\n    "cli": "^1.0.1",\n    "d3": "^5.16.0",\n    "eslint-plugin-deprecation": "^1.4.1",\n    "express": "^4.18.2",\n    "fast-json-stringify": "^5.4.0",\n    "fastify": "^4.9.2",\n    "io-ts": "^2.2.19",\n    "jsdom": "^21.1.1",\n    "physical-cpu-count": "^2.0.0",\n    "prettier": "^2.6.2",\n    "reflect-metadata": "^0.1.13",\n    "rimraf": "^3.0.2",\n    "sloc": "^0.2.1",\n    "source-map-support": "^0.5.21",\n    "suppress-warnings": "^1.0.2",\n    "tgrid": "^0.8.7",\n    "ts-node": "^10.9.1",\n    "ts-patch": "^3.0.0",\n    "tstl": "^2.5.13",\n    "typescript": "^5.1.3",\n    "typescript-transform-paths": "^3.4.6",\n    "uuid": "^8.3.2",\n    "zod": "^3.19.1"\n  },\n  "stackblitzs": {\n    "startCommand": "npm run prepare && npm run build && npm run build:test && npm run test"\n  },\n  "files": [\n    "LICENSE",\n    "README.md",\n    "package.json",\n    "lib",\n    "src"\n  ]\n}'],["file:///node_modules/typia/index.d.ts",'export * from "./lib;\nimport * as typia from "./lib";\nexport default typia;'],["file:///node_modules/typia/lib/CustomValidatorMap.d.ts",'import { Customizable } from "./typings/Customizable";\n/**\n * Map of custom validators.\n *\n * Map of custom validator functions, storing tag name and type of target value\n * as key, and custom validator function as value.\n *\n * When you want to add a custom validation logic utilizing comment tags, you\n * can insert a custom validator function with specific tag name and type of\n * the target value like below.\n *\n * ```ts\n * typia.customValidators.insert("powerOf")("number")(\n *     (text: string) => {\n *         const denominator: number = Math.log(Number(text));\n *         return (value: number) => {\n *             value = Math.log(value) / denominator;\n *             return value === Math.floor(value);\n *         };\n *     }\n * );\n * typia.customValidators.insert("dollar")("string")(\n *     () => (value: string) => value.startsWith("$"),\n * );\n *\n * interface TagCustom {\n *    /**\n *     * @powerOf 10\n *     */\n *    powerOf: number;\n *\n *    /**\n *     * @dollar\n *     */\n *    dollar: string;\n * }\n * ```\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport interface CustomValidatorMap {\n    /**\n     * Get number of stored tags.\n     *\n     * @return Number of stored tags\n     */\n    size(): number;\n    /**\n     * Get number of stored types of the specified tag name.\n     *\n     * In other words, number of stored custom validator functions of\n     * the specified tag name.\n     *\n     * @param name Tag name\n     * @return Number of stored types function\n     */\n    size(name: string): number;\n    /**\n     * Test whether custom validator function exists or not.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @returns Whether exists or not\n     */\n    has: (name: string) => (type: keyof Customizable) => boolean;\n    /**\n     * Get custom validator function.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @returns Custom validator function or undefined value\n     */\n    get(name: string): <Type extends keyof Customizable>(type: Type) => CustomValidatorMap.Closure<Type> | undefined;\n    /**\n     * Insert a new custom validator function.\n     *\n     * You can add a custom validation logic utilizing comment tags,\n     * by inserting a function which returns a boolean value, with specific\n     * tag name and type of the target value.\n     *\n     * However, if you try to insert a duplicated tag name and type, the\n     * closure function would not be enrolled and `false` value would be\n     * returned.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @param closure Custom validator function\n     * @returns Whether succeeded to insert or not\n     */\n    insert(name: string): <Type extends keyof Customizable>(type: Type) => (closure: CustomValidatorMap.Closure<Type>) => boolean;\n    /**\n     * Erase custom validator function.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @returns Whether succeeded to erase or not\n     */\n    erase(name: string): (type: keyof Customizable) => boolean;\n}\nexport declare namespace CustomValidatorMap {\n    /**\n     * Type of closure function of custom validation.\n     *\n     * @template Type Type of the target value\n     * @param text Text of the tag. For example, if the tag is `@powerOf 10`, `text` is 10.\n     * @param value Value to validate\n     * @returns Whether the value is valid or not\n     */\n    type Closure<Type extends keyof Customizable> = (text: string) => (value: Customizable[Type]) => boolean;\n}\n'],["file:///node_modules/typia/lib/executable/setup/ArgumentParser.d.ts",'import commander from "commander";\nimport inquirer from "inquirer";\nimport { PackageManager } from "./PackageManager";\nexport declare namespace ArgumentParser {\n    type Inquiry<T> = (pack: PackageManager, command: commander.Command, prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule, action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>) => Promise<T>;\n    const parse: (pack: PackageManager) => <T>(inquiry: (pack: PackageManager, command: commander.Command, prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule, action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>) => Promise<T>) => Promise<T>;\n}\n'],["file:///node_modules/typia/lib/executable/setup/CommandExecutor.d.ts","export declare namespace CommandExecutor {\n    const run: (str: string) => void;\n}\n"],["file:///node_modules/typia/lib/executable/setup/FileRetriever.d.ts","export declare namespace FileRetriever {\n    const directory: (name: string) => (dir: string, depth?: number) => string | null;\n    const file: (name: string) => (directory: string, depth?: number) => string | null;\n}\n"],["file:///node_modules/typia/lib/executable/setup/PackageManager.d.ts","export declare class PackageManager {\n    readonly directory: string;\n    data: Package.Data;\n    manager: string;\n    get file(): string;\n    static mount(): Promise<PackageManager>;\n    save(modifier: (data: Package.Data) => void): Promise<void>;\n    install(props: {\n        dev: boolean;\n        modulo: string;\n        version: string;\n    }): boolean;\n    private constructor();\n    private static load;\n}\nexport declare namespace Package {\n    interface Data {\n        scripts?: Record<string, string>;\n        dependencies?: Record<string, string>;\n        devDependencies?: Record<string, string>;\n    }\n}\n"],["file:///node_modules/typia/lib/executable/setup/PluginConfigurator.d.ts",'import { TypiaSetupWizard } from "../TypiaSetupWizard";\nexport declare namespace PluginConfigurator {\n    function configure(args: TypiaSetupWizard.IArguments): Promise<void>;\n}\n'],["file:///node_modules/typia/lib/executable/typia.d.ts",'#!/usr/bin/env node\ndeclare const USAGE = "Wrong command has been detected. Use like below:\n\n  npx typia setup \\\n    --manager (npm|pnpm|yarn) \\\n    --project {tsconfig.json file path}\n\n    - npx typia setup\n    - npx typia setup --manager pnpm\n    - npx typia setup --project tsconfig.test.json\n\n  npx typia generate \n    --input {directory} \\\n    --output {directory}\n\n    --npx typia generate --input src/templates --output src/functinoal\n";\ndeclare const halt: (desc: string) => never;\ndeclare const main: () => Promise<void>;\n'],["file:///node_modules/typia/lib/executable/TypiaGenerateWizard.d.ts","export declare namespace TypiaGenerateWizard {\n    function generate(): Promise<void>;\n    interface IArguments {\n        input: string;\n        output: string;\n        project: string;\n    }\n}\n"],["file:///node_modules/typia/lib/executable/TypiaSetupWizard.d.ts",'export declare namespace TypiaSetupWizard {\n    interface IArguments {\n        manager: "npm" | "pnpm" | "yarn";\n        project: string | null;\n    }\n    function setup(): Promise<void>;\n}\n'],["file:///node_modules/typia/lib/factories/CommentFactory.d.ts",'import ts from "typescript";\nexport declare namespace CommentFactory {\n    const description: (symbol: ts.Symbol) => string | undefined;\n    const merge: (comments: ts.SymbolDisplayPart[]) => string;\n}\n'],["file:///node_modules/typia/lib/factories/ExpressionFactory.d.ts",'import ts from "typescript";\nexport declare namespace ExpressionFactory {\n    const isRequired: (input: ts.Expression) => ts.Expression;\n    const isArray: (input: ts.Expression) => ts.Expression;\n    const isObject: (options: {\n        checkNull: boolean;\n        checkArray: boolean;\n    }) => (input: ts.Expression) => ts.Expression;\n    const isInstanceOf: (type: string) => (input: ts.Expression) => ts.Expression;\n    const coalesce: (x: ts.Expression) => (y: ts.Expression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/factories/IdentifierFactory.d.ts",'import ts from "typescript";\nexport declare namespace IdentifierFactory {\n    const identifier: (name: string) => ts.Identifier | ts.StringLiteral;\n    const access: (target: ts.Expression) => (property: string) => ts.ElementAccessExpression | ts.PropertyAccessExpression;\n    const postfix: (str: string) => string;\n    const parameter: (name: string | ts.BindingName, type?: ts.TypeNode, init?: ts.Expression | ts.PunctuationToken<ts.SyntaxKind.QuestionToken>) => any;\n}\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emend_metadata_atomics.d.ts",'import { Metadata } from "../../../metadata/Metadata";\nexport declare const emend_metadata_atomics: (meta: Metadata) => void;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emplace_metadata_array.d.ts",'import ts from "typescript";\nimport { MetadataArray } from "../../../metadata/MetadataArray";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const emplace_metadata_array: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (type: ts.Type, nullable: boolean) => MetadataArray;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emplace_metadata_definition.d.ts",'import ts from "typescript";\nimport { MetadataAlias } from "../../../metadata/MetadataAlias";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const emplace_metadata_definition: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (type: ts.Type, nullable: boolean) => MetadataAlias;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emplace_metadata_object.d.ts",'import ts from "typescript";\nimport { MetadataObject } from "../../../metadata/MetadataObject";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const emplace_metadata_object: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (parent: ts.Type, nullable: boolean) => MetadataObject;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emplace_metadata_tuple.d.ts",'import ts from "typescript";\nimport { MetadataTuple } from "../../../metadata/MetadataTuple";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const emplace_metadata_tuple: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (type: ts.TupleType, nullable: boolean) => MetadataTuple;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/explore_metadata.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const explore_metadata: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (type: ts.Type | null, parentResolved: boolean, aliased?: boolean) => Metadata;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, resolved: boolean, aliased: boolean) => void;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_alias.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_alias: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_array.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_array: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_atomic.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nexport declare const iterate_metadata_atomic: (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_coalesce.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nexport declare const iterate_metadata_coalesce: (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_collection.d.ts",'import { MetadataCollection } from "../../MetadataCollection";\nexport declare const iterate_metadata_collection: (collection: MetadataCollection) => void;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_constant.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_constant: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_intersection.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_intersection: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, resolved: boolean, aliased: boolean) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_map.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_map: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_native.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nexport declare const iterate_metadata_native: (checker: ts.TypeChecker) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_object.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_object: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, parentResolved: boolean, ensure?: boolean) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_resolve.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_resolve: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, resolved: boolean, aliased: boolean) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_set.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_set: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_sort.d.ts",'import { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nexport declare const iterate_metadata_sort: (collection: MetadataCollection) => (meta: Metadata) => void;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_template.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_template: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_tuple.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_tuple: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.TupleType) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_union.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_union: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, parentResolved: boolean) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/MetadataHelper.d.ts",'import { Metadata } from "../../../metadata/Metadata";\nexport declare namespace MetadataHelper {\n    const literal_to_metadata: (key: string) => Metadata;\n}\n'],["file:///node_modules/typia/lib/factories/LiteralFactory.d.ts",'import ts from "typescript";\nexport declare namespace LiteralFactory {\n    const generate: (input: any) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/factories/MetadataCollection.d.ts",'import ts from "typescript";\nimport { IMetadataCollection } from "../metadata/IMetadataCollection";\nimport { Metadata } from "../metadata/Metadata";\nimport { MetadataAlias } from "../metadata/MetadataAlias";\nimport { MetadataArray } from "../metadata/MetadataArray";\nimport { MetadataObject } from "../metadata/MetadataObject";\nimport { MetadataTuple } from "../metadata/MetadataTuple";\nexport declare class MetadataCollection {\n    private readonly options?;\n    private readonly objects_;\n    private readonly object_unions_;\n    private readonly aliases_;\n    private readonly arrays_;\n    private readonly tuples_;\n    private readonly names_;\n    private object_index_;\n    private recursive_array_index_;\n    private recursive_tuple_index_;\n    constructor(options?: Partial<MetadataCollection.IOptions> | undefined);\n    aliases(): MetadataAlias[];\n    objects(): MetadataObject[];\n    unions(): MetadataObject[][];\n    arrays(): MetadataArray[];\n    tuples(): MetadataTuple[];\n    private getName;\n    emplace(checker: ts.TypeChecker, type: ts.Type): [MetadataObject, boolean];\n    emplaceAlias(checker: ts.TypeChecker, type: ts.Type, symbol: ts.Symbol): [MetadataAlias, boolean, (meta: Metadata) => void];\n    emplaceArray(checker: ts.TypeChecker, type: ts.Type): [MetadataArray, boolean, (meta: Metadata) => void];\n    emplaceTuple(checker: ts.TypeChecker, type: ts.TupleType): [MetadataTuple, boolean, (elements: Metadata[]) => void];\n    setTupleRecursive(tuple: MetadataTuple, recursive: boolean): void;\n    toJSON(): IMetadataCollection;\n}\nexport declare namespace MetadataCollection {\n    interface IOptions {\n        replace?(str: string): string;\n    }\n    const replace: (str: string) => string;\n    const escape: (str: string) => string;\n}\n'],["file:///node_modules/typia/lib/factories/MetadataFactory.d.ts",'import ts from "typescript";\nimport { Metadata } from "../metadata/Metadata";\nimport { MetadataCollection } from "./MetadataCollection";\nexport declare namespace MetadataFactory {\n    interface IOptions {\n        resolve: boolean;\n        constant: boolean;\n        absorb: boolean;\n        validate?: (meta: Metadata) => void;\n    }\n    const analyze: (checker: ts.TypeChecker) => (options: IOptions) => (collection: MetadataCollection) => (type: ts.Type | null) => Metadata;\n}\n'],["file:///node_modules/typia/lib/factories/MetadataTagFactory.d.ts",'import ts from "typescript";\nimport { IMetadataTag } from "../metadata/IMetadataTag";\nimport { Metadata } from "../metadata/Metadata";\nexport declare namespace MetadataTagFactory {\n    const generate: (metadata: Metadata) => (tagList: ts.JSDocTagInfo[]) => (identifier: () => string) => IMetadataTag[];\n}\n'],["file:///node_modules/typia/lib/factories/StatementFactory.d.ts",'import ts from "typescript";\nexport declare namespace StatementFactory {\n    const constant: (name: string, initializer?: ts.Expression) => ts.VariableStatement;\n    const transpile: (script: string) => ts.ExpressionStatement;\n}\n'],["file:///node_modules/typia/lib/factories/TemplateFactory.d.ts",'import ts from "typescript";\nexport declare namespace TemplateFactory {\n    const generate: (expressions: ts.Expression[]) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/factories/TypeFactory.d.ts",'import ts from "typescript";\nexport declare namespace TypeFactory {\n    const resolve: (checker: ts.TypeChecker) => (type: ts.Type) => ts.Type | null;\n    const isFunction: (type: ts.Type) => boolean;\n    const getReturnType: (checker: ts.TypeChecker) => (type: ts.Type) => (name: string) => ts.Type | null;\n    const getFullName: (checker: ts.TypeChecker) => (type: ts.Type, symbol?: ts.Symbol) => string;\n    const keyword: (type: "void" | "any" | "unknown" | "boolean" | "number" | "bigint" | "string") => ts.KeywordTypeNode<ts.SyntaxKind.VoidKeyword | ts.SyntaxKind.AnyKeyword | ts.SyntaxKind.BooleanKeyword | ts.SyntaxKind.NumberKeyword | ts.SyntaxKind.StringKeyword | ts.SyntaxKind.UnknownKeyword | ts.SyntaxKind.BigIntKeyword>;\n}\n'],["file:///node_modules/typia/lib/factories/ValueFactory.d.ts",'import ts from "typescript";\nexport declare namespace ValueFactory {\n    const NULL: () => ts.NullLiteral;\n    const UNDEFINED: () => ts.Identifier;\n    const BOOLEAN: (value: boolean) => ts.FalseLiteral | ts.TrueLiteral;\n    const INPUT: (str?: string) => ts.Identifier;\n    const TYPEOF: (input: ts.Expression) => ts.TypeOfExpression;\n}\n'],["file:///node_modules/typia/lib/functional/$any.d.ts","export declare const $any: (val: any) => any;\n"],["file:///node_modules/typia/lib/functional/$dictionary.d.ts",'import { Customizable } from "../typings/Customizable";\nexport declare const $dictionary: Map<string, Map<keyof Customizable, (tagText: string) => (value: any) => boolean>>;\n'],["file:///node_modules/typia/lib/functional/$every.d.ts",'import { TypeGuardError } from "../TypeGuardError";\nexport declare const $every: <T>(array: T[], pred: (value: T, i: number) => null | Omit<TypeGuardError.IProps, "method">) => null | Omit<TypeGuardError.IProps, "method">;\n'],["file:///node_modules/typia/lib/functional/$guard.d.ts","export {};\n"],["file:///node_modules/typia/lib/functional/$is_between.d.ts","export declare const $is_between: (value: number, minimum: number, maximum: number) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_custom.d.ts",'import { Customizable } from "../typings/Customizable";\nexport declare const $is_custom: <Type extends keyof Customizable>(name: string, type: Type, text: string, value: Customizable[Type]) => boolean;\n'],["file:///node_modules/typia/lib/functional/$is_date.d.ts","export declare const $is_date: (value: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_datetime.d.ts","export declare const $is_datetime: (value: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_email.d.ts","export declare const $is_email: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_ipv4.d.ts","export declare const $is_ipv4: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_ipv6.d.ts","export declare const $is_ipv6: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_url.d.ts","export declare const $is_url: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_uuid.d.ts","export declare const $is_uuid: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$join.d.ts","export declare const $join: (str: string) => string;\n"],["file:///node_modules/typia/lib/functional/$number.d.ts","export declare const $number: (value: number) => number;\n"],["file:///node_modules/typia/lib/functional/$report.d.ts",'import { IValidation } from "../IValidation";\nexport declare const $report: (array: IValidation.IError[]) => (exceptable: boolean, error: IValidation.IError) => false;\n'],["file:///node_modules/typia/lib/functional/$rest.d.ts","export declare const $rest: (str: string) => string;\n"],["file:///node_modules/typia/lib/functional/$string.d.ts","export {};\n"],["file:///node_modules/typia/lib/functional/$tail.d.ts","export {};\n"],["file:///node_modules/typia/lib/functional/Namespace.d.ts","export {};\n"],["file:///node_modules/typia/lib/index.d.ts",'import * as typia from "./module";\nexport default typia;\nexport * from "./module";\n'],["file:///node_modules/typia/lib/IRandomGenerator.d.ts",'import { Customizable } from "./typings/Customizable";\nexport interface IRandomGenerator {\n    boolean(): boolean;\n    integer(minimum?: number, maximum?: number): number;\n    number(minimum?: number, maximum?: number): number;\n    bigint(minimum?: bigint, maximum?: bigint): bigint;\n    string(length?: number): string;\n    array<T>(closure: (index: number) => T, count?: number): T[];\n    length(): number;\n    uuid(): string;\n    email(): string;\n    url(): string;\n    ipv4(): string;\n    ipv6(): string;\n    pattern(regex: RegExp): string;\n    date(minimum?: number, maximum?: number): string;\n    datetime(minimum?: number, maximum?: number): string;\n    customs?: IRandomGenerator.CustomMap;\n}\nexport declare namespace IRandomGenerator {\n    type CustomMap = {\n        [Type in keyof Customizable]?: (tags: ICommentTag[]) => Customizable[Type] | undefined;\n    };\n    interface ICommentTag {\n        name: string;\n        value?: string;\n    }\n}\n'],["file:///node_modules/typia/lib/IValidation.d.ts","export type IValidation<T = unknown> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport declare namespace IValidation {\n    interface ISuccess<T = unknown> {\n        success: true;\n        data: T;\n        errors: [];\n    }\n    interface IFailure {\n        success: false;\n        errors: IError[];\n    }\n    interface IError {\n        path: string;\n        expected: string;\n        value: any;\n    }\n}\n"],["file:///node_modules/typia/lib/metadata/ICommentTag.d.ts","export interface ICommentTag {\n    name: string;\n    value?: string;\n}\n"],["file:///node_modules/typia/lib/metadata/IJsDocTagInfo.d.ts","export interface IJsDocTagInfo {\n    name: string;\n    text?: IJsDocTagInfo.IText[];\n}\nexport declare namespace IJsDocTagInfo {\n    interface IText {\n        text: string;\n        kind: string;\n    }\n}\n"],["file:///node_modules/typia/lib/metadata/IMetadata.d.ts",'import { Atomic } from "../typings/Atomic";\nimport { IMetadataConstant } from "./IMetadataConstant";\nimport { IMetadataEntry } from "./IMetadataEntry";\nimport { IMetadataResolved } from "./IMetadataResolved";\nexport interface IMetadata {\n    any: boolean;\n    required: boolean;\n    optional: boolean;\n    nullable: boolean;\n    functional: boolean;\n    atomics: Atomic.Literal[];\n    constants: IMetadataConstant[];\n    templates: IMetadata[][];\n    resolved: IMetadataResolved | null;\n    rest: IMetadata | null;\n    arrays: string[];\n    tuples: string[];\n    objects: string[];\n    aliases: string[];\n    natives: string[];\n    sets: IMetadata[];\n    maps: IMetadataEntry[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataAlias.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadata } from "./IMetadata";\nexport interface IMetadataAlias {\n    name: string;\n    value: IMetadata;\n    description: string | null;\n    jsDocTags: IJsDocTagInfo[];\n    recursive: boolean;\n    nullables: boolean[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataApplication.d.ts",'import { IMetadata } from "./IMetadata";\nimport { IMetadataCollection } from "./IMetadataCollection";\nexport interface IMetadataApplication {\n    metadatas: IMetadata[];\n    collection: IMetadataCollection;\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataArray.d.ts",'import { IMetadata } from "./IMetadata";\nexport interface IMetadataArray {\n    name: string;\n    value: IMetadata;\n    nullables: boolean[];\n    recursive: boolean;\n    index: number | null;\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataCollection.d.ts",'import { IMetadataAlias } from "./IMetadataAlias";\nimport { IMetadataArray } from "./IMetadataArray";\nimport { IMetadataObject } from "./IMetadataObject";\nimport { IMetadataTuple } from "./IMetadataTuple";\nexport interface IMetadataCollection {\n    objects: IMetadataObject[];\n    aliases: IMetadataAlias[];\n    arrays: IMetadataArray[];\n    tuples: IMetadataTuple[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataConstant.d.ts",'import { Atomic } from "../typings/Atomic";\nexport type IMetadataConstant = IMetadataConstant.IBase<"boolean", boolean> | IMetadataConstant.IBase<"number", number> | IMetadataConstant.IBase<"string", string> | IMetadataConstant.IBase<"bigint", bigint>;\nexport declare namespace IMetadataConstant {\n    interface IBase<Type extends Atomic.Literal, Value extends Atomic.Type> {\n        type: Type;\n        values: Value[];\n    }\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataDictionary.d.ts","export {};\n"],["file:///node_modules/typia/lib/metadata/IMetadataEntry.d.ts",'import { IMetadata } from "./IMetadata";\nexport interface IMetadataEntry {\n    key: IMetadata;\n    value: IMetadata;\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataObject.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadataProperty } from "./IMetadataProperty";\nexport interface IMetadataObject {\n    name: string;\n    properties: IMetadataProperty[];\n    description?: string;\n    jsDocTags: IJsDocTagInfo[];\n    index: number;\n    recursive: boolean;\n    nullables: boolean[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataProperty.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadata } from "./IMetadata";\nimport { IMetadataTag } from "./IMetadataTag";\nexport interface IMetadataProperty {\n    key: IMetadata;\n    value: IMetadata;\n    description: string | null;\n    tags: IMetadataTag[];\n    jsDocTags: IJsDocTagInfo[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataResolved.d.ts",'import { IMetadata } from "./IMetadata";\nexport interface IMetadataResolved {\n    original: IMetadata;\n    returns: IMetadata;\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataTag.d.ts",'export type IMetadataTag = IMetadataTag.IType | IMetadataTag.IMinimum | IMetadataTag.IMaximum | IMetadataTag.IExclusiveMinimum | IMetadataTag.IExclusiveMaximum | IMetadataTag.IMultipleOf | IMetadataTag.IStep | IMetadataTag.IFormat | IMetadataTag.IPattern | IMetadataTag.ILength | IMetadataTag.IMinLength | IMetadataTag.IMaxLength | IMetadataTag.IItems | IMetadataTag.IMinItems | IMetadataTag.IMaxItems;\nexport declare namespace IMetadataTag {\n    interface IType {\n        kind: "type";\n        value: "int" | "uint";\n    }\n    interface IMinimum {\n        kind: "minimum";\n        value: number;\n    }\n    interface IMaximum {\n        kind: "maximum";\n        value: number;\n    }\n    interface IExclusiveMinimum {\n        kind: "exclusiveMinimum";\n        value: number;\n    }\n    interface IExclusiveMaximum {\n        kind: "exclusiveMaximum";\n        value: number;\n    }\n    interface IMultipleOf {\n        kind: "multipleOf";\n        value: number;\n    }\n    interface IStep {\n        kind: "step";\n        value: number;\n    }\n    interface IFormat {\n        kind: "format";\n        value: "uuid" | "email" | "url" | "ipv4" | "ipv6" | "date" | "datetime";\n    }\n    interface IPattern {\n        kind: "pattern";\n        value: string;\n    }\n    interface ILength {\n        kind: "length";\n        value: number;\n    }\n    interface IMinLength {\n        kind: "minLength";\n        value: number;\n    }\n    interface IMaxLength {\n        kind: "maxLength";\n        value: number;\n    }\n    interface IItems {\n        kind: "items";\n        value: number;\n    }\n    interface IMinItems {\n        kind: "minItems";\n        value: number;\n    }\n    interface IMaxItems {\n        kind: "maxItems";\n        value: number;\n    }\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataTuple.d.ts",'import { IMetadata } from "./IMetadata";\nexport interface IMetadataTuple {\n    name: string;\n    elements: IMetadata[];\n    index: number | null;\n    recursive: boolean;\n    nullables: boolean[];\n}\n'],["file:///node_modules/typia/lib/metadata/Metadata.d.ts",'import { Atomic } from "../typings/Atomic";\nimport { IMetadata } from "./IMetadata";\nimport { IMetadataCollection } from "./IMetadataCollection";\nimport { MetadataAlias } from "./MetadataAlias";\nimport { MetadataArray } from "./MetadataArray";\nimport { MetadataConstant } from "./MetadataConstant";\nimport { MetadataObject } from "./MetadataObject";\nimport { MetadataResolved } from "./MetadataResolved";\nimport { MetadataTuple } from "./MetadataTuple";\nexport declare class Metadata {\n    any: boolean;\n    required: boolean;\n    optional: boolean;\n    nullable: boolean;\n    functional: boolean;\n    resolved: MetadataResolved | null;\n    atomics: Atomic.Literal[];\n    constants: MetadataConstant[];\n    templates: Metadata[][];\n    rest: Metadata | null;\n    aliases: MetadataAlias[];\n    arrays: MetadataArray[];\n    tuples: MetadataTuple[];\n    objects: MetadataObject[];\n    natives: string[];\n    sets: Metadata[];\n    maps: Metadata.Entry[];\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadata;\n    static from(meta: IMetadata, collection: IMetadataCollection): Metadata;\n    getName(): string;\n    empty(): boolean;\n    size(): number;\n    bucket(): number;\n    isConstant(): boolean;\n}\nexport declare namespace Metadata {\n    const intersects: (x: Metadata, y: Metadata) => boolean;\n    const covers: (x: Metadata, y: Metadata, level?: number) => boolean;\n}\nexport declare namespace Metadata {\n    interface Entry {\n        key: Metadata;\n        value: Metadata;\n    }\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataAlias.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadataAlias } from "./IMetadataAlias";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataAlias {\n    readonly name: string;\n    readonly value: Metadata;\n    readonly description: string | null;\n    readonly jsDocTags: IJsDocTagInfo[];\n    readonly recursive: boolean;\n    readonly nullables: boolean[];\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadataAlias;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataArray.d.ts",'import { IMetadataArray } from "./IMetadataArray";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataArray {\n    readonly name: string;\n    readonly value: Metadata;\n    readonly nullables: boolean[];\n    readonly recursive: boolean;\n    readonly index: number | null;\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadataArray;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataConstant.d.ts",'import { IMetadataConstant } from "./IMetadataConstant";\nexport type MetadataConstant = IMetadataConstant;\n'],["file:///node_modules/typia/lib/metadata/MetadataObject.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadataObject } from "./IMetadataObject";\nimport { MetadataProperty } from "./MetadataProperty";\nexport declare class MetadataObject {\n    readonly name: string;\n    readonly properties: Array<MetadataProperty>;\n    readonly description: string | undefined;\n    readonly jsDocTags: IJsDocTagInfo[];\n    readonly index: number;\n    validated: boolean;\n    recursive: boolean;\n    nullables: boolean[];\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadataObject;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataProperty.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadataProperty } from "./IMetadataProperty";\nimport { IMetadataTag } from "./IMetadataTag";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataProperty {\n    readonly key: Metadata;\n    readonly value: Metadata;\n    readonly description: string | null;\n    readonly tags: IMetadataTag[];\n    readonly jsDocTags: IJsDocTagInfo[];\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadataProperty;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataResolved.d.ts",'import { IMetadataResolved } from "./IMetadataResolved";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataResolved {\n    readonly original: Metadata;\n    readonly returns: Metadata;\n    /**\n     * @hidden\n     */\n    private constructor();\n    getName(): string;\n    toJSON(): IMetadataResolved;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataTuple.d.ts",'import { ClassProperties } from "../typings/ClassProperties";\nimport { IMetadataTuple } from "./IMetadataTuple";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataTuple {\n    readonly name: string;\n    readonly elements: Metadata[];\n    readonly index: number | null;\n    readonly recursive: boolean;\n    readonly nullables: boolean[];\n    static create(props: ClassProperties<MetadataTuple>): MetadataTuple;\n    toJSON(): IMetadataTuple;\n}\n'],["file:///node_modules/typia/lib/module.d.ts",'import { IJsonApplication } from "./schemas/IJsonApplication";\nimport { Atomic } from "./typings/Atomic";\nimport { CustomValidatorMap } from "./CustomValidatorMap";\nimport { IRandomGenerator } from "./IRandomGenerator";\nimport { IValidation } from "./IValidation";\nimport { Primitive } from "./Primitive";\nexport * from "./schemas/IJsonApplication";\nexport * from "./schemas/IJsonComponents";\nexport * from "./schemas/IJsonSchema";\nexport * from "./IRandomGenerator";\nexport * from "./IValidation";\nexport * from "./Primitive";\nexport * from "./TypeGuardError";\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise you want to know all the errors, {@link validate} is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assert<T>(input: T): T;\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise, you want to know all the errors, {@link validate} is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assert<T>(input: unknown): T;\n/**\n * Asserts a value type.\n *\n * Duplicated function of {@link assert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function assertType<T>(input: T): T;\n/**\n * Asserts a value type.\n *\n * Duplicated function of {@link assert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function assertType<T>(input: unknown): T;\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it\'s following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function is<T>(input: T): input is T;\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it\'s following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function is<T>(input: unknown): input is T;\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validate<T>(input: T): IValidation<T>;\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validate<T>(input: unknown): IValidation<T>;\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertEquals<T>(input: T): T;\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertEquals<T>(input: unknown): T;\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it\'s equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there\'s not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function equals<T>(input: T): input is T;\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it\'s equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there\'s not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function equals<T>(input: unknown): input is T;\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateEquals<T>(input: T): IValidation<T>;\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateEquals<T>(input: unknown): IValidation<T>;\n/**\n * Custom validators.\n *\n * If you want to add a custom validation logic utilizing comment tags,\n * add a closure function with its tag and type name. Below example code\n * would helpful to understand how to use this instance.\n *\n * ```ts\n * typia.customValidators.insert("powerOf")("number")(\n *     (text: string) => {\n *         const denominator: number = Math.log(Number(text));\n *         return (value: number) => {\n *             value = Math.log(value) / denominator;\n *             return value === Math.floor(value);\n *         };\n *     }\n * );\n * typia.customValidators.insert("dollar")("string")(\n *     () => (value: string) => value.startsWith("$"),\n * );\n *\n * interface TagCustom {\n *    /**\n *     * @powerOf 10\n *     */\n *    powerOf: number;\n *\n *    /**\n *     * @dollar\n *     */\n *    dollar: string;\n * }\n * ```\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare const customValidators: CustomValidatorMap;\n/**\n * > You must configure the generic argument `T`.\n *\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and components.\n * Note that, all of the object types are stored in the {@link IJsonApplication.components}\n * property for the `$ref` referencing.\n *\n * Also, `typia.application()` has additional generic arguments, *Purpose*.\n * As JSON schema definitions used by `swagger` and `ajv` are different a little bit,\n * you should configure the *Purpose* appropriately.\n *\n * For an example, `ajv` has an extra property "$recursiveRef" that are not exists\n * in the standard JSON schema definition spec. Otherwise, `swagger` can\'t identify\n * the tuple definition.\n *\n * @template Types Tuple of target types\n * @template Purpose Purpose of the JSON schema`\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function application(): never;\n/**\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and components.\n * Note that, all of the object types are stored in the {@link IJsonApplication.components}\n * property for the `$ref` referencing.\n *\n * Also, `typia.application()` has additional generic arguments, *Purpose*.\n * As JSON schema definitions used by `swagger` and `ajv` are different a little bit,\n * you should configure the *Purpose* appropriately.\n *\n * For an example, `ajv` has an extra property "$recursiveRef" that are not exists\n * in the standard JSON schema definition spec. Otherwise, `swagger` can\'t identify\n * the tuple definition.\n *\n * @template Types Tuple of target types\n * @template Purpose Purpose of the JSON schema\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function application<Types extends unknown[], Purpose extends "ajv" | "swagger" = "swagger">(): IJsonApplication;\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.assertParse()` is a combination function of `JSON.parse()` and {@link assert}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * throws {@link TypeGuardError}. Otherwise, there\'s no problem on the parsed value,\n * the parsed value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertParse(input: string): never;\n/**\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.assertParse()` is a combination function of `JSON.parse()` and {@link assert}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * throws {@link TypeGuardError}. Otherwise, there\'s no problem on the parsed value,\n * the parsed value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertParse<T>(input: string): Primitive<T>;\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there\'s no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isParse(input: string): never;\n/**\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there\'s no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isParse<T>(input: string): Primitive<T> | null;\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there\'s no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateParse(input: string): never;\n/**\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there\'s no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateParse<T>(input: string): IValidation<Primitive<T>>;\n/**\n * 8x faster `JSON.stringify()` function.\n *\n * Converts an input value to a JSON (JavaScript Object Notation) string, about 8x faster\n * than the native `JSON.stringify()` function. The 5x faster principle is because\n * it writes an optimized JSON conversion plan, only for the type `T`.\n *\n * For reference, this `typia.stringify()` does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can\'t ensure the input value type, it would be better to call one of below functions\n * instead.\n *\n *  - {@link assertStringify}\n *  - {@link isStringify}\n *  - {@link validateStringify}\n *\n * @template T Type of the input value\n * @param input A value to be converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function stringify<T>(input: T): string;\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, JSON\n * string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertStringify<T>(input: T): string;\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, JSON\n * string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertStringify<T>(input: T): unknown;\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.stringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there\'s no problem on the `input` value, JSON string would\n * be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isStringify<T>(input: T): string | null;\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.isStringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *f\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there\'s no problem on the `input` value, JSON string would\n * be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isStringify<T>(input: unknown): string | null;\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s no\n * problem on the `input` value, JSON string would be stored in `data` property of\n * the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateStringify<T>(input: T): IValidation<string>;\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s no\n * problem on the `input` value, JSON string would be stored in `data` property of\n * the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateStringify<T>(input: unknown): IValidation<string>;\n/**\n * > You must configure the generic argument `T`.\n *\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there\'re some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function random(generator?: Partial<IRandomGenerator>): never;\n/**\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there\'re some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function random<T>(generator?: Partial<IRandomGenerator>): Primitive<T>;\n/**\n * > You must configure the generic argument `T`.\n *\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<"A" | "B" | 1>; // ["A", "B", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type\'s members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function literals(): never;\n/**\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<"A" | "B" | 1>; // ["A", "B", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type\'s members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function literals<T extends Atomic.Type>(): T[];\n/**\n * Clone a data.\n *\n * Clones an instance following type `T`. If the target *input* value or its member\n * variable contains a class instance that is having a `toJSON()` method, its return\n * value would be cloned.\n *\n * For reference, this `typia.clone()` function does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can\'t ensure the input value type, it would be better to call {@link assertClone}\n * function instead.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function clone<T>(input: T): Primitive<T>;\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertClone<T>(input: T): Primitive<T>;\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertClone<T>(input: unknown): Primitive<T>;\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isClone<T>(input: T): Primitive<T> | null;\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isClone<T>(input: unknown): Primitive<T> | null;\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance that is having a\n * `toJSON()` method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there\'s no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nexport declare function validateClone<T>(input: T): IValidation<Primitive<T>>;\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance that is having a\n * `toJSON()` method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there\'s no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nexport declare function validateClone<T>(input: unknown): IValidation<Primitive<T>>;\n/**\n * Prune, erase superfluous properties.\n *\n * Remove every superfluous properties from the `input` object, even including nested\n * objects. Note that, as every superfluous properties would be deleted, you never can\n * read those superfluous properties after calling this `prune()` function.\n *\n * For reference, this `typia.prune()` function does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can\'t ensure the input value type, it would better to call one of below functions\n * instead.\n *\n *   - {@link assertPrune}\n *   - {@link isPrune}\n *   - {@link validatePrune}\n *\n * @template T Type of the input value\n * @param input Target instance to prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function prune<T extends object>(input: T): void;\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.assertPrune()` is a combination function of {@link assert} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, its\n * every superfluous properties would be removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertPrune<T>(input: T): T;\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.assertPrune()` is a combination function of {@link assert} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, its\n * every superfluous properties would be removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertPrune<T>(input: unknown): T;\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.assertPrune()` is a combination function of {@link is} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there\'s no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isPrune<T>(input: T): input is T;\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.assertPrune()` is a combination function of {@link is} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there\'s no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isPrune<T>(input: unknown): input is T;\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.validatePrune()` is a combination function of {@link validate} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validatePrune<T>(input: T): IValidation<T>;\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.validatePrune()` is a combination function of {@link validate} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validatePrune<T>(input: unknown): IValidation<T>;\n/**\n * Creates a reusable {@link assert} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssert(): never;\n/**\n * Creates a reusable {@link assert} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assert` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssert<T>(): (input: unknown) => T;\n/**\n * Creates a reusable {@link assertType} function.\n *\n * Duplicated function of {@link createAssert} for `typescript-is` users.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function createAssertType(): never;\n/**\n * Creates a reusable {@link assertType} function.\n *\n * Duplicated function of {@link createAssert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @returns A reusable `assert` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function createAssertType<T>(): (input: unknown) => T;\n/**\n * Creates a reusable {@link is} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIs(): never;\n/**\n * Creates a reusable {@link is} function.\n *\n * @template T Type of the input value\n * @returns A reusable `is` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIs<T>(): (input: unknown) => input is T;\n/**\n * Creates a reusable {@link validate} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidate(): never;\n/**\n * Creates a reusable {@link validate} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validate` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidate<T>(): (input: unknown) => IValidation<T>;\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertEquals(): never;\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assertEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertEquals<T>(): (input: unknown) => T;\n/**\n * Creates a reusable {@link equals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createEquals(): never;\n/**\n * Creates a reusable {@link equals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `equals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createEquals<T>(): (input: unknown) => input is T;\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateEquals(): never;\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateEquals<T>(): (input: unknown) => IValidation<T>;\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsParse(): never;\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `isParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsParse<T>(): (input: string) => Primitive<T> | null;\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertParse(): never;\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `assertParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertParse<T>(): (input: string) => Primitive<T>;\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateParse(): never;\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `validateParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateParse<T>(): (input: string) => IValidation<Primitive<T>>;\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createStringify(): never;\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `stringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createStringify<T>(): (input: T) => string;\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertStringify(): never;\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assertStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertStringify<T>(): (input: unknown) => string;\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsStringify(): never;\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsStringify<T>(): (input: unknown) => string | null;\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateStringify(): never;\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateStringify` function\n\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateStringify<T>(): (input: unknown) => IValidation<string>;\n/**\n * Creates a reusable {@link random} function.\n *\n * @danger You have to specify the generic argument `T`\n * @param generator Random data generator\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createRandom(generator?: Partial<IRandomGenerator>): never;\n/**\n * Creates a resuable {@link random} function.\n *\n * @template T Type of the input value\n * @param generator Random data generator\n * @returns A reusable `random` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createRandom<T>(generator?: Partial<IRandomGenerator>): () => Primitive<T>;\n/**\n * Creates a reusable {@link clone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createClone(): never;\n/**\n * Creates a resuable {@link clone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createClone<T>(): (input: T) => Primitive<T>;\n/**\n * Creates a reusable {@link assertClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertClone(): never;\n/**\n * Creates a resuable {@link assertClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertClone<T>(): (input: unknown) => Primitive<T>;\n/**\n * Creates a reusable {@link isClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsClone(): never;\n/**\n * Creates a resuable {@link isClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsClone<T>(): (input: unknown) => Primitive<T> | null;\n/**\n * Creates a reusable {@link validateClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateClone(): never;\n/**\n * Creates a resuable {@link validateClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateClone<T>(): (input: unknown) => IValidation<Primitive<T>>;\n/**\n * Creates a reusable {@link prune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createPrune(): never;\n/**\n * Creates a resuable {@link prune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `prune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createPrune<T extends object>(): (input: T) => void;\n/**\n * Creates a reusable {@link assertPrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertPrune(): never;\n/**\n * Creates a resuable {@link assertPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertPrune<T extends object>(): (input: T) => T;\n/**\n * Creates a reusable {@link isPrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsPrune(): never;\n/**\n * Creates a resuable {@link isPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsPrune<T extends object>(): (input: T) => input is T;\n/**\n * Creates a reusable {@link validatePrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidatePrune(): never;\n/**\n * Creates a resuable {@link validatePrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validatePrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidatePrune<T extends object>(): (input: T) => IValidation<T>;\n'],["file:///node_modules/typia/lib/Primitive.d.ts",'/**\n * Primitive type.\n *\n * `Primitive` is a type of TMP (Type Meta Programming) type who converts its argument as a\n * primitive type.\n *\n * If the target argument is a built-in class who returns its origin primitive type through\n * the `valueOf()` method like the `String` or `Number`, its return type would be the\n * `string` or `number`.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom method would\n * be erased and its prototype would be changed to the primitive `object`. Therefore, return\n * type of the TMP type finally be the primitive object.\n *\n * In addition, if the target argument is a type of custom class and it has a special\n * method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\n * but `Primitive<ReturnType<Instance.toJSON>>`.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `String`                | `string`\n * `Class`                 | `object`\n * `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\n * Others                  | No change\n *\n * @template Instance Target argument type.\n * @author Jenogho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n * @author Michael - https://github.com/8471919\n */\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true ? T : PrimitiveMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype PrimitiveMain<Instance> = Instance extends [never] ? never : ValueOf<Instance> extends boolean | number | bigint | string ? ValueOf<Instance> : ValueOf<Instance> extends object ? Instance extends object ? Instance extends NativeClass ? {} : Instance extends IJsonable<infer Raw> ? ValueOf<Raw> extends object ? Raw extends object ? PrimitiveObject<Raw> : never : ValueOf<Raw> : PrimitiveObject<Instance> : never : ValueOf<Instance>;\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T> ? IsTuple<Instance> extends true ? PrimitiveTuple<Instance> : PrimitiveMain<T>[] : {\n    [P in keyof Instance]: Instance[P] extends Function ? never : PrimitiveMain<Instance[P]>;\n};\ntype PrimitiveTuple<T extends readonly any[]> = T extends [] ? [] : T extends [infer F] ? [PrimitiveMain<F>] : T extends [infer F, ...infer Rest extends readonly any[]] ? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>] : T extends [(infer F)?] ? [PrimitiveMain<F>?] : T extends [(infer F)?, ...infer Rest extends readonly any[]] ? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>] : [];\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true ? boolean : IsValueOf<Instance, Number> extends true ? number : IsValueOf<Instance, String> extends true ? string : Instance;\ntype NativeClass = Set<any> | Map<any, any> | WeakSet<any> | WeakMap<any, any> | Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | BigUint64Array | Int8Array | Int16Array | Int32Array | BigInt64Array | Float32Array | Float64Array | ArrayBuffer | SharedArrayBuffer | DataView;\ntype IsTuple<T extends readonly any[] | {\n    length: number;\n}> = [T] extends [\n    never\n] ? false : T extends readonly any[] ? number extends T["length"] ? false : true : false;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object ? Object extends IValueOf<infer Primitive> ? Instance extends Primitive ? false : true : false : false;\ninterface IValueOf<T> {\n    valueOf(): T;\n}\ninterface IJsonable<T> {\n    toJSON(): T;\n}\nexport {};\n'],["file:///node_modules/typia/lib/programmers/ApplicationProgrammer.d.ts",'import { Metadata } from "../metadata/Metadata";\nimport { IJsonApplication } from "../schemas/IJsonApplication";\nexport declare namespace ApplicationProgrammer {\n    interface IOptions {\n        purpose: "ajv" | "swagger";\n    }\n    const write: (options?: Partial<IOptions>) => (metadatas: Array<Metadata>) => IJsonApplication;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertCloneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertCloneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertParseProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertParseProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (equals: boolean) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertPruneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertPruneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertStringifyProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertStringifyProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/CheckerProgrammer.d.ts",'import ts from "typescript";\nimport { MetadataCollection } from "../factories/MetadataCollection";\nimport { Metadata } from "../metadata/Metadata";\nimport { MetadataObject } from "../metadata/MetadataObject";\nimport { IProject } from "../transformers/IProject";\nimport { FeatureProgrammer } from "./FeatureProgrammer";\nimport { FunctionImporter } from "./helpers/FunctionImporeter";\nimport { ICheckEntry } from "./helpers/ICheckEntry";\nimport { IExpressionEntry } from "./helpers/IExpressionEntry";\nexport declare namespace CheckerProgrammer {\n    interface IConfig {\n        prefix: string;\n        path: boolean;\n        trace: boolean;\n        equals: boolean;\n        numeric: boolean;\n        addition?: () => ts.Statement[];\n        decoder?: () => FeatureProgrammer.Decoder<Metadata, ts.Expression>;\n        combiner: IConfig.Combiner;\n        atomist: (explore: IExplore) => (check: ICheckEntry) => (input: ts.Expression) => ts.Expression;\n        joiner: IConfig.IJoiner;\n        success: ts.Expression;\n    }\n    namespace IConfig {\n        interface Combiner {\n            (explorer: IExplore): {\n                (logic: "and" | "or"): {\n                    (input: ts.Expression, binaries: IBinary[], expected: string): ts.Expression;\n                };\n            };\n        }\n        interface IJoiner {\n            object(input: ts.Expression, entries: IExpressionEntry[]): ts.Expression;\n            array(input: ts.Expression, arrow: ts.ArrowFunction): ts.Expression;\n            tuple?(exprs: ts.Expression[]): ts.Expression;\n            failure(value: ts.Expression, expected: string, explore?: FeatureProgrammer.IExplore): ts.Expression;\n            is?(expression: ts.Expression): ts.Expression;\n            required?(exp: ts.Expression): ts.Expression;\n            full?: (condition: ts.Expression) => (input: ts.Expression, expected: string, explore: IExplore) => ts.Expression;\n        }\n    }\n    type IExplore = FeatureProgrammer.IExplore;\n    interface IBinary {\n        expression: ts.Expression;\n        combined: boolean;\n    }\n    const write: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n    const write_object_functions: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const write_union_functions: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const write_array_functions: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const write_tuple_functions: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const decode_object: (config: IConfig) => (importer: FunctionImporter) => (input: ts.Expression, obj: MetadataObject, explore: IExplore) => ts.CallExpression;\n}\n'],["file:///node_modules/typia/lib/programmers/CloneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace CloneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/FeatureProgrammer.d.ts",'import ts from "typescript";\nimport { MetadataCollection } from "../factories/MetadataCollection";\nimport { IJsDocTagInfo } from "../metadata/IJsDocTagInfo";\nimport { IMetadataTag } from "../metadata/IMetadataTag";\nimport { Metadata } from "../metadata/Metadata";\nimport { MetadataArray } from "../metadata/MetadataArray";\nimport { MetadataObject } from "../metadata/MetadataObject";\nimport { IProject } from "../transformers/IProject";\nimport { CheckerProgrammer } from "./CheckerProgrammer";\nimport { FunctionImporter } from "./helpers/FunctionImporeter";\nimport { IExpressionEntry } from "./helpers/IExpressionEntry";\nexport declare namespace FeatureProgrammer {\n    interface IConfig<Output extends ts.ConciseBody = ts.ConciseBody> {\n        types: IConfig.ITypes;\n        /**\n         * Prefix name of internal functions for specific types.\n         */\n        prefix: string;\n        /**\n         * Whether to archive access path or not.\n         */\n        path: boolean;\n        /**\n         * Whether to trace exception or not.\n         */\n        trace: boolean;\n        addition?(collection: MetadataCollection): ts.Statement[];\n        /**\n         * Initializer of metadata.\n         */\n        initializer: (project: IProject) => (type: ts.Type) => [MetadataCollection, Metadata];\n        /**\n         * Decoder, station of every types.\n         */\n        decoder: () => Decoder<Metadata, Output>;\n        /**\n         * Object configurator.\n         */\n        objector: IConfig.IObjector;\n        /**\n         * Generator of functions for object types.\n         */\n        generator: IConfig.IGenerator;\n    }\n    namespace IConfig {\n        interface ITypes {\n            input: (type: ts.Type, name?: string) => ts.TypeNode;\n            output: (type: ts.Type, name?: string) => ts.TypeNode;\n        }\n        interface IObjector {\n            /**\n             * Type checker when union object type comes.\n             */\n            checker: () => Decoder<Metadata, ts.Expression>;\n            /**\n             * Decoder, function call expression generator of specific typed objects.\n             */\n            decoder: () => Decoder<MetadataObject, ts.Expression>;\n            /**\n             * Joiner of expressions from properties.\n             */\n            joiner(input: ts.Expression, entries: IExpressionEntry[], parent: MetadataObject): ts.ConciseBody;\n            /**\n             * Union type specificator.\n             *\n             * Expression of an algorithm specifying object type and calling\n             * the `decoder` function of the specified object type.\n             */\n            unionizer: Decoder<MetadataObject[], ts.Expression>;\n            /**\n             * Handler of union type specification failure.\n             *\n             * @param value Expression of input parameter\n             * @param expected Expected type name\n             * @param explore Exploration info\n             * @returns Statement of failure\n             */\n            failure(value: ts.Expression, expected: string, explore?: IExplore): ts.Statement;\n            /**\n             * Transformer of type checking expression by discrimination.\n             *\n             * When an object type has been specified by a discrimination without full\n             * iteration, the `unionizer` will decode the object instance after\n             * the last type checking.\n             *\n             * In such circumtance, you can transform the last type checking function.\n             *\n             * @param exp Current expression about type checking\n             * @returns Transformed expression\n             * @deprecated\n             */\n            is?(exp: ts.Expression): ts.Expression;\n            /**\n             * Transformer of non-undefined type checking by discrimination.\n             *\n             * When specifying an union type of objects, `typia` tries to find\n             * descrimination way just by checking only one property type.\n             * If succeeded to find the discrimination way, `typia` will check the target\n             * property type and in the checking, non-undefined type checking would be\n             * done.\n             *\n             * In such process, you can transform the non-undefined type checking.\n             *\n             * @param exp\n             * @returns Transformed expression\n             * @deprecated\n             */\n            required?(exp: ts.Expression): ts.Expression;\n            /**\n             * Conditon wrapper when unable to specify any object type.\n             *\n             * When failed to specify an object type through discrimination, full\n             * iteration type checking would be happend. In such circumstance, you\n             * can wrap the condition with additional function.\n             *\n             * @param condition Current condition\n             * @returns A function wrapped current condition\n             */\n            full?: (condition: ts.Expression) => (input: ts.Expression, expected: string, explore: IExplore) => ts.Expression;\n            /**\n             * Return type.\n             */\n            type?: ts.TypeNode;\n        }\n        interface IGenerator {\n            objects?(): (col: MetadataCollection) => ts.VariableStatement[];\n            unions?(): (col: MetadataCollection) => ts.VariableStatement[];\n            arrays(): (col: MetadataCollection) => ts.VariableStatement[];\n            tuples(): (col: MetadataCollection) => ts.VariableStatement[];\n        }\n    }\n    interface IExplore {\n        tracable: boolean;\n        source: "top" | "function";\n        from: "top" | "array" | "object";\n        postfix: string;\n        start?: number;\n    }\n    interface Decoder<T, Output extends ts.ConciseBody = ts.ConciseBody> {\n        (input: ts.Expression, target: T, explore: IExplore, metaTags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]): Output;\n    }\n    const write: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n    const write_object_functions: (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const write_union_functions: (config: IConfig) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const decode_array: (config: Pick<IConfig, "trace" | "path" | "decoder" | "prefix">) => (importer: FunctionImporter) => (combiner: (input: ts.Expression, arrow: ts.ArrowFunction, metaTags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.Expression) => (input: ts.Expression, array: MetadataArray, explore: IExplore, metaTags: IMetadataTag[], jsDocTags: IJsDocTagInfo[]) => ts.Expression;\n    const decode_object: (config: Pick<IConfig, "trace" | "path" | "prefix">) => (importer: FunctionImporter) => (input: ts.Expression, obj: MetadataObject, explore: IExplore) => ts.CallExpression;\n    const index: (start: number | null) => (prev: string) => (rand: string) => string;\n    const argumentsArray: (config: Pick<IConfig, "path" | "trace">) => (explore: FeatureProgrammer.IExplore) => (input: ts.Expression) => ts.Expression[];\n    const parameterDeclarations: (props: Pick<CheckerProgrammer.IConfig, "path" | "trace">) => (type: ts.TypeNode) => (input: ts.Identifier) => ts.ParameterDeclaration[];\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/AtomicPredicator.d.ts",'import { Metadata } from "../../metadata/Metadata";\nimport { Atomic } from "../../typings/Atomic";\nexport declare namespace AtomicPredicator {\n    const constant: (meta: Metadata) => (name: Atomic.Literal) => boolean;\n    const atomic: (meta: Metadata) => (name: Atomic.Literal) => boolean;\n    const native: (name: string) => boolean;\n    const template: (meta: Metadata) => boolean;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/CloneJoiner.d.ts",'import ts from "typescript";\nimport { IExpressionEntry } from "./IExpressionEntry";\nexport declare namespace CloneJoiner {\n    const object: (input: ts.Expression, entries: IExpressionEntry<ts.Expression>[]) => ts.ConciseBody;\n    const tuple: (children: ts.Expression[], rest: ts.Expression | null) => ts.Expression;\n    const array: (input: ts.Expression, arrow: ts.Expression) => ts.CallExpression;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/disable_function_importer_declare.d.ts",'import { FunctionImporter } from "./FunctionImporeter";\nexport declare const disable_function_importer_declare: (importer: FunctionImporter) => FunctionImporter;\n'],["file:///node_modules/typia/lib/programmers/helpers/FunctionImporeter.d.ts",'import ts from "typescript";\nexport declare class FunctionImporter {\n    private readonly used_;\n    private readonly local_;\n    private readonly unions_;\n    private sequence_;\n    empty(): boolean;\n    use(name: string): ts.Identifier;\n    useLocal(name: string): string;\n    hasLocal(name: string): boolean;\n    declare(modulo: ts.LeftHandSideExpression): ts.Statement[];\n    increment(): number;\n    emplaceUnion(prefix: string, name: string, factory: () => ts.ArrowFunction): string;\n    trace(): void;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/ICheckEntry.d.ts",'import ts from "typescript";\nexport interface ICheckEntry {\n    expression: ts.Expression;\n    tags: ICheckEntry.ITag[];\n}\nexport declare namespace ICheckEntry {\n    interface ITag {\n        expected: string;\n        expression: ts.Expression;\n    }\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/IExpressionEntry.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../metadata/Metadata";\nexport interface IExpressionEntry<Expression extends ts.ConciseBody = ts.ConciseBody> {\n    input: ts.Expression;\n    key: Metadata;\n    meta: Metadata;\n    expression: Expression;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/OptionPredicator.d.ts",'import { ITransformOptions } from "../../transformers/ITransformOptions";\nexport declare namespace OptionPredicator {\n    const numeric: (options: ITransformOptions) => boolean;\n    const functional: (options: ITransformOptions) => boolean;\n    const finite: (options: ITransformOptions) => boolean;\n    const undefined: (options: ITransformOptions) => boolean;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/PruneJoiner.d.ts",'import ts from "typescript";\nimport { MetadataObject } from "../../metadata/MetadataObject";\nimport { IExpressionEntry } from "./IExpressionEntry";\nexport declare namespace PruneJoiner {\n    const object: (input: ts.Expression, entries: IExpressionEntry[], obj: MetadataObject) => ts.ConciseBody;\n    const array: (input: ts.Expression, arrow: ts.ArrowFunction) => ts.CallExpression;\n    const tuple: (children: ts.ConciseBody[], rest: ts.ConciseBody | null) => ts.Block;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/RandomJoiner.d.ts",'import ts from "typescript";\nimport { ICommentTag } from "../../metadata/ICommentTag";\nimport { IMetadataTag } from "../../metadata/IMetadataTag";\nimport { Metadata } from "../../metadata/Metadata";\nimport { MetadataObject } from "../../metadata/MetadataObject";\nexport declare namespace RandomJoiner {\n    type Decoder = (meta: Metadata, tags: IMetadataTag[], comments: ICommentTag[]) => ts.Expression;\n    const array: (coalesce: (method: string) => ts.Expression) => (decoder: Decoder) => (explore: IExplore) => (length: ts.Expression | undefined) => (item: Metadata, tags: IMetadataTag[], comments: ICommentTag[]) => ts.Expression;\n    const tuple: (decoder: Decoder) => (items: Metadata[], tags: IMetadataTag[], comments: ICommentTag[]) => ts.ArrayLiteralExpression;\n    const object: (coalesce: (method: string) => ts.Expression) => (decoder: Decoder) => (obj: MetadataObject) => ts.ConciseBody;\n}\ninterface IExplore {\n    function: boolean;\n    recursive: boolean;\n}\nexport {};\n'],["file:///node_modules/typia/lib/programmers/helpers/RandomRanger.d.ts",'import ts from "typescript";\nimport { IMetadataTag } from "../../metadata/IMetadataTag";\nexport declare namespace RandomRanger {\n    interface IDefaults {\n        minimum: number;\n        maximum: number;\n        gap: number;\n    }\n    const length: (coalesce: (method: string) => ts.Expression) => (defs: IDefaults) => (acc: length.IAccessors) => (tags: IMetadataTag[]) => ts.Expression | undefined;\n    namespace length {\n        interface IAccessors {\n            minimum: IMetadataTag["kind"];\n            maximum: IMetadataTag["kind"];\n            fixed: IMetadataTag["kind"];\n        }\n    }\n    const number: (config: number.IConfig) => (defs: IDefaults) => (tags: IMetadataTag[]) => ts.Expression;\n    namespace number {\n        interface IConfig {\n            setter: (args: number[]) => ts.Expression;\n            transform: (value: number) => ts.Expression;\n            type: "int" | "uint" | "double";\n        }\n    }\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/StringifyJoinder.d.ts",'import ts from "typescript";\nimport { FunctionImporter } from "./FunctionImporeter";\nimport { IExpressionEntry } from "./IExpressionEntry";\nexport declare namespace StringifyJoiner {\n    const object: (importer: FunctionImporter) => (_input: ts.Expression, entries: IExpressionEntry<ts.Expression>[]) => ts.Expression;\n    const array: (input: ts.Expression, arrow: ts.ArrowFunction) => ts.Expression;\n    const tuple: (children: ts.Expression[], rest: ts.Expression | null) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/StringifyPredicator.d.ts",'import { Metadata } from "../../metadata/Metadata";\nexport declare namespace StringifyPredicator {\n    const require_escape: (value: string) => boolean;\n    const undefindable: (meta: Metadata) => boolean;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/UnionExplorer.d.ts",'import ts from "typescript";\nimport { IMetadataTag } from "../../metadata/IMetadataTag";\nimport { Metadata } from "../../metadata/Metadata";\nimport { MetadataArray } from "../../metadata/MetadataArray";\nimport { MetadataObject } from "../../metadata/MetadataObject";\nimport { MetadataTuple } from "../../metadata/MetadataTuple";\nimport { FeatureProgrammer } from "../FeatureProgrammer";\nimport { check_union_array_like } from "../internal/check_union_array_like";\nexport declare namespace UnionExplorer {\n    interface Decoder<T> {\n        (input: ts.Expression, target: T, explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]): ts.Expression;\n    }\n    type ObjectCombiner = Decoder<MetadataObject[]>;\n    const object: (config: FeatureProgrammer.IConfig, level?: number) => (input: ts.Expression, targets: MetadataObject[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.Expression;\n    const tuple: (props: check_union_array_like.IProps<MetadataTuple, MetadataTuple>) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: MetadataTuple[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace tuple {\n        type IProps = check_union_array_like.IProps<MetadataTuple, MetadataTuple>;\n    }\n    const array: (props: array.IProps) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: MetadataArray[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace array {\n        type IProps = check_union_array_like.IProps<MetadataArray, Metadata>;\n    }\n    const array_or_tuple: (props: array_or_tuple.IProps) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: (MetadataArray | MetadataTuple)[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace array_or_tuple {\n        type IProps = check_union_array_like.IProps<MetadataArray | MetadataTuple, Metadata>;\n    }\n    const set: (props: set.IProps) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: Metadata[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace set {\n        type IProps = check_union_array_like.IProps<MetadataArray, Metadata>;\n    }\n    const map: (props: map.IProps) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: Metadata.Entry[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace map {\n        type IProps = check_union_array_like.IProps<MetadataArray, [\n            Metadata,\n            Metadata\n        ]>;\n    }\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/UnionPredicator.d.ts",'import { MetadataObject } from "../../metadata/MetadataObject";\nimport { MetadataProperty } from "../../metadata/MetadataProperty";\nexport declare namespace UnionPredicator {\n    interface ISpecialized {\n        index: number;\n        object: MetadataObject;\n        property: MetadataProperty;\n        neighbour: boolean;\n    }\n    const object: (targets: MetadataObject[]) => Array<ISpecialized>;\n}\n'],["file:///node_modules/typia/lib/programmers/internal/application_alias.d.ts",'import { MetadataAlias } from "../../metadata/MetadataAlias";\nimport { IJsonComponents } from "../../schemas/IJsonComponents";\nimport { IJsonSchema } from "../../module";\nimport { ApplicationProgrammer } from "../ApplicationProgrammer";\nexport declare const application_alias: (options: ApplicationProgrammer.IOptions) => <BlockNever extends boolean>(blockNever: BlockNever) => (components: IJsonComponents) => (alias: MetadataAlias) => (nullable: boolean) => IJsonSchema.IReference;\n'],["file:///node_modules/typia/lib/programmers/internal/application_array.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_boolean.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_constant.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_default.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_default_string.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_native.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_number.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_object.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_resolved.d.ts",'import { MetadataResolved } from "../../metadata/MetadataResolved";\nimport { IJsonComponents, IJsonSchema } from "../../module";\nimport { ApplicationProgrammer } from "../ApplicationProgrammer";\nexport declare const application_resolved: (options: ApplicationProgrammer.IOptions) => <BlockNever extends boolean>(blockNever: BlockNever) => (components: IJsonComponents) => (resolved: MetadataResolved) => (attribute: IJsonSchema.IAttribute) => IJsonSchema[];\n'],["file:///node_modules/typia/lib/programmers/internal/application_schema.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_string.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_templates.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_tuple.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_array.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_array_length.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_bigint.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_custom.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_dynamic_properties.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_everything.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_native.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_number.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_object.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_string.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_string_tags.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_template.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_union_array_like.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/decode_union_object.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/feature_object_entries.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/get_comment_tags.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/JSON_SCHEMA_PREFIX.d.ts",'export declare const JSON_COMPONENTS_PREFIX = "#/components";\n'],["file:///node_modules/typia/lib/programmers/internal/metadata_to_pattern.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/prune_object_properties.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/random_custom.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/stringify_dynamic_properties.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/stringify_native.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/stringify_regular_properties.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/template_to_pattern.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/wrap_metadata_rest_tuple.d.ts",'import { Metadata } from "../../metadata/Metadata";\nexport declare const wrap_metadata_rest_tuple: (rest: Metadata) => Metadata;\n'],["file:///node_modules/typia/lib/programmers/IsCloneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace IsCloneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/IsParseProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace IsParseProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/IsProgrammer.d.ts",'import ts from "typescript";\nimport { MetadataCollection } from "../factories/MetadataCollection";\nimport { MetadataObject } from "../metadata/MetadataObject";\nimport { IProject } from "../transformers/IProject";\nimport { CheckerProgrammer } from "./CheckerProgrammer";\nimport { FunctionImporter } from "./helpers/FunctionImporeter";\nimport { IExpressionEntry } from "./helpers/IExpressionEntry";\nexport declare namespace IsProgrammer {\n    const configure: (options?: Partial<CONFIG.IOptions>) => (importer: FunctionImporter) => CheckerProgrammer.IConfig;\n    namespace CONFIG {\n        interface IOptions {\n            numeric: boolean;\n            undefined: boolean;\n            object: (input: ts.Expression, entries: IExpressionEntry<ts.Expression>[]) => ts.Expression;\n        }\n    }\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression, disable?: boolean) => (equals: boolean) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n    const write_function_statements: (project: IProject) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const decode: (project: IProject) => (importer: FunctionImporter) => (input: ts.Expression, meta: import("../metadata/Metadata").Metadata, explore: import("./FeatureProgrammer").FeatureProgrammer.IExplore, metaTags: import("../metadata/IMetadataTag").IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.Expression;\n    const decode_object: (importer: FunctionImporter) => (input: ts.Expression, obj: MetadataObject, explore: import("./FeatureProgrammer").FeatureProgrammer.IExplore) => ts.CallExpression;\n    const decode_to_json: (checkNull: boolean) => (input: ts.Expression) => ts.Expression;\n    const decode_functional: (input: ts.Expression) => ts.BinaryExpression;\n}\n'],["file:///node_modules/typia/lib/programmers/IsPruneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace IsPruneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/IsStringifyProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace IsStringifyProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/LiteralsProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace LiteralsProgrammer {\n    const write: (project: IProject) => (type: ts.Type) => ts.AsExpression;\n}\n'],["file:///node_modules/typia/lib/programmers/PruneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace PruneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/RandomProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace RandomProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (init?: ts.Expression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/StringifyProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace StringifyProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/TypiaProgrammer.d.ts","export declare namespace TypiaProgrammer {\n    interface IProps {\n        input: string;\n        output: string;\n        project: string;\n    }\n    const build: (props: TypiaProgrammer.IProps) => Promise<void>;\n}\n"],["file:///node_modules/typia/lib/programmers/ValidateCloneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidateCloneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/ValidateParseProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidateParseProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/ValidateProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidateProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (equals: boolean) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/ValidatePruneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidatePruneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/ValidateStringifyProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidateStringifyProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/schemas/IJsonApplication.d.ts",'import { IJsonComponents } from "./IJsonComponents";\nimport { IJsonSchema } from "./IJsonSchema";\nexport interface IJsonApplication {\n    schemas: IJsonSchema[];\n    components: IJsonComponents;\n    purpose: "swagger" | "ajv";\n}\n'],["file:///node_modules/typia/lib/schemas/IJsonComponents.d.ts",'import { IJsDocTagInfo } from "../metadata/IJsDocTagInfo";\nimport { IJsonSchema } from "./IJsonSchema";\nexport interface IJsonComponents {\n    schemas?: Record<string, IJsonComponents.IObject | IJsonComponents.IAlias>;\n}\nexport declare namespace IJsonComponents {\n    interface IObject {\n        $id?: string;\n        type: "object";\n        /**\n         * Only when swagger mode.\n         */\n        nullable?: boolean;\n        properties: Record<string, IJsonSchema>;\n        patternProperties?: Record<string, IJsonSchema>;\n        additionalProperties?: IJsonSchema;\n        required?: string[];\n        description?: string;\n        "x-typia-jsDocTags"?: IJsDocTagInfo[];\n        "x-typia-patternProperties"?: Record<string, IJsonSchema>;\n        "x-typia-additionalProperties"?: IJsonSchema;\n    }\n    type IAlias = IJsonSchema & {\n        $id?: string;\n        $recursiveAnchor?: boolean;\n    };\n}\n'],["file:///node_modules/typia/lib/schemas/IJsonSchema.d.ts",'import { IJsDocTagInfo } from "../metadata/IJsDocTagInfo";\nimport { IMetadataTag } from "../metadata/IMetadataTag";\nimport { Atomic } from "../typings/Atomic";\nexport type IJsonSchema = IJsonSchema.Known | IJsonSchema.IUnknown;\nexport declare namespace IJsonSchema {\n    type Known = IEnumeration<"boolean"> | IEnumeration<"number"> | IEnumeration<"string"> | IBoolean | IInteger | INumber | IString | IArray | ITuple | IOneOf | IReference | INullOnly;\n    interface IUnknown extends IAttribute {\n        type?: undefined;\n    }\n    interface IEnumeration<Literal extends Exclude<Atomic.Literal, "bigint">> extends IAtomic<Literal> {\n        enum: Array<Atomic.Mapper[Literal]>;\n    }\n    interface IAtomic<Literal extends Exclude<Atomic.Literal, "bigint">> extends ISignificant<Literal> {\n        default?: Atomic.Mapper[Literal];\n    }\n    interface IString extends IAtomic<"string"> {\n        /**\n         * @type uint\n         */\n        minLength?: number;\n        /**\n         * @type uint\n         */\n        maxLength?: number;\n        pattern?: string;\n        format?: string;\n    }\n    interface INumber extends IAtomic<"number"> {\n        minimum?: number;\n        maximum?: number;\n        exclusiveMinimum?: boolean;\n        exclusiveMaximum?: boolean;\n        multipleOf?: number;\n    }\n    interface IInteger extends IAtomic<"integer"> {\n        /**\n         * @type int\n         */\n        minimum?: number;\n        /**\n         * @type int\n         */\n        maximum?: number;\n        exclusiveMinimum?: boolean;\n        exclusiveMaximum?: boolean;\n        /**\n         * @type int\n         */\n        multipleOf?: number;\n    }\n    interface IBoolean extends IAtomic<"boolean"> {\n    }\n    interface IArray extends ISignificant<"array"> {\n        items: IJsonSchema;\n        /**\n         * @type uint\n         */\n        minItems?: number;\n        /**\n         * @type uint\n         */\n        maxItems?: number;\n        "x-typia-tuple"?: ITuple;\n    }\n    interface ITuple extends ISignificant<"array"> {\n        items: IJsonSchema[];\n        /**\n         * @type uint\n         */\n        minItems: number;\n        /**\n         * @type uint\n         */\n        maxItems?: number;\n    }\n    interface IReference extends IAttribute {\n        $ref: string;\n    }\n    interface INullOnly extends IAttribute {\n        type: "null";\n    }\n    interface IOneOf extends IAttribute {\n        oneOf: IJsonSchema[];\n    }\n    interface ISignificant<Literal extends string> extends IAttribute {\n        type: Literal;\n        /**\n         * Only when swagger mode.\n         */\n        nullable?: boolean;\n    }\n    interface IAttribute {\n        deprecated?: boolean;\n        title?: string;\n        description?: string;\n        "x-typia-metaTags"?: IMetadataTag[];\n        "x-typia-jsDocTags"?: IJsDocTagInfo[];\n        "x-typia-required"?: boolean;\n        "x-typia-optional"?: boolean;\n        "x-typia-rest"?: boolean;\n    }\n}\n'],["file:///node_modules/typia/lib/transform.d.ts",'import ts from "typescript";\nimport { ITransformOptions } from "./transformers/ITransformOptions";\nexport declare const transform: (program: ts.Program, options?: ITransformOptions) => ts.TransformerFactory<ts.SourceFile>;\nexport default transform;\n'],["file:///node_modules/typia/lib/transformers/CallExpressionTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "./IProject";\nexport declare namespace CallExpressionTransformer {\n    const transform: (project: IProject) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/ApplicationTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace ApplicationTransformer {\n    const transform: ({ checker }: IProject) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/AssertCloneTransformer.d.ts",'export declare namespace AssertCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/AssertPruneTransformer.d.ts",'export declare namespace AssertPruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CloneTransformer.d.ts",'export declare namespace CloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateAssertCloneTransformer.d.ts",'export declare namespace CreateAssertCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateAssertPruneTransformer.d.ts",'export declare namespace CreateAssertPruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateCloneTransformer.d.ts",'export declare namespace CreateCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateIsCloneTransformer.d.ts",'export declare namespace CreateIsCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateIsPruneTransformer.d.ts",'export declare namespace CreateIsPruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreatePruneTransformer.d.ts",'export declare namespace CreatePruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateRandomTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace CreateRandomTransformer {\n    const transform: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateValidateCloneTransformer.d.ts",'export declare namespace CreateValidateCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateValidatePruneTransformer.d.ts",'export declare namespace CreateValidatePruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/IsCloneTransformer.d.ts",'export declare namespace IsCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/IsPruneTransformer.d.ts",'export declare namespace IsPruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/LiteralsTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace LiteralsTransformer {\n    const transform: (project: IProject) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/MetadataTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace MetadataTransformer {\n    const transform: ({ checker }: IProject) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/PruneTransformer.d.ts",'export declare namespace PruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/RandomTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace RandomTransformer {\n    const transform: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/ValidateCloneTransformer.d.ts",'export declare namespace ValidateCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/ValidatePruneTransformer.d.ts",'export declare namespace ValidatePruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/AssertParseTransformer.d.ts",'export declare namespace AssertParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/CreateAssertParseTransformer.d.ts",'export declare namespace CreateAssertParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/CreateIsParseTransformer.d.ts",'export declare namespace CreateIsParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/CreateValidateParseTransformer.d.ts",'export declare namespace CreateValidateParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/IsParseTransformer.d.ts",'export declare namespace IsParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/ValidateParseTransformer.d.ts",'export declare namespace ValidateParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/AssertStringifyTransformer.d.ts",'export declare namespace AssertStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/CreateAssertStringifyTransformer.d.ts",'export declare namespace CreateAssertStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/CreateIsStringifyTransformer.d.ts",'export declare namespace CreateIsStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/CreateStringifyTransformer.d.ts",'export declare namespace CreateStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/CreateValidateStringifyProgrammer.d.ts",'export declare namespace CreateValidateStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/IsStringifyTransformer.d.ts",'export declare namespace IsStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/StringifyTransformer.d.ts",'export declare namespace StringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/ValidateStringifyTransformer.d.ts",'export declare namespace ValidateStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/AssertTransformer.d.ts",'export declare namespace AssertTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/CreateAssertTransformer.d.ts",'export declare namespace CreateAssertTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/CreateIsTransformer.d.ts",'export declare namespace CreateIsTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/CreateValidateTransformer.d.ts",'export declare namespace CreateValidateTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/IsTransformer.d.ts",'export declare namespace IsTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/ValidateTransformer.d.ts",'export declare namespace ValidateTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/FileTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "./IProject";\nexport declare namespace FileTransformer {\n    const transform: (project: IProject) => (context: ts.TransformationContext) => (file: ts.SourceFile) => ts.SourceFile;\n}\n'],["file:///node_modules/typia/lib/transformers/ImportTransformer.d.ts",'import ts from "typescript";\nexport declare namespace ImportTransformer {\n    const transform: (from: string) => (to: string) => (context: ts.TransformationContext) => (file: ts.SourceFile) => ts.SourceFile;\n}\n'],["file:///node_modules/typia/lib/transformers/internal/GenericTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../IProject";\nexport declare namespace GenericTransformer {\n    const scalar: (method: string) => (programmer: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name: string) => ts.ArrowFunction) => (project: IProject) => (modulo: ts.LeftHandSideExpression) => (expression: ts.CallExpression) => ts.CallExpression;\n    const factory: (method: string) => (programmer: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name: string) => ts.ArrowFunction) => (project: IProject) => (modulo: ts.LeftHandSideExpression) => (expression: ts.CallExpression) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/IProject.d.ts",'import ts from "typescript";\nimport { ITransformOptions } from "./ITransformOptions";\nexport interface IProject {\n    program: ts.Program;\n    compilerOptions: ts.CompilerOptions;\n    checker: ts.TypeChecker;\n    printer: ts.Printer;\n    options: ITransformOptions;\n}\n'],["file:///node_modules/typia/lib/transformers/ITransformOptions.d.ts","export interface ITransformOptions {\n    /**\n     * Whether to validate finite number or not.\n     *\n     * If configured true, number typed values would be validated by Number.isNaN().\n     *\n     * However, whatever you configure, it would be ignored when marshaling or parsing.\n     *\n     *   - when marshaling, always be true\n     *     - assertStringify()\n     *     - validateEncode()\n     *   - when parsing, always be false\n     *     - assertParse()\n     *     - isDecode()\n     *\n     * @default false\n     */\n    finite?: boolean;\n    /**\n     * Whether to validate finite number or not.\n     *\n     * If configured true, number typed values would be validated by Number.isFinite().\n     *\n     * However, whatever you configure, it can be ignored in below case.\n     *\n     *   - when `finite` option is true, this option would be ignored\n     *   - when marshaling, always be true\n     *     - assertStringify()\n     *     - validateEncode()\n     *   - when parsing, always be false\n     *     - assertParse()\n     *     - isDecode()\n     *\n     * @default false\n     */\n    numeric?: boolean;\n    /**\n     * Whether to validate functional type or not.\n     *\n     * However, whatever you configure, it becomes false when marshaling or parsing.\n     *\n     * @default false\n     */\n    functional?: boolean;\n    /**\n     * Whether to check undefined value or not.\n     *\n     * JavaScript can assign `undefined` value to a specific property and it is an\n     * issue when validating without allowing superfluous properties. Should undefined\n     * value assigned superfluous property be allowed or not?\n     *\n     * Note that, this option only works on {@link equals} function. Other function\n     * like {@link assertEquals} or {@link validateEquals} would ignore this option\n     * value and always allow the `undefined` value.\n     *\n     * @default true\n     */\n    undefined?: boolean;\n}\n"],["file:///node_modules/typia/lib/transformers/NodeTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "./IProject";\nexport declare namespace NodeTransformer {\n    const transform: (project: IProject) => (expression: ts.Node) => ts.Node;\n}\n'],["file:///node_modules/typia/lib/TypeGuardError.d.ts","export declare class TypeGuardError extends Error {\n    readonly method: string;\n    readonly path: string | undefined;\n    readonly expected: string;\n    readonly value: any;\n    constructor(props: TypeGuardError.IProps);\n}\nexport declare namespace TypeGuardError {\n    interface IProps {\n        method: string;\n        path?: string;\n        expected: string;\n        value: any;\n        message?: string;\n    }\n}\n"],["file:///node_modules/typia/lib/typings/Atomic.d.ts",'export declare namespace Atomic {\n    type Type = boolean | number | string | bigint;\n    type Literal = "boolean" | "integer" | "number" | "string" | "bigint";\n    type Mapper = {\n        boolean: boolean;\n        integer: number;\n        number: number;\n        string: string;\n        bigint: bigint;\n    };\n}\n'],["file:///node_modules/typia/lib/typings/ClassProperties.d.ts",'import { OmitNever } from "./OmitNever";\nexport type ClassProperties<T extends object> = OmitNever<{\n    [K in keyof T]: T[K] extends Function ? never : T[K];\n}>;\n'],["file:///node_modules/typia/lib/typings/Customizable.d.ts","export type Customizable = {\n    number: number;\n    string: string;\n    bigint: bigint;\n};\n"],["file:///node_modules/typia/lib/typings/OmitNever.d.ts",'import { SpecialFields } from "./SpecialFields";\nexport type OmitNever<T extends object> = Omit<T, SpecialFields<T, never>>;\n'],["file:///node_modules/typia/lib/typings/SpecialFields.d.ts","export type SpecialFields<Instance extends object, Target> = {\n    [P in keyof Instance]: Instance[P] extends Target ? P : never;\n}[keyof Instance & string];\n"],["file:///node_modules/typia/lib/typings/Writable.d.ts",'import { ClassProperties } from "./ClassProperties";\nexport type Writable<T extends object> = {\n    -readonly [P in keyof T]: T[P];\n};\nexport declare function Writable<T extends object>(elem: T): Writable<ClassProperties<T>>;\n'],["file:///node_modules/typia/lib/utils/ArrayUtil.d.ts","export declare namespace ArrayUtil {\n    const has: <T>(array: T[], pred: (elem: T) => boolean) => boolean;\n    const add: <T>(array: T[], value: T, pred?: (x: T, y: T) => boolean) => boolean;\n    const set: <Key, T>(array: T[], value: T, key: (elem: T) => Key) => void;\n    const take: <T>(array: T[], pred: (elem: T) => boolean, init: () => T) => T;\n    const repeat: <T>(count: number, closure: (index: number, count: number) => T) => T[];\n    const flat: <T>(matrix: T[][]) => T[];\n}\n"],["file:///node_modules/typia/lib/utils/Escaper.d.ts","export declare namespace Escaper {\n    const variable: (str: string) => boolean;\n}\n"],["file:///node_modules/typia/lib/utils/MapUtil.d.ts","export declare namespace MapUtil {\n    const take: <Key, T>(dict: Map<Key, T>) => (key: Key, generator: () => T) => T;\n}\n"],["file:///node_modules/typia/lib/utils/PatternUtil.d.ts",'export declare namespace PatternUtil {\n    const fix: (str: string) => string;\n    const escape: (str: string) => string;\n    const NUMBER = "-?\\d+\\.?\\d*";\n    const BOOLEAN = "true|false";\n    const STRING = "(.*)";\n}\n'],["file:///node_modules/typia/lib/utils/RandomGenerator.d.ts","export {};\n"],["file:///node_modules/typia/lib/utils/Singleton.d.ts","export declare class Singleton<T, Args extends any[] = []> {\n    private readonly closure_;\n    private value_;\n    constructor(closure: (...args: Args) => T);\n    get(...args: Args): T;\n}\n"]];(a=o||(o={})).compile=e=>{let t=new Map;for(let[e,n]of f){if(e.endsWith("packageJson.d.ts"))continue;let a=e.replace("file:///",""),r=m().createSourceFile(e,n,m().ScriptTarget.ES2016);t.set(a,r)}let n=m().createSourceFile("main.ts",e,m().ScriptTarget.ES2016);t.set("main.ts",n);let a={value:""},o=m().createProgram(["main.ts"],r,{fileExists:e=>t.has(e),writeFile:(e,t)=>a.value=t,readFile:e=>e.startsWith("node_modules/")&&e.endsWith("/package.json")?f.find(t=>t[0]==="file:///".concat(e))[1]:void 0,getSourceFile:e=>t.get(e),getDefaultLibFileName:()=>"node_modules/typia/index.d.ts",directoryExists:()=>!0,getCurrentDirectory:()=>"",getDirectories:()=>[],getNewLine:()=>"\n",getCanonicalFileName:e=>e,useCaseSensitiveFileNames:()=>!1});window.checker=o.getTypeChecker(),window.source=n;try{return o.emit(void 0,void 0,void 0,void 0,{before:[u()(o)]}),{type:"success",content:a.value}}catch(e){return{type:"error",error:e}}},r=a.OPTIONS={target:m().ScriptTarget.ES2015,module:m().ModuleKind.CommonJS,lib:["DOM","ES2015"],esModuleInterop:!0,forceConsistentCasingInFileNames:!0,strict:!0,skipLibCheck:!0,emitDecoratorMetadata:!0,experimentalDecorators:!0};var y=n(3764);function h(e){let[t,n]=(0,p.useState)(),a=(0,y.Ik)();return(0,p.useEffect)(()=>{a&&(async()=>{let t=await a.editor.colorize(e.content,e.language,{tabSize:4});n(t)})()},[a,e.content]),(0,i.jsx)("div",{children:t&&(0,i.jsx)("div",{dangerouslySetInnerHTML:{__html:t},style:{backgroundColor:"#1e1e1e",overflowX:"auto",overflowY:"auto",paddingLeft:"15px",width:"calc(50vw - 15px)",height:"calc(90vh - 25px)",fontFamily:"monospace"}})})}let g=e=>{let t=(t,n)=>{for(let[t,a]of(n.languages.typescript.typescriptDefaults.setCompilerOptions(e.options),e.imports))n.languages.typescript.typescriptDefaults.addExtraLib(a,t);let a=n.editor.createModel(e.script,"typescript",n.Uri.parse("file:///main.ts"));t.setModel(a)};return(0,i.jsx)(y.ZP,{height:"calc(90vh - 25px)",theme:"vs-dark",onMount:t,onChange:e.setScript})};var b=n(2571),x=n.n(b),T=n(9369);let I=()=>{let[e,t]=(0,p.useState)('import typia from "typia";\n\ninterface IMember {\n    /** \n     * @format uuid \n     */ \n    id: string;\n\n    /** \n     * @format email \n     */ \n    email: string;\n\n    /**\n     * @type uint\n     * @minimum 20\n     * @exclusiveMaximum 100\n     */\n    age: number;\n    parent: IMember | null;\n    children: IMember[];\n}\n\n//----\n// IS\n//----\ntypia.createIs<IMember>();\n\n//----\n// EQUALS\n//----\ntypia.createEquals<IMember>();\n\n//----\n// RANDOM\n//----\ntypia.createRandom<IMember>();\n\n//----\n// ASSERT-STRINGIFY\n//----\ntypia.createAssertStringify<IMember>();\n\n//----\n// JSON SCHEMA\n//----\ntypia.application<[IMember], "ajv">();\n'),[n,a]=(0,p.useState)(null);(0,p.useEffect)(()=>{var t,n,a,o,i,p;document.head.title="Typia Playground",null===(t=T.Z.useNextSeoProps)||void 0===t||null===(n=t.call(T.Z))||void 0===n||null===(a=n.additionalLinkTags)||void 0===a||a.forEach(e=>document.head.appendChild(Object.assign(document.createElement("link"),e))),null===(o=T.Z.useNextSeoProps)||void 0===o||null===(i=o.call(T.Z))||void 0===i||null===(p=i.additionalMetaTags)||void 0===p||p.forEach(e=>document.head.appendChild(Object.assign(document.createElement("meta"),e))),document.body.style.overflow="hidden",document.body.style.margin="0",document.body.style.fontFamily="Arial, sans-serif",document.body.style.backgroundColor="#1e1e1e";let l=Object.fromEntries(new URLSearchParams(window.location.search).entries());if(l.script){let e=(0,s.decompressFromEncodedURIComponent)(l.script);e&&r(e)}else r(e)},[]);let r=n=>{t(null!=n?n:"");let r=o.compile(null!=n?n:"");"success"===r.type&&window.history.replaceState(null,"Typia Playground","".concat(location.origin).concat(location.pathname,"?script=").concat((0,s.compressToEncodedURIComponent)(e))),a(r)},c=()=>{e&&navigator.permissions.query({name:"clipboard-write"}).then(t=>{("granted"==t.state||"prompt"==t.state)&&navigator.clipboard.writeText(location.origin+location.pathname+"?script=".concat((0,s.compressToEncodedURIComponent)(e)))})},m=l.Z;return(0,i.jsxs)("div",{children:[(0,i.jsxs)("header",{className:x().header,children:[(0,i.jsxs)("div",{style:{display:"flex"},children:[(0,i.jsx)("h2",{children:"Typia - Superfast Runtime Validator"}),(0,i.jsx)("button",{className:x().button,onClick:()=>c(),children:"Copy Link"})]}),(0,i.jsx)("a",{href:"https://github.com/samchon/typia",style:{fontSize:"24px"},children:(0,i.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",width:"28",height:"28",fill:"currentColor",viewBox:"0 0 16 16",children:(0,i.jsx)("path",{d:"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"})})})]}),(0,i.jsxs)(m,{split:"vertical",defaultSize:"50%",primary:"first",children:[(0,i.jsx)(g,{options:o.OPTIONS,imports:f,script:e,setScript:r}),(0,i.jsx)(h,{language:"javascript",content:null===n?"":"success"===n.type?n.content:n.error.message})]}),(0,i.jsx)("footer",{className:x().footer,children:(0,i.jsxs)("p",{children:["Made with  by ",(0,i.jsx)("a",{href:"https://github.com/samchon",children:"Samchon"}),"."]})})]})};var v=I},9369:function(e,t,n){"use strict";var a=n(5893);n(7294);let r={logo:()=>(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("img",{src:"/favicon/android-chrome-192x192.png",width:32,height:32}),(0,a.jsx)("span",{style:{fontWeight:"bold",fontSize:"1.2rem",paddingLeft:10,paddingRight:10},children:"Typia"}),(0,a.jsx)("span",{children:"Superfast Runtime Validator"})]}),project:{link:"https://github.com/samchon/typia",icon:(0,a.jsx)("img",{alt:"Typia Github repo stars",src:"https://img.shields.io/github/stars/samchon/typia?style=social"})},docsRepositoryBase:"https://github.com/samchon/typia/blob/master/website",footer:{text:()=>(0,a.jsxs)("span",{children:["Made by"," ",(0,a.jsx)("a",{href:"https://github.com/samchon",target:"_blank",style:{color:"blue"},children:(0,a.jsx)("u",{children:" Samchon "})})]})},useNextSeoProps:()=>({defaultTitle:"Typia Guide Documents",titleTemplate:"Typia Guide Documents - %s",additionalLinkTags:[{rel:"apple-touch-icon",sizes:"180x180",href:"/favicon/apple-touch-icon.png"},{rel:"manifest",href:"/favicon/site.webmanifest"},...[16,32].map(e=>({rel:"icon",type:"image/png",sizes:"".concat(e,"x").concat(e),href:"/favicon/favicon-".concat(e,"x").concat(e,".png")}))],additionalMetaTags:[{property:"og:image",content:"/og.jpg"},{property:"og:type",content:"object"},{property:"og:title",content:"Typia Guide Documents"},{property:"og:description",content:"Superfast Runtime Validator with only one line"},{property:"og:site_name",content:"Typia Guide Documents"},{property:"og:url",content:"https://typia.io"},{name:"twitter:card",content:"summary"},{name:"twitter:image",content:"https://typia.io/og.jpg"},{name:"twitter:title",content:"Typia Guide Documents"},{name:"twitter:description",content:"Superfast Runtime Validator with only one line"},{name:"twitter:site",content:"@SamchonGithub"}]})};t.Z=r},2571:function(e){e.exports={header:"layout_header__2Q6Ab",footer:"layout_footer__MKiK_",button:"layout_button__262nO",runSection:"layout_runSection__l8m2m",runSectionResult:"layout_runSectionResult__W_yRQ"}},3411:function(e){function t(e){var t=Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=function(){return[]},t.resolve=t,t.id=3411,e.exports=t},2183:function(){},3024:function(){},2715:function(){},3611:function(){},8353:function(){},1210:function(){},3454:function(){}},function(e){e.O(0,[138,70,774,888,179],function(){return e(e.s=3746)}),_N_E=e.O()}]);